// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"net/url"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
	"github.com/shopspring/decimal"
	"github.com/thaiha1607/foursquare_server/ent/conversation"
	"github.com/thaiha1607/foursquare_server/ent/financialtransaction"
	"github.com/thaiha1607/foursquare_server/ent/invoice"
	"github.com/thaiha1607/foursquare_server/ent/invoicelineitem"
	"github.com/thaiha1607/foursquare_server/ent/invoicetype"
	"github.com/thaiha1607/foursquare_server/ent/message"
	"github.com/thaiha1607/foursquare_server/ent/order"
	"github.com/thaiha1607/foursquare_server/ent/orderlineitem"
	"github.com/thaiha1607/foursquare_server/ent/orderstatuscode"
	"github.com/thaiha1607/foursquare_server/ent/ordertype"
	"github.com/thaiha1607/foursquare_server/ent/predicate"
	"github.com/thaiha1607/foursquare_server/ent/product"
	"github.com/thaiha1607/foursquare_server/ent/producttag"
	"github.com/thaiha1607/foursquare_server/ent/tag"
	"github.com/thaiha1607/foursquare_server/ent/transactiontype"
	"github.com/thaiha1607/foursquare_server/ent/user"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeConversation         = "Conversation"
	TypeFinancialTransaction = "FinancialTransaction"
	TypeInvoice              = "Invoice"
	TypeInvoiceLineItem      = "InvoiceLineItem"
	TypeInvoiceType          = "InvoiceType"
	TypeMessage              = "Message"
	TypeOrder                = "Order"
	TypeOrderLineItem        = "OrderLineItem"
	TypeOrderStatusCode      = "OrderStatusCode"
	TypeOrderType            = "OrderType"
	TypeProduct              = "Product"
	TypeProductTag           = "ProductTag"
	TypeTag                  = "Tag"
	TypeTransactionType      = "TransactionType"
	TypeUser                 = "User"
)

// ConversationMutation represents an operation that mutates the Conversation nodes in the graph.
type ConversationMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	created_at      *time.Time
	updated_at      *time.Time
	title           *string
	clearedFields   map[string]struct{}
	user_one        *uuid.UUID
	cleareduser_one bool
	user_two        *uuid.UUID
	cleareduser_two bool
	done            bool
	oldValue        func(context.Context) (*Conversation, error)
	predicates      []predicate.Conversation
}

var _ ent.Mutation = (*ConversationMutation)(nil)

// conversationOption allows management of the mutation configuration using functional options.
type conversationOption func(*ConversationMutation)

// newConversationMutation creates new mutation for the Conversation entity.
func newConversationMutation(c config, op Op, opts ...conversationOption) *ConversationMutation {
	m := &ConversationMutation{
		config:        c,
		op:            op,
		typ:           TypeConversation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConversationID sets the ID field of the mutation.
func withConversationID(id uuid.UUID) conversationOption {
	return func(m *ConversationMutation) {
		var (
			err   error
			once  sync.Once
			value *Conversation
		)
		m.oldValue = func(ctx context.Context) (*Conversation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Conversation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConversation sets the old Conversation of the mutation.
func withConversation(node *Conversation) conversationOption {
	return func(m *ConversationMutation) {
		m.oldValue = func(context.Context) (*Conversation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConversationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConversationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Conversation entities.
func (m *ConversationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ConversationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ConversationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Conversation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ConversationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ConversationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Conversation entity.
// If the Conversation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConversationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ConversationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ConversationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ConversationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Conversation entity.
// If the Conversation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConversationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ConversationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTitle sets the "title" field.
func (m *ConversationMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ConversationMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Conversation entity.
// If the Conversation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConversationMutation) OldTitle(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *ConversationMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[conversation.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *ConversationMutation) TitleCleared() bool {
	_, ok := m.clearedFields[conversation.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *ConversationMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, conversation.FieldTitle)
}

// SetUserOneID sets the "user_one_id" field.
func (m *ConversationMutation) SetUserOneID(u uuid.UUID) {
	m.user_one = &u
}

// UserOneID returns the value of the "user_one_id" field in the mutation.
func (m *ConversationMutation) UserOneID() (r uuid.UUID, exists bool) {
	v := m.user_one
	if v == nil {
		return
	}
	return *v, true
}

// OldUserOneID returns the old "user_one_id" field's value of the Conversation entity.
// If the Conversation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConversationMutation) OldUserOneID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserOneID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserOneID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserOneID: %w", err)
	}
	return oldValue.UserOneID, nil
}

// ResetUserOneID resets all changes to the "user_one_id" field.
func (m *ConversationMutation) ResetUserOneID() {
	m.user_one = nil
}

// SetUserTwoID sets the "user_two_id" field.
func (m *ConversationMutation) SetUserTwoID(u uuid.UUID) {
	m.user_two = &u
}

// UserTwoID returns the value of the "user_two_id" field in the mutation.
func (m *ConversationMutation) UserTwoID() (r uuid.UUID, exists bool) {
	v := m.user_two
	if v == nil {
		return
	}
	return *v, true
}

// OldUserTwoID returns the old "user_two_id" field's value of the Conversation entity.
// If the Conversation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConversationMutation) OldUserTwoID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserTwoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserTwoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserTwoID: %w", err)
	}
	return oldValue.UserTwoID, nil
}

// ResetUserTwoID resets all changes to the "user_two_id" field.
func (m *ConversationMutation) ResetUserTwoID() {
	m.user_two = nil
}

// ClearUserOne clears the "user_one" edge to the User entity.
func (m *ConversationMutation) ClearUserOne() {
	m.cleareduser_one = true
	m.clearedFields[conversation.FieldUserOneID] = struct{}{}
}

// UserOneCleared reports if the "user_one" edge to the User entity was cleared.
func (m *ConversationMutation) UserOneCleared() bool {
	return m.cleareduser_one
}

// UserOneIDs returns the "user_one" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserOneID instead. It exists only for internal usage by the builders.
func (m *ConversationMutation) UserOneIDs() (ids []uuid.UUID) {
	if id := m.user_one; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUserOne resets all changes to the "user_one" edge.
func (m *ConversationMutation) ResetUserOne() {
	m.user_one = nil
	m.cleareduser_one = false
}

// ClearUserTwo clears the "user_two" edge to the User entity.
func (m *ConversationMutation) ClearUserTwo() {
	m.cleareduser_two = true
	m.clearedFields[conversation.FieldUserTwoID] = struct{}{}
}

// UserTwoCleared reports if the "user_two" edge to the User entity was cleared.
func (m *ConversationMutation) UserTwoCleared() bool {
	return m.cleareduser_two
}

// UserTwoIDs returns the "user_two" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserTwoID instead. It exists only for internal usage by the builders.
func (m *ConversationMutation) UserTwoIDs() (ids []uuid.UUID) {
	if id := m.user_two; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUserTwo resets all changes to the "user_two" edge.
func (m *ConversationMutation) ResetUserTwo() {
	m.user_two = nil
	m.cleareduser_two = false
}

// Where appends a list predicates to the ConversationMutation builder.
func (m *ConversationMutation) Where(ps ...predicate.Conversation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ConversationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ConversationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Conversation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ConversationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ConversationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Conversation).
func (m *ConversationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ConversationMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, conversation.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, conversation.FieldUpdatedAt)
	}
	if m.title != nil {
		fields = append(fields, conversation.FieldTitle)
	}
	if m.user_one != nil {
		fields = append(fields, conversation.FieldUserOneID)
	}
	if m.user_two != nil {
		fields = append(fields, conversation.FieldUserTwoID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ConversationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case conversation.FieldCreatedAt:
		return m.CreatedAt()
	case conversation.FieldUpdatedAt:
		return m.UpdatedAt()
	case conversation.FieldTitle:
		return m.Title()
	case conversation.FieldUserOneID:
		return m.UserOneID()
	case conversation.FieldUserTwoID:
		return m.UserTwoID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ConversationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case conversation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case conversation.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case conversation.FieldTitle:
		return m.OldTitle(ctx)
	case conversation.FieldUserOneID:
		return m.OldUserOneID(ctx)
	case conversation.FieldUserTwoID:
		return m.OldUserTwoID(ctx)
	}
	return nil, fmt.Errorf("unknown Conversation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConversationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case conversation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case conversation.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case conversation.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case conversation.FieldUserOneID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserOneID(v)
		return nil
	case conversation.FieldUserTwoID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserTwoID(v)
		return nil
	}
	return fmt.Errorf("unknown Conversation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ConversationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ConversationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConversationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Conversation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ConversationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(conversation.FieldTitle) {
		fields = append(fields, conversation.FieldTitle)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ConversationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConversationMutation) ClearField(name string) error {
	switch name {
	case conversation.FieldTitle:
		m.ClearTitle()
		return nil
	}
	return fmt.Errorf("unknown Conversation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ConversationMutation) ResetField(name string) error {
	switch name {
	case conversation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case conversation.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case conversation.FieldTitle:
		m.ResetTitle()
		return nil
	case conversation.FieldUserOneID:
		m.ResetUserOneID()
		return nil
	case conversation.FieldUserTwoID:
		m.ResetUserTwoID()
		return nil
	}
	return fmt.Errorf("unknown Conversation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ConversationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user_one != nil {
		edges = append(edges, conversation.EdgeUserOne)
	}
	if m.user_two != nil {
		edges = append(edges, conversation.EdgeUserTwo)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ConversationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case conversation.EdgeUserOne:
		if id := m.user_one; id != nil {
			return []ent.Value{*id}
		}
	case conversation.EdgeUserTwo:
		if id := m.user_two; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ConversationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ConversationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ConversationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser_one {
		edges = append(edges, conversation.EdgeUserOne)
	}
	if m.cleareduser_two {
		edges = append(edges, conversation.EdgeUserTwo)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ConversationMutation) EdgeCleared(name string) bool {
	switch name {
	case conversation.EdgeUserOne:
		return m.cleareduser_one
	case conversation.EdgeUserTwo:
		return m.cleareduser_two
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ConversationMutation) ClearEdge(name string) error {
	switch name {
	case conversation.EdgeUserOne:
		m.ClearUserOne()
		return nil
	case conversation.EdgeUserTwo:
		m.ClearUserTwo()
		return nil
	}
	return fmt.Errorf("unknown Conversation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ConversationMutation) ResetEdge(name string) error {
	switch name {
	case conversation.EdgeUserOne:
		m.ResetUserOne()
		return nil
	case conversation.EdgeUserTwo:
		m.ResetUserTwo()
		return nil
	}
	return fmt.Errorf("unknown Conversation edge %s", name)
}

// FinancialTransactionMutation represents an operation that mutates the FinancialTransaction nodes in the graph.
type FinancialTransactionMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	created_at              *time.Time
	updated_at              *time.Time
	amount                  *decimal.Decimal
	addamount               *decimal.Decimal
	comment                 *string
	payment_method          *financialtransaction.PaymentMethod
	clearedFields           map[string]struct{}
	invoice                 *uuid.UUID
	clearedinvoice          bool
	transaction_type        *int
	clearedtransaction_type bool
	done                    bool
	oldValue                func(context.Context) (*FinancialTransaction, error)
	predicates              []predicate.FinancialTransaction
}

var _ ent.Mutation = (*FinancialTransactionMutation)(nil)

// financialtransactionOption allows management of the mutation configuration using functional options.
type financialtransactionOption func(*FinancialTransactionMutation)

// newFinancialTransactionMutation creates new mutation for the FinancialTransaction entity.
func newFinancialTransactionMutation(c config, op Op, opts ...financialtransactionOption) *FinancialTransactionMutation {
	m := &FinancialTransactionMutation{
		config:        c,
		op:            op,
		typ:           TypeFinancialTransaction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFinancialTransactionID sets the ID field of the mutation.
func withFinancialTransactionID(id uuid.UUID) financialtransactionOption {
	return func(m *FinancialTransactionMutation) {
		var (
			err   error
			once  sync.Once
			value *FinancialTransaction
		)
		m.oldValue = func(ctx context.Context) (*FinancialTransaction, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FinancialTransaction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFinancialTransaction sets the old FinancialTransaction of the mutation.
func withFinancialTransaction(node *FinancialTransaction) financialtransactionOption {
	return func(m *FinancialTransactionMutation) {
		m.oldValue = func(context.Context) (*FinancialTransaction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FinancialTransactionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FinancialTransactionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FinancialTransaction entities.
func (m *FinancialTransactionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FinancialTransactionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FinancialTransactionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FinancialTransaction.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FinancialTransactionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FinancialTransactionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FinancialTransaction entity.
// If the FinancialTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FinancialTransactionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FinancialTransactionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FinancialTransactionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FinancialTransactionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FinancialTransaction entity.
// If the FinancialTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FinancialTransactionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FinancialTransactionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetInvoiceID sets the "invoice_id" field.
func (m *FinancialTransactionMutation) SetInvoiceID(u uuid.UUID) {
	m.invoice = &u
}

// InvoiceID returns the value of the "invoice_id" field in the mutation.
func (m *FinancialTransactionMutation) InvoiceID() (r uuid.UUID, exists bool) {
	v := m.invoice
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceID returns the old "invoice_id" field's value of the FinancialTransaction entity.
// If the FinancialTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FinancialTransactionMutation) OldInvoiceID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceID: %w", err)
	}
	return oldValue.InvoiceID, nil
}

// ResetInvoiceID resets all changes to the "invoice_id" field.
func (m *FinancialTransactionMutation) ResetInvoiceID() {
	m.invoice = nil
}

// SetAmount sets the "amount" field.
func (m *FinancialTransactionMutation) SetAmount(d decimal.Decimal) {
	m.amount = &d
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *FinancialTransactionMutation) Amount() (r decimal.Decimal, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the FinancialTransaction entity.
// If the FinancialTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FinancialTransactionMutation) OldAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds d to the "amount" field.
func (m *FinancialTransactionMutation) AddAmount(d decimal.Decimal) {
	if m.addamount != nil {
		*m.addamount = m.addamount.Add(d)
	} else {
		m.addamount = &d
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *FinancialTransactionMutation) AddedAmount() (r decimal.Decimal, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *FinancialTransactionMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetComment sets the "comment" field.
func (m *FinancialTransactionMutation) SetComment(s string) {
	m.comment = &s
}

// Comment returns the value of the "comment" field in the mutation.
func (m *FinancialTransactionMutation) Comment() (r string, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldComment returns the old "comment" field's value of the FinancialTransaction entity.
// If the FinancialTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FinancialTransactionMutation) OldComment(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComment: %w", err)
	}
	return oldValue.Comment, nil
}

// ClearComment clears the value of the "comment" field.
func (m *FinancialTransactionMutation) ClearComment() {
	m.comment = nil
	m.clearedFields[financialtransaction.FieldComment] = struct{}{}
}

// CommentCleared returns if the "comment" field was cleared in this mutation.
func (m *FinancialTransactionMutation) CommentCleared() bool {
	_, ok := m.clearedFields[financialtransaction.FieldComment]
	return ok
}

// ResetComment resets all changes to the "comment" field.
func (m *FinancialTransactionMutation) ResetComment() {
	m.comment = nil
	delete(m.clearedFields, financialtransaction.FieldComment)
}

// SetType sets the "type" field.
func (m *FinancialTransactionMutation) SetType(i int) {
	m.transaction_type = &i
}

// GetType returns the value of the "type" field in the mutation.
func (m *FinancialTransactionMutation) GetType() (r int, exists bool) {
	v := m.transaction_type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the FinancialTransaction entity.
// If the FinancialTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FinancialTransactionMutation) OldType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *FinancialTransactionMutation) ResetType() {
	m.transaction_type = nil
}

// SetPaymentMethod sets the "payment_method" field.
func (m *FinancialTransactionMutation) SetPaymentMethod(fm financialtransaction.PaymentMethod) {
	m.payment_method = &fm
}

// PaymentMethod returns the value of the "payment_method" field in the mutation.
func (m *FinancialTransactionMutation) PaymentMethod() (r financialtransaction.PaymentMethod, exists bool) {
	v := m.payment_method
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentMethod returns the old "payment_method" field's value of the FinancialTransaction entity.
// If the FinancialTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FinancialTransactionMutation) OldPaymentMethod(ctx context.Context) (v financialtransaction.PaymentMethod, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentMethod: %w", err)
	}
	return oldValue.PaymentMethod, nil
}

// ResetPaymentMethod resets all changes to the "payment_method" field.
func (m *FinancialTransactionMutation) ResetPaymentMethod() {
	m.payment_method = nil
}

// ClearInvoice clears the "invoice" edge to the Invoice entity.
func (m *FinancialTransactionMutation) ClearInvoice() {
	m.clearedinvoice = true
	m.clearedFields[financialtransaction.FieldInvoiceID] = struct{}{}
}

// InvoiceCleared reports if the "invoice" edge to the Invoice entity was cleared.
func (m *FinancialTransactionMutation) InvoiceCleared() bool {
	return m.clearedinvoice
}

// InvoiceIDs returns the "invoice" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InvoiceID instead. It exists only for internal usage by the builders.
func (m *FinancialTransactionMutation) InvoiceIDs() (ids []uuid.UUID) {
	if id := m.invoice; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInvoice resets all changes to the "invoice" edge.
func (m *FinancialTransactionMutation) ResetInvoice() {
	m.invoice = nil
	m.clearedinvoice = false
}

// SetTransactionTypeID sets the "transaction_type" edge to the TransactionType entity by id.
func (m *FinancialTransactionMutation) SetTransactionTypeID(id int) {
	m.transaction_type = &id
}

// ClearTransactionType clears the "transaction_type" edge to the TransactionType entity.
func (m *FinancialTransactionMutation) ClearTransactionType() {
	m.clearedtransaction_type = true
	m.clearedFields[financialtransaction.FieldType] = struct{}{}
}

// TransactionTypeCleared reports if the "transaction_type" edge to the TransactionType entity was cleared.
func (m *FinancialTransactionMutation) TransactionTypeCleared() bool {
	return m.clearedtransaction_type
}

// TransactionTypeID returns the "transaction_type" edge ID in the mutation.
func (m *FinancialTransactionMutation) TransactionTypeID() (id int, exists bool) {
	if m.transaction_type != nil {
		return *m.transaction_type, true
	}
	return
}

// TransactionTypeIDs returns the "transaction_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TransactionTypeID instead. It exists only for internal usage by the builders.
func (m *FinancialTransactionMutation) TransactionTypeIDs() (ids []int) {
	if id := m.transaction_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTransactionType resets all changes to the "transaction_type" edge.
func (m *FinancialTransactionMutation) ResetTransactionType() {
	m.transaction_type = nil
	m.clearedtransaction_type = false
}

// Where appends a list predicates to the FinancialTransactionMutation builder.
func (m *FinancialTransactionMutation) Where(ps ...predicate.FinancialTransaction) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FinancialTransactionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FinancialTransactionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FinancialTransaction, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FinancialTransactionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FinancialTransactionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FinancialTransaction).
func (m *FinancialTransactionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FinancialTransactionMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, financialtransaction.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, financialtransaction.FieldUpdatedAt)
	}
	if m.invoice != nil {
		fields = append(fields, financialtransaction.FieldInvoiceID)
	}
	if m.amount != nil {
		fields = append(fields, financialtransaction.FieldAmount)
	}
	if m.comment != nil {
		fields = append(fields, financialtransaction.FieldComment)
	}
	if m.transaction_type != nil {
		fields = append(fields, financialtransaction.FieldType)
	}
	if m.payment_method != nil {
		fields = append(fields, financialtransaction.FieldPaymentMethod)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FinancialTransactionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case financialtransaction.FieldCreatedAt:
		return m.CreatedAt()
	case financialtransaction.FieldUpdatedAt:
		return m.UpdatedAt()
	case financialtransaction.FieldInvoiceID:
		return m.InvoiceID()
	case financialtransaction.FieldAmount:
		return m.Amount()
	case financialtransaction.FieldComment:
		return m.Comment()
	case financialtransaction.FieldType:
		return m.GetType()
	case financialtransaction.FieldPaymentMethod:
		return m.PaymentMethod()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FinancialTransactionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case financialtransaction.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case financialtransaction.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case financialtransaction.FieldInvoiceID:
		return m.OldInvoiceID(ctx)
	case financialtransaction.FieldAmount:
		return m.OldAmount(ctx)
	case financialtransaction.FieldComment:
		return m.OldComment(ctx)
	case financialtransaction.FieldType:
		return m.OldType(ctx)
	case financialtransaction.FieldPaymentMethod:
		return m.OldPaymentMethod(ctx)
	}
	return nil, fmt.Errorf("unknown FinancialTransaction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FinancialTransactionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case financialtransaction.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case financialtransaction.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case financialtransaction.FieldInvoiceID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceID(v)
		return nil
	case financialtransaction.FieldAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case financialtransaction.FieldComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComment(v)
		return nil
	case financialtransaction.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case financialtransaction.FieldPaymentMethod:
		v, ok := value.(financialtransaction.PaymentMethod)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentMethod(v)
		return nil
	}
	return fmt.Errorf("unknown FinancialTransaction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FinancialTransactionMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, financialtransaction.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FinancialTransactionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case financialtransaction.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FinancialTransactionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case financialtransaction.FieldAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown FinancialTransaction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FinancialTransactionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(financialtransaction.FieldComment) {
		fields = append(fields, financialtransaction.FieldComment)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FinancialTransactionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FinancialTransactionMutation) ClearField(name string) error {
	switch name {
	case financialtransaction.FieldComment:
		m.ClearComment()
		return nil
	}
	return fmt.Errorf("unknown FinancialTransaction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FinancialTransactionMutation) ResetField(name string) error {
	switch name {
	case financialtransaction.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case financialtransaction.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case financialtransaction.FieldInvoiceID:
		m.ResetInvoiceID()
		return nil
	case financialtransaction.FieldAmount:
		m.ResetAmount()
		return nil
	case financialtransaction.FieldComment:
		m.ResetComment()
		return nil
	case financialtransaction.FieldType:
		m.ResetType()
		return nil
	case financialtransaction.FieldPaymentMethod:
		m.ResetPaymentMethod()
		return nil
	}
	return fmt.Errorf("unknown FinancialTransaction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FinancialTransactionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.invoice != nil {
		edges = append(edges, financialtransaction.EdgeInvoice)
	}
	if m.transaction_type != nil {
		edges = append(edges, financialtransaction.EdgeTransactionType)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FinancialTransactionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case financialtransaction.EdgeInvoice:
		if id := m.invoice; id != nil {
			return []ent.Value{*id}
		}
	case financialtransaction.EdgeTransactionType:
		if id := m.transaction_type; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FinancialTransactionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FinancialTransactionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FinancialTransactionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedinvoice {
		edges = append(edges, financialtransaction.EdgeInvoice)
	}
	if m.clearedtransaction_type {
		edges = append(edges, financialtransaction.EdgeTransactionType)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FinancialTransactionMutation) EdgeCleared(name string) bool {
	switch name {
	case financialtransaction.EdgeInvoice:
		return m.clearedinvoice
	case financialtransaction.EdgeTransactionType:
		return m.clearedtransaction_type
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FinancialTransactionMutation) ClearEdge(name string) error {
	switch name {
	case financialtransaction.EdgeInvoice:
		m.ClearInvoice()
		return nil
	case financialtransaction.EdgeTransactionType:
		m.ClearTransactionType()
		return nil
	}
	return fmt.Errorf("unknown FinancialTransaction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FinancialTransactionMutation) ResetEdge(name string) error {
	switch name {
	case financialtransaction.EdgeInvoice:
		m.ResetInvoice()
		return nil
	case financialtransaction.EdgeTransactionType:
		m.ResetTransactionType()
		return nil
	}
	return fmt.Errorf("unknown FinancialTransaction edge %s", name)
}

// InvoiceMutation represents an operation that mutates the Invoice nodes in the graph.
type InvoiceMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	created_at          *time.Time
	updated_at          *time.Time
	total               *decimal.Decimal
	addtotal            *decimal.Decimal
	comment             *string
	note                *string
	status              *invoice.Status
	clearedFields       map[string]struct{}
	_order              *uuid.UUID
	cleared_order       bool
	invoice_type        *int
	clearedinvoice_type bool
	done                bool
	oldValue            func(context.Context) (*Invoice, error)
	predicates          []predicate.Invoice
}

var _ ent.Mutation = (*InvoiceMutation)(nil)

// invoiceOption allows management of the mutation configuration using functional options.
type invoiceOption func(*InvoiceMutation)

// newInvoiceMutation creates new mutation for the Invoice entity.
func newInvoiceMutation(c config, op Op, opts ...invoiceOption) *InvoiceMutation {
	m := &InvoiceMutation{
		config:        c,
		op:            op,
		typ:           TypeInvoice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInvoiceID sets the ID field of the mutation.
func withInvoiceID(id uuid.UUID) invoiceOption {
	return func(m *InvoiceMutation) {
		var (
			err   error
			once  sync.Once
			value *Invoice
		)
		m.oldValue = func(ctx context.Context) (*Invoice, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Invoice.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInvoice sets the old Invoice of the mutation.
func withInvoice(node *Invoice) invoiceOption {
	return func(m *InvoiceMutation) {
		m.oldValue = func(context.Context) (*Invoice, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InvoiceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InvoiceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Invoice entities.
func (m *InvoiceMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InvoiceMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InvoiceMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Invoice.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *InvoiceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InvoiceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InvoiceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *InvoiceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *InvoiceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *InvoiceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetOrderID sets the "order_id" field.
func (m *InvoiceMutation) SetOrderID(u uuid.UUID) {
	m._order = &u
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *InvoiceMutation) OrderID() (r uuid.UUID, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldOrderID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *InvoiceMutation) ResetOrderID() {
	m._order = nil
}

// SetTotal sets the "total" field.
func (m *InvoiceMutation) SetTotal(d decimal.Decimal) {
	m.total = &d
	m.addtotal = nil
}

// Total returns the value of the "total" field in the mutation.
func (m *InvoiceMutation) Total() (r decimal.Decimal, exists bool) {
	v := m.total
	if v == nil {
		return
	}
	return *v, true
}

// OldTotal returns the old "total" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldTotal(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotal: %w", err)
	}
	return oldValue.Total, nil
}

// AddTotal adds d to the "total" field.
func (m *InvoiceMutation) AddTotal(d decimal.Decimal) {
	if m.addtotal != nil {
		*m.addtotal = m.addtotal.Add(d)
	} else {
		m.addtotal = &d
	}
}

// AddedTotal returns the value that was added to the "total" field in this mutation.
func (m *InvoiceMutation) AddedTotal() (r decimal.Decimal, exists bool) {
	v := m.addtotal
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotal resets all changes to the "total" field.
func (m *InvoiceMutation) ResetTotal() {
	m.total = nil
	m.addtotal = nil
}

// SetComment sets the "comment" field.
func (m *InvoiceMutation) SetComment(s string) {
	m.comment = &s
}

// Comment returns the value of the "comment" field in the mutation.
func (m *InvoiceMutation) Comment() (r string, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldComment returns the old "comment" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldComment(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComment: %w", err)
	}
	return oldValue.Comment, nil
}

// ClearComment clears the value of the "comment" field.
func (m *InvoiceMutation) ClearComment() {
	m.comment = nil
	m.clearedFields[invoice.FieldComment] = struct{}{}
}

// CommentCleared returns if the "comment" field was cleared in this mutation.
func (m *InvoiceMutation) CommentCleared() bool {
	_, ok := m.clearedFields[invoice.FieldComment]
	return ok
}

// ResetComment resets all changes to the "comment" field.
func (m *InvoiceMutation) ResetComment() {
	m.comment = nil
	delete(m.clearedFields, invoice.FieldComment)
}

// SetNote sets the "note" field.
func (m *InvoiceMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the value of the "note" field in the mutation.
func (m *InvoiceMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "note" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldNote(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ClearNote clears the value of the "note" field.
func (m *InvoiceMutation) ClearNote() {
	m.note = nil
	m.clearedFields[invoice.FieldNote] = struct{}{}
}

// NoteCleared returns if the "note" field was cleared in this mutation.
func (m *InvoiceMutation) NoteCleared() bool {
	_, ok := m.clearedFields[invoice.FieldNote]
	return ok
}

// ResetNote resets all changes to the "note" field.
func (m *InvoiceMutation) ResetNote() {
	m.note = nil
	delete(m.clearedFields, invoice.FieldNote)
}

// SetType sets the "type" field.
func (m *InvoiceMutation) SetType(i int) {
	m.invoice_type = &i
}

// GetType returns the value of the "type" field in the mutation.
func (m *InvoiceMutation) GetType() (r int, exists bool) {
	v := m.invoice_type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *InvoiceMutation) ResetType() {
	m.invoice_type = nil
}

// SetStatus sets the "status" field.
func (m *InvoiceMutation) SetStatus(i invoice.Status) {
	m.status = &i
}

// Status returns the value of the "status" field in the mutation.
func (m *InvoiceMutation) Status() (r invoice.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldStatus(ctx context.Context) (v invoice.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *InvoiceMutation) ResetStatus() {
	m.status = nil
}

// ClearOrder clears the "order" edge to the Order entity.
func (m *InvoiceMutation) ClearOrder() {
	m.cleared_order = true
	m.clearedFields[invoice.FieldOrderID] = struct{}{}
}

// OrderCleared reports if the "order" edge to the Order entity was cleared.
func (m *InvoiceMutation) OrderCleared() bool {
	return m.cleared_order
}

// OrderIDs returns the "order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderID instead. It exists only for internal usage by the builders.
func (m *InvoiceMutation) OrderIDs() (ids []uuid.UUID) {
	if id := m._order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrder resets all changes to the "order" edge.
func (m *InvoiceMutation) ResetOrder() {
	m._order = nil
	m.cleared_order = false
}

// SetInvoiceTypeID sets the "invoice_type" edge to the InvoiceType entity by id.
func (m *InvoiceMutation) SetInvoiceTypeID(id int) {
	m.invoice_type = &id
}

// ClearInvoiceType clears the "invoice_type" edge to the InvoiceType entity.
func (m *InvoiceMutation) ClearInvoiceType() {
	m.clearedinvoice_type = true
	m.clearedFields[invoice.FieldType] = struct{}{}
}

// InvoiceTypeCleared reports if the "invoice_type" edge to the InvoiceType entity was cleared.
func (m *InvoiceMutation) InvoiceTypeCleared() bool {
	return m.clearedinvoice_type
}

// InvoiceTypeID returns the "invoice_type" edge ID in the mutation.
func (m *InvoiceMutation) InvoiceTypeID() (id int, exists bool) {
	if m.invoice_type != nil {
		return *m.invoice_type, true
	}
	return
}

// InvoiceTypeIDs returns the "invoice_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InvoiceTypeID instead. It exists only for internal usage by the builders.
func (m *InvoiceMutation) InvoiceTypeIDs() (ids []int) {
	if id := m.invoice_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInvoiceType resets all changes to the "invoice_type" edge.
func (m *InvoiceMutation) ResetInvoiceType() {
	m.invoice_type = nil
	m.clearedinvoice_type = false
}

// Where appends a list predicates to the InvoiceMutation builder.
func (m *InvoiceMutation) Where(ps ...predicate.Invoice) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InvoiceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InvoiceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Invoice, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InvoiceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InvoiceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Invoice).
func (m *InvoiceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InvoiceMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, invoice.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, invoice.FieldUpdatedAt)
	}
	if m._order != nil {
		fields = append(fields, invoice.FieldOrderID)
	}
	if m.total != nil {
		fields = append(fields, invoice.FieldTotal)
	}
	if m.comment != nil {
		fields = append(fields, invoice.FieldComment)
	}
	if m.note != nil {
		fields = append(fields, invoice.FieldNote)
	}
	if m.invoice_type != nil {
		fields = append(fields, invoice.FieldType)
	}
	if m.status != nil {
		fields = append(fields, invoice.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InvoiceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case invoice.FieldCreatedAt:
		return m.CreatedAt()
	case invoice.FieldUpdatedAt:
		return m.UpdatedAt()
	case invoice.FieldOrderID:
		return m.OrderID()
	case invoice.FieldTotal:
		return m.Total()
	case invoice.FieldComment:
		return m.Comment()
	case invoice.FieldNote:
		return m.Note()
	case invoice.FieldType:
		return m.GetType()
	case invoice.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InvoiceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case invoice.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case invoice.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case invoice.FieldOrderID:
		return m.OldOrderID(ctx)
	case invoice.FieldTotal:
		return m.OldTotal(ctx)
	case invoice.FieldComment:
		return m.OldComment(ctx)
	case invoice.FieldNote:
		return m.OldNote(ctx)
	case invoice.FieldType:
		return m.OldType(ctx)
	case invoice.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Invoice field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvoiceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case invoice.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case invoice.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case invoice.FieldOrderID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case invoice.FieldTotal:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotal(v)
		return nil
	case invoice.FieldComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComment(v)
		return nil
	case invoice.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	case invoice.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case invoice.FieldStatus:
		v, ok := value.(invoice.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Invoice field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InvoiceMutation) AddedFields() []string {
	var fields []string
	if m.addtotal != nil {
		fields = append(fields, invoice.FieldTotal)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InvoiceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case invoice.FieldTotal:
		return m.AddedTotal()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvoiceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case invoice.FieldTotal:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotal(v)
		return nil
	}
	return fmt.Errorf("unknown Invoice numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InvoiceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(invoice.FieldComment) {
		fields = append(fields, invoice.FieldComment)
	}
	if m.FieldCleared(invoice.FieldNote) {
		fields = append(fields, invoice.FieldNote)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InvoiceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InvoiceMutation) ClearField(name string) error {
	switch name {
	case invoice.FieldComment:
		m.ClearComment()
		return nil
	case invoice.FieldNote:
		m.ClearNote()
		return nil
	}
	return fmt.Errorf("unknown Invoice nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InvoiceMutation) ResetField(name string) error {
	switch name {
	case invoice.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case invoice.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case invoice.FieldOrderID:
		m.ResetOrderID()
		return nil
	case invoice.FieldTotal:
		m.ResetTotal()
		return nil
	case invoice.FieldComment:
		m.ResetComment()
		return nil
	case invoice.FieldNote:
		m.ResetNote()
		return nil
	case invoice.FieldType:
		m.ResetType()
		return nil
	case invoice.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Invoice field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InvoiceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._order != nil {
		edges = append(edges, invoice.EdgeOrder)
	}
	if m.invoice_type != nil {
		edges = append(edges, invoice.EdgeInvoiceType)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InvoiceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case invoice.EdgeOrder:
		if id := m._order; id != nil {
			return []ent.Value{*id}
		}
	case invoice.EdgeInvoiceType:
		if id := m.invoice_type; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InvoiceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InvoiceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InvoiceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_order {
		edges = append(edges, invoice.EdgeOrder)
	}
	if m.clearedinvoice_type {
		edges = append(edges, invoice.EdgeInvoiceType)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InvoiceMutation) EdgeCleared(name string) bool {
	switch name {
	case invoice.EdgeOrder:
		return m.cleared_order
	case invoice.EdgeInvoiceType:
		return m.clearedinvoice_type
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InvoiceMutation) ClearEdge(name string) error {
	switch name {
	case invoice.EdgeOrder:
		m.ClearOrder()
		return nil
	case invoice.EdgeInvoiceType:
		m.ClearInvoiceType()
		return nil
	}
	return fmt.Errorf("unknown Invoice unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InvoiceMutation) ResetEdge(name string) error {
	switch name {
	case invoice.EdgeOrder:
		m.ResetOrder()
		return nil
	case invoice.EdgeInvoiceType:
		m.ResetInvoiceType()
		return nil
	}
	return fmt.Errorf("unknown Invoice edge %s", name)
}

// InvoiceLineItemMutation represents an operation that mutates the InvoiceLineItem nodes in the graph.
type InvoiceLineItemMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	created_at             *time.Time
	updated_at             *time.Time
	qty                    *decimal.Decimal
	addqty                 *decimal.Decimal
	total                  *decimal.Decimal
	addtotal               *decimal.Decimal
	clearedFields          map[string]struct{}
	invoice                *uuid.UUID
	clearedinvoice         bool
	order_line_item        *uuid.UUID
	clearedorder_line_item bool
	done                   bool
	oldValue               func(context.Context) (*InvoiceLineItem, error)
	predicates             []predicate.InvoiceLineItem
}

var _ ent.Mutation = (*InvoiceLineItemMutation)(nil)

// invoicelineitemOption allows management of the mutation configuration using functional options.
type invoicelineitemOption func(*InvoiceLineItemMutation)

// newInvoiceLineItemMutation creates new mutation for the InvoiceLineItem entity.
func newInvoiceLineItemMutation(c config, op Op, opts ...invoicelineitemOption) *InvoiceLineItemMutation {
	m := &InvoiceLineItemMutation{
		config:        c,
		op:            op,
		typ:           TypeInvoiceLineItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInvoiceLineItemID sets the ID field of the mutation.
func withInvoiceLineItemID(id uuid.UUID) invoicelineitemOption {
	return func(m *InvoiceLineItemMutation) {
		var (
			err   error
			once  sync.Once
			value *InvoiceLineItem
		)
		m.oldValue = func(ctx context.Context) (*InvoiceLineItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InvoiceLineItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInvoiceLineItem sets the old InvoiceLineItem of the mutation.
func withInvoiceLineItem(node *InvoiceLineItem) invoicelineitemOption {
	return func(m *InvoiceLineItemMutation) {
		m.oldValue = func(context.Context) (*InvoiceLineItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InvoiceLineItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InvoiceLineItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of InvoiceLineItem entities.
func (m *InvoiceLineItemMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InvoiceLineItemMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InvoiceLineItemMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InvoiceLineItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *InvoiceLineItemMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InvoiceLineItemMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the InvoiceLineItem entity.
// If the InvoiceLineItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceLineItemMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InvoiceLineItemMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *InvoiceLineItemMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *InvoiceLineItemMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the InvoiceLineItem entity.
// If the InvoiceLineItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceLineItemMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *InvoiceLineItemMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetInvoiceID sets the "invoice_id" field.
func (m *InvoiceLineItemMutation) SetInvoiceID(u uuid.UUID) {
	m.invoice = &u
}

// InvoiceID returns the value of the "invoice_id" field in the mutation.
func (m *InvoiceLineItemMutation) InvoiceID() (r uuid.UUID, exists bool) {
	v := m.invoice
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceID returns the old "invoice_id" field's value of the InvoiceLineItem entity.
// If the InvoiceLineItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceLineItemMutation) OldInvoiceID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceID: %w", err)
	}
	return oldValue.InvoiceID, nil
}

// ResetInvoiceID resets all changes to the "invoice_id" field.
func (m *InvoiceLineItemMutation) ResetInvoiceID() {
	m.invoice = nil
}

// SetOrderLineItemID sets the "order_line_item_id" field.
func (m *InvoiceLineItemMutation) SetOrderLineItemID(u uuid.UUID) {
	m.order_line_item = &u
}

// OrderLineItemID returns the value of the "order_line_item_id" field in the mutation.
func (m *InvoiceLineItemMutation) OrderLineItemID() (r uuid.UUID, exists bool) {
	v := m.order_line_item
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderLineItemID returns the old "order_line_item_id" field's value of the InvoiceLineItem entity.
// If the InvoiceLineItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceLineItemMutation) OldOrderLineItemID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderLineItemID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderLineItemID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderLineItemID: %w", err)
	}
	return oldValue.OrderLineItemID, nil
}

// ResetOrderLineItemID resets all changes to the "order_line_item_id" field.
func (m *InvoiceLineItemMutation) ResetOrderLineItemID() {
	m.order_line_item = nil
}

// SetQty sets the "qty" field.
func (m *InvoiceLineItemMutation) SetQty(d decimal.Decimal) {
	m.qty = &d
	m.addqty = nil
}

// Qty returns the value of the "qty" field in the mutation.
func (m *InvoiceLineItemMutation) Qty() (r decimal.Decimal, exists bool) {
	v := m.qty
	if v == nil {
		return
	}
	return *v, true
}

// OldQty returns the old "qty" field's value of the InvoiceLineItem entity.
// If the InvoiceLineItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceLineItemMutation) OldQty(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQty: %w", err)
	}
	return oldValue.Qty, nil
}

// AddQty adds d to the "qty" field.
func (m *InvoiceLineItemMutation) AddQty(d decimal.Decimal) {
	if m.addqty != nil {
		*m.addqty = m.addqty.Add(d)
	} else {
		m.addqty = &d
	}
}

// AddedQty returns the value that was added to the "qty" field in this mutation.
func (m *InvoiceLineItemMutation) AddedQty() (r decimal.Decimal, exists bool) {
	v := m.addqty
	if v == nil {
		return
	}
	return *v, true
}

// ResetQty resets all changes to the "qty" field.
func (m *InvoiceLineItemMutation) ResetQty() {
	m.qty = nil
	m.addqty = nil
}

// SetTotal sets the "total" field.
func (m *InvoiceLineItemMutation) SetTotal(d decimal.Decimal) {
	m.total = &d
	m.addtotal = nil
}

// Total returns the value of the "total" field in the mutation.
func (m *InvoiceLineItemMutation) Total() (r decimal.Decimal, exists bool) {
	v := m.total
	if v == nil {
		return
	}
	return *v, true
}

// OldTotal returns the old "total" field's value of the InvoiceLineItem entity.
// If the InvoiceLineItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceLineItemMutation) OldTotal(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotal: %w", err)
	}
	return oldValue.Total, nil
}

// AddTotal adds d to the "total" field.
func (m *InvoiceLineItemMutation) AddTotal(d decimal.Decimal) {
	if m.addtotal != nil {
		*m.addtotal = m.addtotal.Add(d)
	} else {
		m.addtotal = &d
	}
}

// AddedTotal returns the value that was added to the "total" field in this mutation.
func (m *InvoiceLineItemMutation) AddedTotal() (r decimal.Decimal, exists bool) {
	v := m.addtotal
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotal resets all changes to the "total" field.
func (m *InvoiceLineItemMutation) ResetTotal() {
	m.total = nil
	m.addtotal = nil
}

// ClearInvoice clears the "invoice" edge to the Invoice entity.
func (m *InvoiceLineItemMutation) ClearInvoice() {
	m.clearedinvoice = true
	m.clearedFields[invoicelineitem.FieldInvoiceID] = struct{}{}
}

// InvoiceCleared reports if the "invoice" edge to the Invoice entity was cleared.
func (m *InvoiceLineItemMutation) InvoiceCleared() bool {
	return m.clearedinvoice
}

// InvoiceIDs returns the "invoice" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InvoiceID instead. It exists only for internal usage by the builders.
func (m *InvoiceLineItemMutation) InvoiceIDs() (ids []uuid.UUID) {
	if id := m.invoice; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInvoice resets all changes to the "invoice" edge.
func (m *InvoiceLineItemMutation) ResetInvoice() {
	m.invoice = nil
	m.clearedinvoice = false
}

// ClearOrderLineItem clears the "order_line_item" edge to the OrderLineItem entity.
func (m *InvoiceLineItemMutation) ClearOrderLineItem() {
	m.clearedorder_line_item = true
	m.clearedFields[invoicelineitem.FieldOrderLineItemID] = struct{}{}
}

// OrderLineItemCleared reports if the "order_line_item" edge to the OrderLineItem entity was cleared.
func (m *InvoiceLineItemMutation) OrderLineItemCleared() bool {
	return m.clearedorder_line_item
}

// OrderLineItemIDs returns the "order_line_item" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderLineItemID instead. It exists only for internal usage by the builders.
func (m *InvoiceLineItemMutation) OrderLineItemIDs() (ids []uuid.UUID) {
	if id := m.order_line_item; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrderLineItem resets all changes to the "order_line_item" edge.
func (m *InvoiceLineItemMutation) ResetOrderLineItem() {
	m.order_line_item = nil
	m.clearedorder_line_item = false
}

// Where appends a list predicates to the InvoiceLineItemMutation builder.
func (m *InvoiceLineItemMutation) Where(ps ...predicate.InvoiceLineItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InvoiceLineItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InvoiceLineItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.InvoiceLineItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InvoiceLineItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InvoiceLineItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (InvoiceLineItem).
func (m *InvoiceLineItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InvoiceLineItemMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, invoicelineitem.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, invoicelineitem.FieldUpdatedAt)
	}
	if m.invoice != nil {
		fields = append(fields, invoicelineitem.FieldInvoiceID)
	}
	if m.order_line_item != nil {
		fields = append(fields, invoicelineitem.FieldOrderLineItemID)
	}
	if m.qty != nil {
		fields = append(fields, invoicelineitem.FieldQty)
	}
	if m.total != nil {
		fields = append(fields, invoicelineitem.FieldTotal)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InvoiceLineItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case invoicelineitem.FieldCreatedAt:
		return m.CreatedAt()
	case invoicelineitem.FieldUpdatedAt:
		return m.UpdatedAt()
	case invoicelineitem.FieldInvoiceID:
		return m.InvoiceID()
	case invoicelineitem.FieldOrderLineItemID:
		return m.OrderLineItemID()
	case invoicelineitem.FieldQty:
		return m.Qty()
	case invoicelineitem.FieldTotal:
		return m.Total()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InvoiceLineItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case invoicelineitem.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case invoicelineitem.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case invoicelineitem.FieldInvoiceID:
		return m.OldInvoiceID(ctx)
	case invoicelineitem.FieldOrderLineItemID:
		return m.OldOrderLineItemID(ctx)
	case invoicelineitem.FieldQty:
		return m.OldQty(ctx)
	case invoicelineitem.FieldTotal:
		return m.OldTotal(ctx)
	}
	return nil, fmt.Errorf("unknown InvoiceLineItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvoiceLineItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case invoicelineitem.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case invoicelineitem.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case invoicelineitem.FieldInvoiceID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceID(v)
		return nil
	case invoicelineitem.FieldOrderLineItemID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderLineItemID(v)
		return nil
	case invoicelineitem.FieldQty:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQty(v)
		return nil
	case invoicelineitem.FieldTotal:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotal(v)
		return nil
	}
	return fmt.Errorf("unknown InvoiceLineItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InvoiceLineItemMutation) AddedFields() []string {
	var fields []string
	if m.addqty != nil {
		fields = append(fields, invoicelineitem.FieldQty)
	}
	if m.addtotal != nil {
		fields = append(fields, invoicelineitem.FieldTotal)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InvoiceLineItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case invoicelineitem.FieldQty:
		return m.AddedQty()
	case invoicelineitem.FieldTotal:
		return m.AddedTotal()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvoiceLineItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case invoicelineitem.FieldQty:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQty(v)
		return nil
	case invoicelineitem.FieldTotal:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotal(v)
		return nil
	}
	return fmt.Errorf("unknown InvoiceLineItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InvoiceLineItemMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InvoiceLineItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InvoiceLineItemMutation) ClearField(name string) error {
	return fmt.Errorf("unknown InvoiceLineItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InvoiceLineItemMutation) ResetField(name string) error {
	switch name {
	case invoicelineitem.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case invoicelineitem.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case invoicelineitem.FieldInvoiceID:
		m.ResetInvoiceID()
		return nil
	case invoicelineitem.FieldOrderLineItemID:
		m.ResetOrderLineItemID()
		return nil
	case invoicelineitem.FieldQty:
		m.ResetQty()
		return nil
	case invoicelineitem.FieldTotal:
		m.ResetTotal()
		return nil
	}
	return fmt.Errorf("unknown InvoiceLineItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InvoiceLineItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.invoice != nil {
		edges = append(edges, invoicelineitem.EdgeInvoice)
	}
	if m.order_line_item != nil {
		edges = append(edges, invoicelineitem.EdgeOrderLineItem)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InvoiceLineItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case invoicelineitem.EdgeInvoice:
		if id := m.invoice; id != nil {
			return []ent.Value{*id}
		}
	case invoicelineitem.EdgeOrderLineItem:
		if id := m.order_line_item; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InvoiceLineItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InvoiceLineItemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InvoiceLineItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedinvoice {
		edges = append(edges, invoicelineitem.EdgeInvoice)
	}
	if m.clearedorder_line_item {
		edges = append(edges, invoicelineitem.EdgeOrderLineItem)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InvoiceLineItemMutation) EdgeCleared(name string) bool {
	switch name {
	case invoicelineitem.EdgeInvoice:
		return m.clearedinvoice
	case invoicelineitem.EdgeOrderLineItem:
		return m.clearedorder_line_item
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InvoiceLineItemMutation) ClearEdge(name string) error {
	switch name {
	case invoicelineitem.EdgeInvoice:
		m.ClearInvoice()
		return nil
	case invoicelineitem.EdgeOrderLineItem:
		m.ClearOrderLineItem()
		return nil
	}
	return fmt.Errorf("unknown InvoiceLineItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InvoiceLineItemMutation) ResetEdge(name string) error {
	switch name {
	case invoicelineitem.EdgeInvoice:
		m.ResetInvoice()
		return nil
	case invoicelineitem.EdgeOrderLineItem:
		m.ResetOrderLineItem()
		return nil
	}
	return fmt.Errorf("unknown InvoiceLineItem edge %s", name)
}

// InvoiceTypeMutation represents an operation that mutates the InvoiceType nodes in the graph.
type InvoiceTypeMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	invoice_type  *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*InvoiceType, error)
	predicates    []predicate.InvoiceType
}

var _ ent.Mutation = (*InvoiceTypeMutation)(nil)

// invoicetypeOption allows management of the mutation configuration using functional options.
type invoicetypeOption func(*InvoiceTypeMutation)

// newInvoiceTypeMutation creates new mutation for the InvoiceType entity.
func newInvoiceTypeMutation(c config, op Op, opts ...invoicetypeOption) *InvoiceTypeMutation {
	m := &InvoiceTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeInvoiceType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInvoiceTypeID sets the ID field of the mutation.
func withInvoiceTypeID(id int) invoicetypeOption {
	return func(m *InvoiceTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *InvoiceType
		)
		m.oldValue = func(ctx context.Context) (*InvoiceType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InvoiceType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInvoiceType sets the old InvoiceType of the mutation.
func withInvoiceType(node *InvoiceType) invoicetypeOption {
	return func(m *InvoiceTypeMutation) {
		m.oldValue = func(context.Context) (*InvoiceType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InvoiceTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InvoiceTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InvoiceTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InvoiceTypeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InvoiceType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *InvoiceTypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InvoiceTypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the InvoiceType entity.
// If the InvoiceType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceTypeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InvoiceTypeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *InvoiceTypeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *InvoiceTypeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the InvoiceType entity.
// If the InvoiceType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceTypeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *InvoiceTypeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetInvoiceType sets the "invoice_type" field.
func (m *InvoiceTypeMutation) SetInvoiceType(s string) {
	m.invoice_type = &s
}

// InvoiceType returns the value of the "invoice_type" field in the mutation.
func (m *InvoiceTypeMutation) InvoiceType() (r string, exists bool) {
	v := m.invoice_type
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceType returns the old "invoice_type" field's value of the InvoiceType entity.
// If the InvoiceType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceTypeMutation) OldInvoiceType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceType: %w", err)
	}
	return oldValue.InvoiceType, nil
}

// ResetInvoiceType resets all changes to the "invoice_type" field.
func (m *InvoiceTypeMutation) ResetInvoiceType() {
	m.invoice_type = nil
}

// Where appends a list predicates to the InvoiceTypeMutation builder.
func (m *InvoiceTypeMutation) Where(ps ...predicate.InvoiceType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InvoiceTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InvoiceTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.InvoiceType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InvoiceTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InvoiceTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (InvoiceType).
func (m *InvoiceTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InvoiceTypeMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, invoicetype.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, invoicetype.FieldUpdatedAt)
	}
	if m.invoice_type != nil {
		fields = append(fields, invoicetype.FieldInvoiceType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InvoiceTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case invoicetype.FieldCreatedAt:
		return m.CreatedAt()
	case invoicetype.FieldUpdatedAt:
		return m.UpdatedAt()
	case invoicetype.FieldInvoiceType:
		return m.InvoiceType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InvoiceTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case invoicetype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case invoicetype.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case invoicetype.FieldInvoiceType:
		return m.OldInvoiceType(ctx)
	}
	return nil, fmt.Errorf("unknown InvoiceType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvoiceTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case invoicetype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case invoicetype.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case invoicetype.FieldInvoiceType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceType(v)
		return nil
	}
	return fmt.Errorf("unknown InvoiceType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InvoiceTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InvoiceTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvoiceTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown InvoiceType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InvoiceTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InvoiceTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InvoiceTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown InvoiceType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InvoiceTypeMutation) ResetField(name string) error {
	switch name {
	case invoicetype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case invoicetype.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case invoicetype.FieldInvoiceType:
		m.ResetInvoiceType()
		return nil
	}
	return fmt.Errorf("unknown InvoiceType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InvoiceTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InvoiceTypeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InvoiceTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InvoiceTypeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InvoiceTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InvoiceTypeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InvoiceTypeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown InvoiceType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InvoiceTypeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown InvoiceType edge %s", name)
}

// MessageMutation represents an operation that mutates the Message nodes in the graph.
type MessageMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	created_at          *time.Time
	updated_at          *time.Time
	_type               *message.Type
	content             *string
	is_read             *bool
	clearedFields       map[string]struct{}
	conversation        *uuid.UUID
	clearedconversation bool
	sender              *uuid.UUID
	clearedsender       bool
	done                bool
	oldValue            func(context.Context) (*Message, error)
	predicates          []predicate.Message
}

var _ ent.Mutation = (*MessageMutation)(nil)

// messageOption allows management of the mutation configuration using functional options.
type messageOption func(*MessageMutation)

// newMessageMutation creates new mutation for the Message entity.
func newMessageMutation(c config, op Op, opts ...messageOption) *MessageMutation {
	m := &MessageMutation{
		config:        c,
		op:            op,
		typ:           TypeMessage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMessageID sets the ID field of the mutation.
func withMessageID(id uuid.UUID) messageOption {
	return func(m *MessageMutation) {
		var (
			err   error
			once  sync.Once
			value *Message
		)
		m.oldValue = func(ctx context.Context) (*Message, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Message.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMessage sets the old Message of the mutation.
func withMessage(node *Message) messageOption {
	return func(m *MessageMutation) {
		m.oldValue = func(context.Context) (*Message, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MessageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MessageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Message entities.
func (m *MessageMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MessageMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MessageMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Message.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MessageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MessageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MessageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MessageMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MessageMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MessageMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetConversationID sets the "conversation_id" field.
func (m *MessageMutation) SetConversationID(u uuid.UUID) {
	m.conversation = &u
}

// ConversationID returns the value of the "conversation_id" field in the mutation.
func (m *MessageMutation) ConversationID() (r uuid.UUID, exists bool) {
	v := m.conversation
	if v == nil {
		return
	}
	return *v, true
}

// OldConversationID returns the old "conversation_id" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldConversationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConversationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConversationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConversationID: %w", err)
	}
	return oldValue.ConversationID, nil
}

// ResetConversationID resets all changes to the "conversation_id" field.
func (m *MessageMutation) ResetConversationID() {
	m.conversation = nil
}

// SetSenderID sets the "sender_id" field.
func (m *MessageMutation) SetSenderID(u uuid.UUID) {
	m.sender = &u
}

// SenderID returns the value of the "sender_id" field in the mutation.
func (m *MessageMutation) SenderID() (r uuid.UUID, exists bool) {
	v := m.sender
	if v == nil {
		return
	}
	return *v, true
}

// OldSenderID returns the old "sender_id" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldSenderID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSenderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSenderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSenderID: %w", err)
	}
	return oldValue.SenderID, nil
}

// ResetSenderID resets all changes to the "sender_id" field.
func (m *MessageMutation) ResetSenderID() {
	m.sender = nil
}

// SetType sets the "type" field.
func (m *MessageMutation) SetType(value message.Type) {
	m._type = &value
}

// GetType returns the value of the "type" field in the mutation.
func (m *MessageMutation) GetType() (r message.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldType(ctx context.Context) (v message.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *MessageMutation) ResetType() {
	m._type = nil
}

// SetContent sets the "content" field.
func (m *MessageMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *MessageMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *MessageMutation) ResetContent() {
	m.content = nil
}

// SetIsRead sets the "is_read" field.
func (m *MessageMutation) SetIsRead(b bool) {
	m.is_read = &b
}

// IsRead returns the value of the "is_read" field in the mutation.
func (m *MessageMutation) IsRead() (r bool, exists bool) {
	v := m.is_read
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRead returns the old "is_read" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldIsRead(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsRead is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsRead requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRead: %w", err)
	}
	return oldValue.IsRead, nil
}

// ResetIsRead resets all changes to the "is_read" field.
func (m *MessageMutation) ResetIsRead() {
	m.is_read = nil
}

// ClearConversation clears the "conversation" edge to the Conversation entity.
func (m *MessageMutation) ClearConversation() {
	m.clearedconversation = true
	m.clearedFields[message.FieldConversationID] = struct{}{}
}

// ConversationCleared reports if the "conversation" edge to the Conversation entity was cleared.
func (m *MessageMutation) ConversationCleared() bool {
	return m.clearedconversation
}

// ConversationIDs returns the "conversation" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ConversationID instead. It exists only for internal usage by the builders.
func (m *MessageMutation) ConversationIDs() (ids []uuid.UUID) {
	if id := m.conversation; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConversation resets all changes to the "conversation" edge.
func (m *MessageMutation) ResetConversation() {
	m.conversation = nil
	m.clearedconversation = false
}

// ClearSender clears the "sender" edge to the User entity.
func (m *MessageMutation) ClearSender() {
	m.clearedsender = true
	m.clearedFields[message.FieldSenderID] = struct{}{}
}

// SenderCleared reports if the "sender" edge to the User entity was cleared.
func (m *MessageMutation) SenderCleared() bool {
	return m.clearedsender
}

// SenderIDs returns the "sender" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SenderID instead. It exists only for internal usage by the builders.
func (m *MessageMutation) SenderIDs() (ids []uuid.UUID) {
	if id := m.sender; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSender resets all changes to the "sender" edge.
func (m *MessageMutation) ResetSender() {
	m.sender = nil
	m.clearedsender = false
}

// Where appends a list predicates to the MessageMutation builder.
func (m *MessageMutation) Where(ps ...predicate.Message) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MessageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MessageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Message, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MessageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MessageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Message).
func (m *MessageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MessageMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, message.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, message.FieldUpdatedAt)
	}
	if m.conversation != nil {
		fields = append(fields, message.FieldConversationID)
	}
	if m.sender != nil {
		fields = append(fields, message.FieldSenderID)
	}
	if m._type != nil {
		fields = append(fields, message.FieldType)
	}
	if m.content != nil {
		fields = append(fields, message.FieldContent)
	}
	if m.is_read != nil {
		fields = append(fields, message.FieldIsRead)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MessageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case message.FieldCreatedAt:
		return m.CreatedAt()
	case message.FieldUpdatedAt:
		return m.UpdatedAt()
	case message.FieldConversationID:
		return m.ConversationID()
	case message.FieldSenderID:
		return m.SenderID()
	case message.FieldType:
		return m.GetType()
	case message.FieldContent:
		return m.Content()
	case message.FieldIsRead:
		return m.IsRead()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MessageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case message.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case message.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case message.FieldConversationID:
		return m.OldConversationID(ctx)
	case message.FieldSenderID:
		return m.OldSenderID(ctx)
	case message.FieldType:
		return m.OldType(ctx)
	case message.FieldContent:
		return m.OldContent(ctx)
	case message.FieldIsRead:
		return m.OldIsRead(ctx)
	}
	return nil, fmt.Errorf("unknown Message field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case message.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case message.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case message.FieldConversationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConversationID(v)
		return nil
	case message.FieldSenderID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSenderID(v)
		return nil
	case message.FieldType:
		v, ok := value.(message.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case message.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case message.FieldIsRead:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRead(v)
		return nil
	}
	return fmt.Errorf("unknown Message field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MessageMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MessageMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Message numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MessageMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MessageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MessageMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Message nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MessageMutation) ResetField(name string) error {
	switch name {
	case message.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case message.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case message.FieldConversationID:
		m.ResetConversationID()
		return nil
	case message.FieldSenderID:
		m.ResetSenderID()
		return nil
	case message.FieldType:
		m.ResetType()
		return nil
	case message.FieldContent:
		m.ResetContent()
		return nil
	case message.FieldIsRead:
		m.ResetIsRead()
		return nil
	}
	return fmt.Errorf("unknown Message field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MessageMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.conversation != nil {
		edges = append(edges, message.EdgeConversation)
	}
	if m.sender != nil {
		edges = append(edges, message.EdgeSender)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MessageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case message.EdgeConversation:
		if id := m.conversation; id != nil {
			return []ent.Value{*id}
		}
	case message.EdgeSender:
		if id := m.sender; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MessageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MessageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MessageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedconversation {
		edges = append(edges, message.EdgeConversation)
	}
	if m.clearedsender {
		edges = append(edges, message.EdgeSender)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MessageMutation) EdgeCleared(name string) bool {
	switch name {
	case message.EdgeConversation:
		return m.clearedconversation
	case message.EdgeSender:
		return m.clearedsender
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MessageMutation) ClearEdge(name string) error {
	switch name {
	case message.EdgeConversation:
		m.ClearConversation()
		return nil
	case message.EdgeSender:
		m.ClearSender()
		return nil
	}
	return fmt.Errorf("unknown Message unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MessageMutation) ResetEdge(name string) error {
	switch name {
	case message.EdgeConversation:
		m.ResetConversation()
		return nil
	case message.EdgeSender:
		m.ResetSender()
		return nil
	}
	return fmt.Errorf("unknown Message edge %s", name)
}

// OrderMutation represents an operation that mutates the Order nodes in the graph.
type OrderMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	created_at              *time.Time
	updated_at              *time.Time
	note                    *string
	priority                *int
	addpriority             *int
	internal_note           *string
	is_internal             *bool
	clearedFields           map[string]struct{}
	customer                *uuid.UUID
	clearedcustomer         bool
	creator                 *uuid.UUID
	clearedcreator          bool
	parent_order            *uuid.UUID
	clearedparent_order     bool
	order_status            *int
	clearedorder_status     bool
	order_type              *int
	clearedorder_type       bool
	management_staff        *uuid.UUID
	clearedmanagement_staff bool
	warehouse_staff         *uuid.UUID
	clearedwarehouse_staff  bool
	delivery_staff          *uuid.UUID
	cleareddelivery_staff   bool
	done                    bool
	oldValue                func(context.Context) (*Order, error)
	predicates              []predicate.Order
}

var _ ent.Mutation = (*OrderMutation)(nil)

// orderOption allows management of the mutation configuration using functional options.
type orderOption func(*OrderMutation)

// newOrderMutation creates new mutation for the Order entity.
func newOrderMutation(c config, op Op, opts ...orderOption) *OrderMutation {
	m := &OrderMutation{
		config:        c,
		op:            op,
		typ:           TypeOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderID sets the ID field of the mutation.
func withOrderID(id uuid.UUID) orderOption {
	return func(m *OrderMutation) {
		var (
			err   error
			once  sync.Once
			value *Order
		)
		m.oldValue = func(ctx context.Context) (*Order, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Order.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrder sets the old Order of the mutation.
func withOrder(node *Order) orderOption {
	return func(m *OrderMutation) {
		m.oldValue = func(context.Context) (*Order, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Order entities.
func (m *OrderMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Order.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCustomerID sets the "customer_id" field.
func (m *OrderMutation) SetCustomerID(u uuid.UUID) {
	m.customer = &u
}

// CustomerID returns the value of the "customer_id" field in the mutation.
func (m *OrderMutation) CustomerID() (r uuid.UUID, exists bool) {
	v := m.customer
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerID returns the old "customer_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCustomerID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerID: %w", err)
	}
	return oldValue.CustomerID, nil
}

// ResetCustomerID resets all changes to the "customer_id" field.
func (m *OrderMutation) ResetCustomerID() {
	m.customer = nil
}

// SetNote sets the "note" field.
func (m *OrderMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the value of the "note" field in the mutation.
func (m *OrderMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "note" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldNote(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ClearNote clears the value of the "note" field.
func (m *OrderMutation) ClearNote() {
	m.note = nil
	m.clearedFields[order.FieldNote] = struct{}{}
}

// NoteCleared returns if the "note" field was cleared in this mutation.
func (m *OrderMutation) NoteCleared() bool {
	_, ok := m.clearedFields[order.FieldNote]
	return ok
}

// ResetNote resets all changes to the "note" field.
func (m *OrderMutation) ResetNote() {
	m.note = nil
	delete(m.clearedFields, order.FieldNote)
}

// SetCreatedBy sets the "created_by" field.
func (m *OrderMutation) SetCreatedBy(u uuid.UUID) {
	m.creator = &u
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *OrderMutation) CreatedBy() (r uuid.UUID, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCreatedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *OrderMutation) ResetCreatedBy() {
	m.creator = nil
}

// SetParentOrderID sets the "parent_order_id" field.
func (m *OrderMutation) SetParentOrderID(u uuid.UUID) {
	m.parent_order = &u
}

// ParentOrderID returns the value of the "parent_order_id" field in the mutation.
func (m *OrderMutation) ParentOrderID() (r uuid.UUID, exists bool) {
	v := m.parent_order
	if v == nil {
		return
	}
	return *v, true
}

// OldParentOrderID returns the old "parent_order_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldParentOrderID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentOrderID: %w", err)
	}
	return oldValue.ParentOrderID, nil
}

// ClearParentOrderID clears the value of the "parent_order_id" field.
func (m *OrderMutation) ClearParentOrderID() {
	m.parent_order = nil
	m.clearedFields[order.FieldParentOrderID] = struct{}{}
}

// ParentOrderIDCleared returns if the "parent_order_id" field was cleared in this mutation.
func (m *OrderMutation) ParentOrderIDCleared() bool {
	_, ok := m.clearedFields[order.FieldParentOrderID]
	return ok
}

// ResetParentOrderID resets all changes to the "parent_order_id" field.
func (m *OrderMutation) ResetParentOrderID() {
	m.parent_order = nil
	delete(m.clearedFields, order.FieldParentOrderID)
}

// SetPriority sets the "priority" field.
func (m *OrderMutation) SetPriority(i int) {
	m.priority = &i
	m.addpriority = nil
}

// Priority returns the value of the "priority" field in the mutation.
func (m *OrderMutation) Priority() (r int, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldPriority(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// AddPriority adds i to the "priority" field.
func (m *OrderMutation) AddPriority(i int) {
	if m.addpriority != nil {
		*m.addpriority += i
	} else {
		m.addpriority = &i
	}
}

// AddedPriority returns the value that was added to the "priority" field in this mutation.
func (m *OrderMutation) AddedPriority() (r int, exists bool) {
	v := m.addpriority
	if v == nil {
		return
	}
	return *v, true
}

// ResetPriority resets all changes to the "priority" field.
func (m *OrderMutation) ResetPriority() {
	m.priority = nil
	m.addpriority = nil
}

// SetType sets the "type" field.
func (m *OrderMutation) SetType(i int) {
	m.order_type = &i
}

// GetType returns the value of the "type" field in the mutation.
func (m *OrderMutation) GetType() (r int, exists bool) {
	v := m.order_type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *OrderMutation) ResetType() {
	m.order_type = nil
}

// SetStatusCode sets the "status_code" field.
func (m *OrderMutation) SetStatusCode(i int) {
	m.order_status = &i
}

// StatusCode returns the value of the "status_code" field in the mutation.
func (m *OrderMutation) StatusCode() (r int, exists bool) {
	v := m.order_status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusCode returns the old "status_code" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldStatusCode(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatusCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatusCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusCode: %w", err)
	}
	return oldValue.StatusCode, nil
}

// ResetStatusCode resets all changes to the "status_code" field.
func (m *OrderMutation) ResetStatusCode() {
	m.order_status = nil
}

// SetManaagmentStaffID sets the "manaagment_staff_id" field.
func (m *OrderMutation) SetManaagmentStaffID(u uuid.UUID) {
	m.management_staff = &u
}

// ManaagmentStaffID returns the value of the "manaagment_staff_id" field in the mutation.
func (m *OrderMutation) ManaagmentStaffID() (r uuid.UUID, exists bool) {
	v := m.management_staff
	if v == nil {
		return
	}
	return *v, true
}

// OldManaagmentStaffID returns the old "manaagment_staff_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldManaagmentStaffID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManaagmentStaffID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManaagmentStaffID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManaagmentStaffID: %w", err)
	}
	return oldValue.ManaagmentStaffID, nil
}

// ResetManaagmentStaffID resets all changes to the "manaagment_staff_id" field.
func (m *OrderMutation) ResetManaagmentStaffID() {
	m.management_staff = nil
}

// SetWarehouseStaffID sets the "warehouse_staff_id" field.
func (m *OrderMutation) SetWarehouseStaffID(u uuid.UUID) {
	m.warehouse_staff = &u
}

// WarehouseStaffID returns the value of the "warehouse_staff_id" field in the mutation.
func (m *OrderMutation) WarehouseStaffID() (r uuid.UUID, exists bool) {
	v := m.warehouse_staff
	if v == nil {
		return
	}
	return *v, true
}

// OldWarehouseStaffID returns the old "warehouse_staff_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldWarehouseStaffID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWarehouseStaffID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWarehouseStaffID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWarehouseStaffID: %w", err)
	}
	return oldValue.WarehouseStaffID, nil
}

// ClearWarehouseStaffID clears the value of the "warehouse_staff_id" field.
func (m *OrderMutation) ClearWarehouseStaffID() {
	m.warehouse_staff = nil
	m.clearedFields[order.FieldWarehouseStaffID] = struct{}{}
}

// WarehouseStaffIDCleared returns if the "warehouse_staff_id" field was cleared in this mutation.
func (m *OrderMutation) WarehouseStaffIDCleared() bool {
	_, ok := m.clearedFields[order.FieldWarehouseStaffID]
	return ok
}

// ResetWarehouseStaffID resets all changes to the "warehouse_staff_id" field.
func (m *OrderMutation) ResetWarehouseStaffID() {
	m.warehouse_staff = nil
	delete(m.clearedFields, order.FieldWarehouseStaffID)
}

// SetDeliveryStaffID sets the "delivery_staff_id" field.
func (m *OrderMutation) SetDeliveryStaffID(u uuid.UUID) {
	m.delivery_staff = &u
}

// DeliveryStaffID returns the value of the "delivery_staff_id" field in the mutation.
func (m *OrderMutation) DeliveryStaffID() (r uuid.UUID, exists bool) {
	v := m.delivery_staff
	if v == nil {
		return
	}
	return *v, true
}

// OldDeliveryStaffID returns the old "delivery_staff_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldDeliveryStaffID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeliveryStaffID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeliveryStaffID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeliveryStaffID: %w", err)
	}
	return oldValue.DeliveryStaffID, nil
}

// ClearDeliveryStaffID clears the value of the "delivery_staff_id" field.
func (m *OrderMutation) ClearDeliveryStaffID() {
	m.delivery_staff = nil
	m.clearedFields[order.FieldDeliveryStaffID] = struct{}{}
}

// DeliveryStaffIDCleared returns if the "delivery_staff_id" field was cleared in this mutation.
func (m *OrderMutation) DeliveryStaffIDCleared() bool {
	_, ok := m.clearedFields[order.FieldDeliveryStaffID]
	return ok
}

// ResetDeliveryStaffID resets all changes to the "delivery_staff_id" field.
func (m *OrderMutation) ResetDeliveryStaffID() {
	m.delivery_staff = nil
	delete(m.clearedFields, order.FieldDeliveryStaffID)
}

// SetInternalNote sets the "internal_note" field.
func (m *OrderMutation) SetInternalNote(s string) {
	m.internal_note = &s
}

// InternalNote returns the value of the "internal_note" field in the mutation.
func (m *OrderMutation) InternalNote() (r string, exists bool) {
	v := m.internal_note
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalNote returns the old "internal_note" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldInternalNote(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalNote: %w", err)
	}
	return oldValue.InternalNote, nil
}

// ClearInternalNote clears the value of the "internal_note" field.
func (m *OrderMutation) ClearInternalNote() {
	m.internal_note = nil
	m.clearedFields[order.FieldInternalNote] = struct{}{}
}

// InternalNoteCleared returns if the "internal_note" field was cleared in this mutation.
func (m *OrderMutation) InternalNoteCleared() bool {
	_, ok := m.clearedFields[order.FieldInternalNote]
	return ok
}

// ResetInternalNote resets all changes to the "internal_note" field.
func (m *OrderMutation) ResetInternalNote() {
	m.internal_note = nil
	delete(m.clearedFields, order.FieldInternalNote)
}

// SetIsInternal sets the "is_internal" field.
func (m *OrderMutation) SetIsInternal(b bool) {
	m.is_internal = &b
}

// IsInternal returns the value of the "is_internal" field in the mutation.
func (m *OrderMutation) IsInternal() (r bool, exists bool) {
	v := m.is_internal
	if v == nil {
		return
	}
	return *v, true
}

// OldIsInternal returns the old "is_internal" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldIsInternal(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsInternal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsInternal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsInternal: %w", err)
	}
	return oldValue.IsInternal, nil
}

// ResetIsInternal resets all changes to the "is_internal" field.
func (m *OrderMutation) ResetIsInternal() {
	m.is_internal = nil
}

// ClearCustomer clears the "customer" edge to the User entity.
func (m *OrderMutation) ClearCustomer() {
	m.clearedcustomer = true
	m.clearedFields[order.FieldCustomerID] = struct{}{}
}

// CustomerCleared reports if the "customer" edge to the User entity was cleared.
func (m *OrderMutation) CustomerCleared() bool {
	return m.clearedcustomer
}

// CustomerIDs returns the "customer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CustomerID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) CustomerIDs() (ids []uuid.UUID) {
	if id := m.customer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomer resets all changes to the "customer" edge.
func (m *OrderMutation) ResetCustomer() {
	m.customer = nil
	m.clearedcustomer = false
}

// SetCreatorID sets the "creator" edge to the User entity by id.
func (m *OrderMutation) SetCreatorID(id uuid.UUID) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the User entity.
func (m *OrderMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[order.FieldCreatedBy] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the User entity was cleared.
func (m *OrderMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *OrderMutation) CreatorID() (id uuid.UUID, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) CreatorIDs() (ids []uuid.UUID) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *OrderMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// ClearParentOrder clears the "parent_order" edge to the Order entity.
func (m *OrderMutation) ClearParentOrder() {
	m.clearedparent_order = true
	m.clearedFields[order.FieldParentOrderID] = struct{}{}
}

// ParentOrderCleared reports if the "parent_order" edge to the Order entity was cleared.
func (m *OrderMutation) ParentOrderCleared() bool {
	return m.ParentOrderIDCleared() || m.clearedparent_order
}

// ParentOrderIDs returns the "parent_order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentOrderID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) ParentOrderIDs() (ids []uuid.UUID) {
	if id := m.parent_order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParentOrder resets all changes to the "parent_order" edge.
func (m *OrderMutation) ResetParentOrder() {
	m.parent_order = nil
	m.clearedparent_order = false
}

// SetOrderStatusID sets the "order_status" edge to the OrderStatusCode entity by id.
func (m *OrderMutation) SetOrderStatusID(id int) {
	m.order_status = &id
}

// ClearOrderStatus clears the "order_status" edge to the OrderStatusCode entity.
func (m *OrderMutation) ClearOrderStatus() {
	m.clearedorder_status = true
	m.clearedFields[order.FieldStatusCode] = struct{}{}
}

// OrderStatusCleared reports if the "order_status" edge to the OrderStatusCode entity was cleared.
func (m *OrderMutation) OrderStatusCleared() bool {
	return m.clearedorder_status
}

// OrderStatusID returns the "order_status" edge ID in the mutation.
func (m *OrderMutation) OrderStatusID() (id int, exists bool) {
	if m.order_status != nil {
		return *m.order_status, true
	}
	return
}

// OrderStatusIDs returns the "order_status" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderStatusID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) OrderStatusIDs() (ids []int) {
	if id := m.order_status; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrderStatus resets all changes to the "order_status" edge.
func (m *OrderMutation) ResetOrderStatus() {
	m.order_status = nil
	m.clearedorder_status = false
}

// SetOrderTypeID sets the "order_type" edge to the OrderType entity by id.
func (m *OrderMutation) SetOrderTypeID(id int) {
	m.order_type = &id
}

// ClearOrderType clears the "order_type" edge to the OrderType entity.
func (m *OrderMutation) ClearOrderType() {
	m.clearedorder_type = true
	m.clearedFields[order.FieldType] = struct{}{}
}

// OrderTypeCleared reports if the "order_type" edge to the OrderType entity was cleared.
func (m *OrderMutation) OrderTypeCleared() bool {
	return m.clearedorder_type
}

// OrderTypeID returns the "order_type" edge ID in the mutation.
func (m *OrderMutation) OrderTypeID() (id int, exists bool) {
	if m.order_type != nil {
		return *m.order_type, true
	}
	return
}

// OrderTypeIDs returns the "order_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderTypeID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) OrderTypeIDs() (ids []int) {
	if id := m.order_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrderType resets all changes to the "order_type" edge.
func (m *OrderMutation) ResetOrderType() {
	m.order_type = nil
	m.clearedorder_type = false
}

// SetManagementStaffID sets the "management_staff" edge to the User entity by id.
func (m *OrderMutation) SetManagementStaffID(id uuid.UUID) {
	m.management_staff = &id
}

// ClearManagementStaff clears the "management_staff" edge to the User entity.
func (m *OrderMutation) ClearManagementStaff() {
	m.clearedmanagement_staff = true
	m.clearedFields[order.FieldManaagmentStaffID] = struct{}{}
}

// ManagementStaffCleared reports if the "management_staff" edge to the User entity was cleared.
func (m *OrderMutation) ManagementStaffCleared() bool {
	return m.clearedmanagement_staff
}

// ManagementStaffID returns the "management_staff" edge ID in the mutation.
func (m *OrderMutation) ManagementStaffID() (id uuid.UUID, exists bool) {
	if m.management_staff != nil {
		return *m.management_staff, true
	}
	return
}

// ManagementStaffIDs returns the "management_staff" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ManagementStaffID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) ManagementStaffIDs() (ids []uuid.UUID) {
	if id := m.management_staff; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetManagementStaff resets all changes to the "management_staff" edge.
func (m *OrderMutation) ResetManagementStaff() {
	m.management_staff = nil
	m.clearedmanagement_staff = false
}

// ClearWarehouseStaff clears the "warehouse_staff" edge to the User entity.
func (m *OrderMutation) ClearWarehouseStaff() {
	m.clearedwarehouse_staff = true
	m.clearedFields[order.FieldWarehouseStaffID] = struct{}{}
}

// WarehouseStaffCleared reports if the "warehouse_staff" edge to the User entity was cleared.
func (m *OrderMutation) WarehouseStaffCleared() bool {
	return m.WarehouseStaffIDCleared() || m.clearedwarehouse_staff
}

// WarehouseStaffIDs returns the "warehouse_staff" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WarehouseStaffID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) WarehouseStaffIDs() (ids []uuid.UUID) {
	if id := m.warehouse_staff; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWarehouseStaff resets all changes to the "warehouse_staff" edge.
func (m *OrderMutation) ResetWarehouseStaff() {
	m.warehouse_staff = nil
	m.clearedwarehouse_staff = false
}

// ClearDeliveryStaff clears the "delivery_staff" edge to the User entity.
func (m *OrderMutation) ClearDeliveryStaff() {
	m.cleareddelivery_staff = true
	m.clearedFields[order.FieldDeliveryStaffID] = struct{}{}
}

// DeliveryStaffCleared reports if the "delivery_staff" edge to the User entity was cleared.
func (m *OrderMutation) DeliveryStaffCleared() bool {
	return m.DeliveryStaffIDCleared() || m.cleareddelivery_staff
}

// DeliveryStaffIDs returns the "delivery_staff" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeliveryStaffID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) DeliveryStaffIDs() (ids []uuid.UUID) {
	if id := m.delivery_staff; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeliveryStaff resets all changes to the "delivery_staff" edge.
func (m *OrderMutation) ResetDeliveryStaff() {
	m.delivery_staff = nil
	m.cleareddelivery_staff = false
}

// Where appends a list predicates to the OrderMutation builder.
func (m *OrderMutation) Where(ps ...predicate.Order) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Order, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Order).
func (m *OrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, order.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, order.FieldUpdatedAt)
	}
	if m.customer != nil {
		fields = append(fields, order.FieldCustomerID)
	}
	if m.note != nil {
		fields = append(fields, order.FieldNote)
	}
	if m.creator != nil {
		fields = append(fields, order.FieldCreatedBy)
	}
	if m.parent_order != nil {
		fields = append(fields, order.FieldParentOrderID)
	}
	if m.priority != nil {
		fields = append(fields, order.FieldPriority)
	}
	if m.order_type != nil {
		fields = append(fields, order.FieldType)
	}
	if m.order_status != nil {
		fields = append(fields, order.FieldStatusCode)
	}
	if m.management_staff != nil {
		fields = append(fields, order.FieldManaagmentStaffID)
	}
	if m.warehouse_staff != nil {
		fields = append(fields, order.FieldWarehouseStaffID)
	}
	if m.delivery_staff != nil {
		fields = append(fields, order.FieldDeliveryStaffID)
	}
	if m.internal_note != nil {
		fields = append(fields, order.FieldInternalNote)
	}
	if m.is_internal != nil {
		fields = append(fields, order.FieldIsInternal)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case order.FieldCreatedAt:
		return m.CreatedAt()
	case order.FieldUpdatedAt:
		return m.UpdatedAt()
	case order.FieldCustomerID:
		return m.CustomerID()
	case order.FieldNote:
		return m.Note()
	case order.FieldCreatedBy:
		return m.CreatedBy()
	case order.FieldParentOrderID:
		return m.ParentOrderID()
	case order.FieldPriority:
		return m.Priority()
	case order.FieldType:
		return m.GetType()
	case order.FieldStatusCode:
		return m.StatusCode()
	case order.FieldManaagmentStaffID:
		return m.ManaagmentStaffID()
	case order.FieldWarehouseStaffID:
		return m.WarehouseStaffID()
	case order.FieldDeliveryStaffID:
		return m.DeliveryStaffID()
	case order.FieldInternalNote:
		return m.InternalNote()
	case order.FieldIsInternal:
		return m.IsInternal()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case order.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case order.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case order.FieldCustomerID:
		return m.OldCustomerID(ctx)
	case order.FieldNote:
		return m.OldNote(ctx)
	case order.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case order.FieldParentOrderID:
		return m.OldParentOrderID(ctx)
	case order.FieldPriority:
		return m.OldPriority(ctx)
	case order.FieldType:
		return m.OldType(ctx)
	case order.FieldStatusCode:
		return m.OldStatusCode(ctx)
	case order.FieldManaagmentStaffID:
		return m.OldManaagmentStaffID(ctx)
	case order.FieldWarehouseStaffID:
		return m.OldWarehouseStaffID(ctx)
	case order.FieldDeliveryStaffID:
		return m.OldDeliveryStaffID(ctx)
	case order.FieldInternalNote:
		return m.OldInternalNote(ctx)
	case order.FieldIsInternal:
		return m.OldIsInternal(ctx)
	}
	return nil, fmt.Errorf("unknown Order field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case order.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case order.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case order.FieldCustomerID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerID(v)
		return nil
	case order.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	case order.FieldCreatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case order.FieldParentOrderID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentOrderID(v)
		return nil
	case order.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case order.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case order.FieldStatusCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusCode(v)
		return nil
	case order.FieldManaagmentStaffID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManaagmentStaffID(v)
		return nil
	case order.FieldWarehouseStaffID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWarehouseStaffID(v)
		return nil
	case order.FieldDeliveryStaffID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeliveryStaffID(v)
		return nil
	case order.FieldInternalNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalNote(v)
		return nil
	case order.FieldIsInternal:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsInternal(v)
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderMutation) AddedFields() []string {
	var fields []string
	if m.addpriority != nil {
		fields = append(fields, order.FieldPriority)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case order.FieldPriority:
		return m.AddedPriority()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case order.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriority(v)
		return nil
	}
	return fmt.Errorf("unknown Order numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(order.FieldNote) {
		fields = append(fields, order.FieldNote)
	}
	if m.FieldCleared(order.FieldParentOrderID) {
		fields = append(fields, order.FieldParentOrderID)
	}
	if m.FieldCleared(order.FieldWarehouseStaffID) {
		fields = append(fields, order.FieldWarehouseStaffID)
	}
	if m.FieldCleared(order.FieldDeliveryStaffID) {
		fields = append(fields, order.FieldDeliveryStaffID)
	}
	if m.FieldCleared(order.FieldInternalNote) {
		fields = append(fields, order.FieldInternalNote)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderMutation) ClearField(name string) error {
	switch name {
	case order.FieldNote:
		m.ClearNote()
		return nil
	case order.FieldParentOrderID:
		m.ClearParentOrderID()
		return nil
	case order.FieldWarehouseStaffID:
		m.ClearWarehouseStaffID()
		return nil
	case order.FieldDeliveryStaffID:
		m.ClearDeliveryStaffID()
		return nil
	case order.FieldInternalNote:
		m.ClearInternalNote()
		return nil
	}
	return fmt.Errorf("unknown Order nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderMutation) ResetField(name string) error {
	switch name {
	case order.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case order.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case order.FieldCustomerID:
		m.ResetCustomerID()
		return nil
	case order.FieldNote:
		m.ResetNote()
		return nil
	case order.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case order.FieldParentOrderID:
		m.ResetParentOrderID()
		return nil
	case order.FieldPriority:
		m.ResetPriority()
		return nil
	case order.FieldType:
		m.ResetType()
		return nil
	case order.FieldStatusCode:
		m.ResetStatusCode()
		return nil
	case order.FieldManaagmentStaffID:
		m.ResetManaagmentStaffID()
		return nil
	case order.FieldWarehouseStaffID:
		m.ResetWarehouseStaffID()
		return nil
	case order.FieldDeliveryStaffID:
		m.ResetDeliveryStaffID()
		return nil
	case order.FieldInternalNote:
		m.ResetInternalNote()
		return nil
	case order.FieldIsInternal:
		m.ResetIsInternal()
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.customer != nil {
		edges = append(edges, order.EdgeCustomer)
	}
	if m.creator != nil {
		edges = append(edges, order.EdgeCreator)
	}
	if m.parent_order != nil {
		edges = append(edges, order.EdgeParentOrder)
	}
	if m.order_status != nil {
		edges = append(edges, order.EdgeOrderStatus)
	}
	if m.order_type != nil {
		edges = append(edges, order.EdgeOrderType)
	}
	if m.management_staff != nil {
		edges = append(edges, order.EdgeManagementStaff)
	}
	if m.warehouse_staff != nil {
		edges = append(edges, order.EdgeWarehouseStaff)
	}
	if m.delivery_staff != nil {
		edges = append(edges, order.EdgeDeliveryStaff)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case order.EdgeCustomer:
		if id := m.customer; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeParentOrder:
		if id := m.parent_order; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeOrderStatus:
		if id := m.order_status; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeOrderType:
		if id := m.order_type; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeManagementStaff:
		if id := m.management_staff; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeWarehouseStaff:
		if id := m.warehouse_staff; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeDeliveryStaff:
		if id := m.delivery_staff; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedcustomer {
		edges = append(edges, order.EdgeCustomer)
	}
	if m.clearedcreator {
		edges = append(edges, order.EdgeCreator)
	}
	if m.clearedparent_order {
		edges = append(edges, order.EdgeParentOrder)
	}
	if m.clearedorder_status {
		edges = append(edges, order.EdgeOrderStatus)
	}
	if m.clearedorder_type {
		edges = append(edges, order.EdgeOrderType)
	}
	if m.clearedmanagement_staff {
		edges = append(edges, order.EdgeManagementStaff)
	}
	if m.clearedwarehouse_staff {
		edges = append(edges, order.EdgeWarehouseStaff)
	}
	if m.cleareddelivery_staff {
		edges = append(edges, order.EdgeDeliveryStaff)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderMutation) EdgeCleared(name string) bool {
	switch name {
	case order.EdgeCustomer:
		return m.clearedcustomer
	case order.EdgeCreator:
		return m.clearedcreator
	case order.EdgeParentOrder:
		return m.clearedparent_order
	case order.EdgeOrderStatus:
		return m.clearedorder_status
	case order.EdgeOrderType:
		return m.clearedorder_type
	case order.EdgeManagementStaff:
		return m.clearedmanagement_staff
	case order.EdgeWarehouseStaff:
		return m.clearedwarehouse_staff
	case order.EdgeDeliveryStaff:
		return m.cleareddelivery_staff
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderMutation) ClearEdge(name string) error {
	switch name {
	case order.EdgeCustomer:
		m.ClearCustomer()
		return nil
	case order.EdgeCreator:
		m.ClearCreator()
		return nil
	case order.EdgeParentOrder:
		m.ClearParentOrder()
		return nil
	case order.EdgeOrderStatus:
		m.ClearOrderStatus()
		return nil
	case order.EdgeOrderType:
		m.ClearOrderType()
		return nil
	case order.EdgeManagementStaff:
		m.ClearManagementStaff()
		return nil
	case order.EdgeWarehouseStaff:
		m.ClearWarehouseStaff()
		return nil
	case order.EdgeDeliveryStaff:
		m.ClearDeliveryStaff()
		return nil
	}
	return fmt.Errorf("unknown Order unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderMutation) ResetEdge(name string) error {
	switch name {
	case order.EdgeCustomer:
		m.ResetCustomer()
		return nil
	case order.EdgeCreator:
		m.ResetCreator()
		return nil
	case order.EdgeParentOrder:
		m.ResetParentOrder()
		return nil
	case order.EdgeOrderStatus:
		m.ResetOrderStatus()
		return nil
	case order.EdgeOrderType:
		m.ResetOrderType()
		return nil
	case order.EdgeManagementStaff:
		m.ResetManagementStaff()
		return nil
	case order.EdgeWarehouseStaff:
		m.ResetWarehouseStaff()
		return nil
	case order.EdgeDeliveryStaff:
		m.ResetDeliveryStaff()
		return nil
	}
	return fmt.Errorf("unknown Order edge %s", name)
}

// OrderLineItemMutation represents an operation that mutates the OrderLineItem nodes in the graph.
type OrderLineItemMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	created_at     *time.Time
	updated_at     *time.Time
	qty            *decimal.Decimal
	addqty         *decimal.Decimal
	clearedFields  map[string]struct{}
	_order         *uuid.UUID
	cleared_order  bool
	product        *uuid.UUID
	clearedproduct bool
	done           bool
	oldValue       func(context.Context) (*OrderLineItem, error)
	predicates     []predicate.OrderLineItem
}

var _ ent.Mutation = (*OrderLineItemMutation)(nil)

// orderlineitemOption allows management of the mutation configuration using functional options.
type orderlineitemOption func(*OrderLineItemMutation)

// newOrderLineItemMutation creates new mutation for the OrderLineItem entity.
func newOrderLineItemMutation(c config, op Op, opts ...orderlineitemOption) *OrderLineItemMutation {
	m := &OrderLineItemMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderLineItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderLineItemID sets the ID field of the mutation.
func withOrderLineItemID(id uuid.UUID) orderlineitemOption {
	return func(m *OrderLineItemMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderLineItem
		)
		m.oldValue = func(ctx context.Context) (*OrderLineItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderLineItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderLineItem sets the old OrderLineItem of the mutation.
func withOrderLineItem(node *OrderLineItem) orderlineitemOption {
	return func(m *OrderLineItemMutation) {
		m.oldValue = func(context.Context) (*OrderLineItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderLineItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderLineItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrderLineItem entities.
func (m *OrderLineItemMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderLineItemMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderLineItemMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderLineItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderLineItemMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderLineItemMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrderLineItem entity.
// If the OrderLineItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderLineItemMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderLineItemMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderLineItemMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderLineItemMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrderLineItem entity.
// If the OrderLineItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderLineItemMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderLineItemMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetOrderID sets the "order_id" field.
func (m *OrderLineItemMutation) SetOrderID(u uuid.UUID) {
	m._order = &u
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *OrderLineItemMutation) OrderID() (r uuid.UUID, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the OrderLineItem entity.
// If the OrderLineItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderLineItemMutation) OldOrderID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *OrderLineItemMutation) ResetOrderID() {
	m._order = nil
}

// SetProductID sets the "product_id" field.
func (m *OrderLineItemMutation) SetProductID(u uuid.UUID) {
	m.product = &u
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *OrderLineItemMutation) ProductID() (r uuid.UUID, exists bool) {
	v := m.product
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the OrderLineItem entity.
// If the OrderLineItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderLineItemMutation) OldProductID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// ResetProductID resets all changes to the "product_id" field.
func (m *OrderLineItemMutation) ResetProductID() {
	m.product = nil
}

// SetQty sets the "qty" field.
func (m *OrderLineItemMutation) SetQty(d decimal.Decimal) {
	m.qty = &d
	m.addqty = nil
}

// Qty returns the value of the "qty" field in the mutation.
func (m *OrderLineItemMutation) Qty() (r decimal.Decimal, exists bool) {
	v := m.qty
	if v == nil {
		return
	}
	return *v, true
}

// OldQty returns the old "qty" field's value of the OrderLineItem entity.
// If the OrderLineItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderLineItemMutation) OldQty(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQty: %w", err)
	}
	return oldValue.Qty, nil
}

// AddQty adds d to the "qty" field.
func (m *OrderLineItemMutation) AddQty(d decimal.Decimal) {
	if m.addqty != nil {
		*m.addqty = m.addqty.Add(d)
	} else {
		m.addqty = &d
	}
}

// AddedQty returns the value that was added to the "qty" field in this mutation.
func (m *OrderLineItemMutation) AddedQty() (r decimal.Decimal, exists bool) {
	v := m.addqty
	if v == nil {
		return
	}
	return *v, true
}

// ResetQty resets all changes to the "qty" field.
func (m *OrderLineItemMutation) ResetQty() {
	m.qty = nil
	m.addqty = nil
}

// ClearOrder clears the "order" edge to the Order entity.
func (m *OrderLineItemMutation) ClearOrder() {
	m.cleared_order = true
	m.clearedFields[orderlineitem.FieldOrderID] = struct{}{}
}

// OrderCleared reports if the "order" edge to the Order entity was cleared.
func (m *OrderLineItemMutation) OrderCleared() bool {
	return m.cleared_order
}

// OrderIDs returns the "order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderID instead. It exists only for internal usage by the builders.
func (m *OrderLineItemMutation) OrderIDs() (ids []uuid.UUID) {
	if id := m._order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrder resets all changes to the "order" edge.
func (m *OrderLineItemMutation) ResetOrder() {
	m._order = nil
	m.cleared_order = false
}

// ClearProduct clears the "product" edge to the Product entity.
func (m *OrderLineItemMutation) ClearProduct() {
	m.clearedproduct = true
	m.clearedFields[orderlineitem.FieldProductID] = struct{}{}
}

// ProductCleared reports if the "product" edge to the Product entity was cleared.
func (m *OrderLineItemMutation) ProductCleared() bool {
	return m.clearedproduct
}

// ProductIDs returns the "product" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductID instead. It exists only for internal usage by the builders.
func (m *OrderLineItemMutation) ProductIDs() (ids []uuid.UUID) {
	if id := m.product; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProduct resets all changes to the "product" edge.
func (m *OrderLineItemMutation) ResetProduct() {
	m.product = nil
	m.clearedproduct = false
}

// Where appends a list predicates to the OrderLineItemMutation builder.
func (m *OrderLineItemMutation) Where(ps ...predicate.OrderLineItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderLineItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderLineItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrderLineItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderLineItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderLineItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrderLineItem).
func (m *OrderLineItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderLineItemMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, orderlineitem.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, orderlineitem.FieldUpdatedAt)
	}
	if m._order != nil {
		fields = append(fields, orderlineitem.FieldOrderID)
	}
	if m.product != nil {
		fields = append(fields, orderlineitem.FieldProductID)
	}
	if m.qty != nil {
		fields = append(fields, orderlineitem.FieldQty)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderLineItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderlineitem.FieldCreatedAt:
		return m.CreatedAt()
	case orderlineitem.FieldUpdatedAt:
		return m.UpdatedAt()
	case orderlineitem.FieldOrderID:
		return m.OrderID()
	case orderlineitem.FieldProductID:
		return m.ProductID()
	case orderlineitem.FieldQty:
		return m.Qty()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderLineItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderlineitem.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case orderlineitem.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case orderlineitem.FieldOrderID:
		return m.OldOrderID(ctx)
	case orderlineitem.FieldProductID:
		return m.OldProductID(ctx)
	case orderlineitem.FieldQty:
		return m.OldQty(ctx)
	}
	return nil, fmt.Errorf("unknown OrderLineItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderLineItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderlineitem.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case orderlineitem.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case orderlineitem.FieldOrderID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case orderlineitem.FieldProductID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case orderlineitem.FieldQty:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQty(v)
		return nil
	}
	return fmt.Errorf("unknown OrderLineItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderLineItemMutation) AddedFields() []string {
	var fields []string
	if m.addqty != nil {
		fields = append(fields, orderlineitem.FieldQty)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderLineItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderlineitem.FieldQty:
		return m.AddedQty()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderLineItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderlineitem.FieldQty:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQty(v)
		return nil
	}
	return fmt.Errorf("unknown OrderLineItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderLineItemMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderLineItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderLineItemMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OrderLineItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderLineItemMutation) ResetField(name string) error {
	switch name {
	case orderlineitem.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case orderlineitem.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case orderlineitem.FieldOrderID:
		m.ResetOrderID()
		return nil
	case orderlineitem.FieldProductID:
		m.ResetProductID()
		return nil
	case orderlineitem.FieldQty:
		m.ResetQty()
		return nil
	}
	return fmt.Errorf("unknown OrderLineItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderLineItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._order != nil {
		edges = append(edges, orderlineitem.EdgeOrder)
	}
	if m.product != nil {
		edges = append(edges, orderlineitem.EdgeProduct)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderLineItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orderlineitem.EdgeOrder:
		if id := m._order; id != nil {
			return []ent.Value{*id}
		}
	case orderlineitem.EdgeProduct:
		if id := m.product; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderLineItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderLineItemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderLineItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_order {
		edges = append(edges, orderlineitem.EdgeOrder)
	}
	if m.clearedproduct {
		edges = append(edges, orderlineitem.EdgeProduct)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderLineItemMutation) EdgeCleared(name string) bool {
	switch name {
	case orderlineitem.EdgeOrder:
		return m.cleared_order
	case orderlineitem.EdgeProduct:
		return m.clearedproduct
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderLineItemMutation) ClearEdge(name string) error {
	switch name {
	case orderlineitem.EdgeOrder:
		m.ClearOrder()
		return nil
	case orderlineitem.EdgeProduct:
		m.ClearProduct()
		return nil
	}
	return fmt.Errorf("unknown OrderLineItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderLineItemMutation) ResetEdge(name string) error {
	switch name {
	case orderlineitem.EdgeOrder:
		m.ResetOrder()
		return nil
	case orderlineitem.EdgeProduct:
		m.ResetProduct()
		return nil
	}
	return fmt.Errorf("unknown OrderLineItem edge %s", name)
}

// OrderStatusCodeMutation represents an operation that mutates the OrderStatusCode nodes in the graph.
type OrderStatusCodeMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	order_status  *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*OrderStatusCode, error)
	predicates    []predicate.OrderStatusCode
}

var _ ent.Mutation = (*OrderStatusCodeMutation)(nil)

// orderstatuscodeOption allows management of the mutation configuration using functional options.
type orderstatuscodeOption func(*OrderStatusCodeMutation)

// newOrderStatusCodeMutation creates new mutation for the OrderStatusCode entity.
func newOrderStatusCodeMutation(c config, op Op, opts ...orderstatuscodeOption) *OrderStatusCodeMutation {
	m := &OrderStatusCodeMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderStatusCode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderStatusCodeID sets the ID field of the mutation.
func withOrderStatusCodeID(id int) orderstatuscodeOption {
	return func(m *OrderStatusCodeMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderStatusCode
		)
		m.oldValue = func(ctx context.Context) (*OrderStatusCode, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderStatusCode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderStatusCode sets the old OrderStatusCode of the mutation.
func withOrderStatusCode(node *OrderStatusCode) orderstatuscodeOption {
	return func(m *OrderStatusCodeMutation) {
		m.oldValue = func(context.Context) (*OrderStatusCode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderStatusCodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderStatusCodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderStatusCodeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderStatusCodeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderStatusCode.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderStatusCodeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderStatusCodeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrderStatusCode entity.
// If the OrderStatusCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderStatusCodeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderStatusCodeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderStatusCodeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderStatusCodeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrderStatusCode entity.
// If the OrderStatusCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderStatusCodeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderStatusCodeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetOrderStatus sets the "order_status" field.
func (m *OrderStatusCodeMutation) SetOrderStatus(s string) {
	m.order_status = &s
}

// OrderStatus returns the value of the "order_status" field in the mutation.
func (m *OrderStatusCodeMutation) OrderStatus() (r string, exists bool) {
	v := m.order_status
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderStatus returns the old "order_status" field's value of the OrderStatusCode entity.
// If the OrderStatusCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderStatusCodeMutation) OldOrderStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderStatus: %w", err)
	}
	return oldValue.OrderStatus, nil
}

// ResetOrderStatus resets all changes to the "order_status" field.
func (m *OrderStatusCodeMutation) ResetOrderStatus() {
	m.order_status = nil
}

// Where appends a list predicates to the OrderStatusCodeMutation builder.
func (m *OrderStatusCodeMutation) Where(ps ...predicate.OrderStatusCode) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderStatusCodeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderStatusCodeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrderStatusCode, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderStatusCodeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderStatusCodeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrderStatusCode).
func (m *OrderStatusCodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderStatusCodeMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, orderstatuscode.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, orderstatuscode.FieldUpdatedAt)
	}
	if m.order_status != nil {
		fields = append(fields, orderstatuscode.FieldOrderStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderStatusCodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderstatuscode.FieldCreatedAt:
		return m.CreatedAt()
	case orderstatuscode.FieldUpdatedAt:
		return m.UpdatedAt()
	case orderstatuscode.FieldOrderStatus:
		return m.OrderStatus()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderStatusCodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderstatuscode.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case orderstatuscode.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case orderstatuscode.FieldOrderStatus:
		return m.OldOrderStatus(ctx)
	}
	return nil, fmt.Errorf("unknown OrderStatusCode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderStatusCodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderstatuscode.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case orderstatuscode.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case orderstatuscode.FieldOrderStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderStatus(v)
		return nil
	}
	return fmt.Errorf("unknown OrderStatusCode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderStatusCodeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderStatusCodeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderStatusCodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OrderStatusCode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderStatusCodeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderStatusCodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderStatusCodeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OrderStatusCode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderStatusCodeMutation) ResetField(name string) error {
	switch name {
	case orderstatuscode.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case orderstatuscode.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case orderstatuscode.FieldOrderStatus:
		m.ResetOrderStatus()
		return nil
	}
	return fmt.Errorf("unknown OrderStatusCode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderStatusCodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderStatusCodeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderStatusCodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderStatusCodeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderStatusCodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderStatusCodeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderStatusCodeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown OrderStatusCode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderStatusCodeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown OrderStatusCode edge %s", name)
}

// OrderTypeMutation represents an operation that mutates the OrderType nodes in the graph.
type OrderTypeMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	order_type    *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*OrderType, error)
	predicates    []predicate.OrderType
}

var _ ent.Mutation = (*OrderTypeMutation)(nil)

// ordertypeOption allows management of the mutation configuration using functional options.
type ordertypeOption func(*OrderTypeMutation)

// newOrderTypeMutation creates new mutation for the OrderType entity.
func newOrderTypeMutation(c config, op Op, opts ...ordertypeOption) *OrderTypeMutation {
	m := &OrderTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderTypeID sets the ID field of the mutation.
func withOrderTypeID(id int) ordertypeOption {
	return func(m *OrderTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderType
		)
		m.oldValue = func(ctx context.Context) (*OrderType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderType sets the old OrderType of the mutation.
func withOrderType(node *OrderType) ordertypeOption {
	return func(m *OrderTypeMutation) {
		m.oldValue = func(context.Context) (*OrderType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderTypeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderTypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderTypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrderType entity.
// If the OrderType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderTypeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderTypeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderTypeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderTypeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrderType entity.
// If the OrderType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderTypeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderTypeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetOrderType sets the "order_type" field.
func (m *OrderTypeMutation) SetOrderType(s string) {
	m.order_type = &s
}

// OrderType returns the value of the "order_type" field in the mutation.
func (m *OrderTypeMutation) OrderType() (r string, exists bool) {
	v := m.order_type
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderType returns the old "order_type" field's value of the OrderType entity.
// If the OrderType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderTypeMutation) OldOrderType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderType: %w", err)
	}
	return oldValue.OrderType, nil
}

// ResetOrderType resets all changes to the "order_type" field.
func (m *OrderTypeMutation) ResetOrderType() {
	m.order_type = nil
}

// Where appends a list predicates to the OrderTypeMutation builder.
func (m *OrderTypeMutation) Where(ps ...predicate.OrderType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrderType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrderType).
func (m *OrderTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderTypeMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, ordertype.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, ordertype.FieldUpdatedAt)
	}
	if m.order_type != nil {
		fields = append(fields, ordertype.FieldOrderType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ordertype.FieldCreatedAt:
		return m.CreatedAt()
	case ordertype.FieldUpdatedAt:
		return m.UpdatedAt()
	case ordertype.FieldOrderType:
		return m.OrderType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ordertype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case ordertype.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case ordertype.FieldOrderType:
		return m.OldOrderType(ctx)
	}
	return nil, fmt.Errorf("unknown OrderType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ordertype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case ordertype.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case ordertype.FieldOrderType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderType(v)
		return nil
	}
	return fmt.Errorf("unknown OrderType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OrderType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OrderType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderTypeMutation) ResetField(name string) error {
	switch name {
	case ordertype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case ordertype.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case ordertype.FieldOrderType:
		m.ResetOrderType()
		return nil
	}
	return fmt.Errorf("unknown OrderType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderTypeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderTypeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderTypeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderTypeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown OrderType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderTypeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown OrderType edge %s", name)
}

// ProductMutation represents an operation that mutates the Product nodes in the graph.
type ProductMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	created_at          *time.Time
	updated_at          *time.Time
	name                *string
	description         *string
	year                *int
	addyear             *int
	price               *decimal.Decimal
	addprice            *decimal.Decimal
	qty                 *decimal.Decimal
	addqty              *decimal.Decimal
	image_urls          *[]url.URL
	appendimage_urls    []url.URL
	unit_of_measurement *string
	_type               *string
	provider            *string
	clearedFields       map[string]struct{}
	tags                map[uuid.UUID]struct{}
	removedtags         map[uuid.UUID]struct{}
	clearedtags         bool
	done                bool
	oldValue            func(context.Context) (*Product, error)
	predicates          []predicate.Product
}

var _ ent.Mutation = (*ProductMutation)(nil)

// productOption allows management of the mutation configuration using functional options.
type productOption func(*ProductMutation)

// newProductMutation creates new mutation for the Product entity.
func newProductMutation(c config, op Op, opts ...productOption) *ProductMutation {
	m := &ProductMutation{
		config:        c,
		op:            op,
		typ:           TypeProduct,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductID sets the ID field of the mutation.
func withProductID(id uuid.UUID) productOption {
	return func(m *ProductMutation) {
		var (
			err   error
			once  sync.Once
			value *Product
		)
		m.oldValue = func(ctx context.Context) (*Product, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Product.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProduct sets the old Product of the mutation.
func withProduct(node *Product) productOption {
	return func(m *ProductMutation) {
		m.oldValue = func(context.Context) (*Product, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Product entities.
func (m *ProductMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Product.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProductMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProductMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProductMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProductMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProductMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProductMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *ProductMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProductMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProductMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ProductMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProductMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProductMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[product.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProductMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[product.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProductMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, product.FieldDescription)
}

// SetYear sets the "year" field.
func (m *ProductMutation) SetYear(i int) {
	m.year = &i
	m.addyear = nil
}

// Year returns the value of the "year" field in the mutation.
func (m *ProductMutation) Year() (r int, exists bool) {
	v := m.year
	if v == nil {
		return
	}
	return *v, true
}

// OldYear returns the old "year" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldYear(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYear is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYear: %w", err)
	}
	return oldValue.Year, nil
}

// AddYear adds i to the "year" field.
func (m *ProductMutation) AddYear(i int) {
	if m.addyear != nil {
		*m.addyear += i
	} else {
		m.addyear = &i
	}
}

// AddedYear returns the value that was added to the "year" field in this mutation.
func (m *ProductMutation) AddedYear() (r int, exists bool) {
	v := m.addyear
	if v == nil {
		return
	}
	return *v, true
}

// ResetYear resets all changes to the "year" field.
func (m *ProductMutation) ResetYear() {
	m.year = nil
	m.addyear = nil
}

// SetPrice sets the "price" field.
func (m *ProductMutation) SetPrice(d decimal.Decimal) {
	m.price = &d
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *ProductMutation) Price() (r decimal.Decimal, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldPrice(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds d to the "price" field.
func (m *ProductMutation) AddPrice(d decimal.Decimal) {
	if m.addprice != nil {
		*m.addprice = m.addprice.Add(d)
	} else {
		m.addprice = &d
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *ProductMutation) AddedPrice() (r decimal.Decimal, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *ProductMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetQty sets the "qty" field.
func (m *ProductMutation) SetQty(d decimal.Decimal) {
	m.qty = &d
	m.addqty = nil
}

// Qty returns the value of the "qty" field in the mutation.
func (m *ProductMutation) Qty() (r decimal.Decimal, exists bool) {
	v := m.qty
	if v == nil {
		return
	}
	return *v, true
}

// OldQty returns the old "qty" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldQty(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQty: %w", err)
	}
	return oldValue.Qty, nil
}

// AddQty adds d to the "qty" field.
func (m *ProductMutation) AddQty(d decimal.Decimal) {
	if m.addqty != nil {
		*m.addqty = m.addqty.Add(d)
	} else {
		m.addqty = &d
	}
}

// AddedQty returns the value that was added to the "qty" field in this mutation.
func (m *ProductMutation) AddedQty() (r decimal.Decimal, exists bool) {
	v := m.addqty
	if v == nil {
		return
	}
	return *v, true
}

// ResetQty resets all changes to the "qty" field.
func (m *ProductMutation) ResetQty() {
	m.qty = nil
	m.addqty = nil
}

// SetImageUrls sets the "image_urls" field.
func (m *ProductMutation) SetImageUrls(u []url.URL) {
	m.image_urls = &u
	m.appendimage_urls = nil
}

// ImageUrls returns the value of the "image_urls" field in the mutation.
func (m *ProductMutation) ImageUrls() (r []url.URL, exists bool) {
	v := m.image_urls
	if v == nil {
		return
	}
	return *v, true
}

// OldImageUrls returns the old "image_urls" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldImageUrls(ctx context.Context) (v []url.URL, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImageUrls is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImageUrls requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImageUrls: %w", err)
	}
	return oldValue.ImageUrls, nil
}

// AppendImageUrls adds u to the "image_urls" field.
func (m *ProductMutation) AppendImageUrls(u []url.URL) {
	m.appendimage_urls = append(m.appendimage_urls, u...)
}

// AppendedImageUrls returns the list of values that were appended to the "image_urls" field in this mutation.
func (m *ProductMutation) AppendedImageUrls() ([]url.URL, bool) {
	if len(m.appendimage_urls) == 0 {
		return nil, false
	}
	return m.appendimage_urls, true
}

// ClearImageUrls clears the value of the "image_urls" field.
func (m *ProductMutation) ClearImageUrls() {
	m.image_urls = nil
	m.appendimage_urls = nil
	m.clearedFields[product.FieldImageUrls] = struct{}{}
}

// ImageUrlsCleared returns if the "image_urls" field was cleared in this mutation.
func (m *ProductMutation) ImageUrlsCleared() bool {
	_, ok := m.clearedFields[product.FieldImageUrls]
	return ok
}

// ResetImageUrls resets all changes to the "image_urls" field.
func (m *ProductMutation) ResetImageUrls() {
	m.image_urls = nil
	m.appendimage_urls = nil
	delete(m.clearedFields, product.FieldImageUrls)
}

// SetUnitOfMeasurement sets the "unit_of_measurement" field.
func (m *ProductMutation) SetUnitOfMeasurement(s string) {
	m.unit_of_measurement = &s
}

// UnitOfMeasurement returns the value of the "unit_of_measurement" field in the mutation.
func (m *ProductMutation) UnitOfMeasurement() (r string, exists bool) {
	v := m.unit_of_measurement
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitOfMeasurement returns the old "unit_of_measurement" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldUnitOfMeasurement(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitOfMeasurement is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitOfMeasurement requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitOfMeasurement: %w", err)
	}
	return oldValue.UnitOfMeasurement, nil
}

// ClearUnitOfMeasurement clears the value of the "unit_of_measurement" field.
func (m *ProductMutation) ClearUnitOfMeasurement() {
	m.unit_of_measurement = nil
	m.clearedFields[product.FieldUnitOfMeasurement] = struct{}{}
}

// UnitOfMeasurementCleared returns if the "unit_of_measurement" field was cleared in this mutation.
func (m *ProductMutation) UnitOfMeasurementCleared() bool {
	_, ok := m.clearedFields[product.FieldUnitOfMeasurement]
	return ok
}

// ResetUnitOfMeasurement resets all changes to the "unit_of_measurement" field.
func (m *ProductMutation) ResetUnitOfMeasurement() {
	m.unit_of_measurement = nil
	delete(m.clearedFields, product.FieldUnitOfMeasurement)
}

// SetType sets the "type" field.
func (m *ProductMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *ProductMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldType(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *ProductMutation) ClearType() {
	m._type = nil
	m.clearedFields[product.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *ProductMutation) TypeCleared() bool {
	_, ok := m.clearedFields[product.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *ProductMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, product.FieldType)
}

// SetProvider sets the "provider" field.
func (m *ProductMutation) SetProvider(s string) {
	m.provider = &s
}

// Provider returns the value of the "provider" field in the mutation.
func (m *ProductMutation) Provider() (r string, exists bool) {
	v := m.provider
	if v == nil {
		return
	}
	return *v, true
}

// OldProvider returns the old "provider" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldProvider(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvider is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvider requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvider: %w", err)
	}
	return oldValue.Provider, nil
}

// ClearProvider clears the value of the "provider" field.
func (m *ProductMutation) ClearProvider() {
	m.provider = nil
	m.clearedFields[product.FieldProvider] = struct{}{}
}

// ProviderCleared returns if the "provider" field was cleared in this mutation.
func (m *ProductMutation) ProviderCleared() bool {
	_, ok := m.clearedFields[product.FieldProvider]
	return ok
}

// ResetProvider resets all changes to the "provider" field.
func (m *ProductMutation) ResetProvider() {
	m.provider = nil
	delete(m.clearedFields, product.FieldProvider)
}

// AddTagIDs adds the "tags" edge to the Tag entity by ids.
func (m *ProductMutation) AddTagIDs(ids ...uuid.UUID) {
	if m.tags == nil {
		m.tags = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the Tag entity.
func (m *ProductMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the Tag entity was cleared.
func (m *ProductMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the Tag entity by IDs.
func (m *ProductMutation) RemoveTagIDs(ids ...uuid.UUID) {
	if m.removedtags == nil {
		m.removedtags = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the Tag entity.
func (m *ProductMutation) RemovedTagsIDs() (ids []uuid.UUID) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *ProductMutation) TagsIDs() (ids []uuid.UUID) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *ProductMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// Where appends a list predicates to the ProductMutation builder.
func (m *ProductMutation) Where(ps ...predicate.Product) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Product, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Product).
func (m *ProductMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, product.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, product.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, product.FieldName)
	}
	if m.description != nil {
		fields = append(fields, product.FieldDescription)
	}
	if m.year != nil {
		fields = append(fields, product.FieldYear)
	}
	if m.price != nil {
		fields = append(fields, product.FieldPrice)
	}
	if m.qty != nil {
		fields = append(fields, product.FieldQty)
	}
	if m.image_urls != nil {
		fields = append(fields, product.FieldImageUrls)
	}
	if m.unit_of_measurement != nil {
		fields = append(fields, product.FieldUnitOfMeasurement)
	}
	if m._type != nil {
		fields = append(fields, product.FieldType)
	}
	if m.provider != nil {
		fields = append(fields, product.FieldProvider)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case product.FieldCreatedAt:
		return m.CreatedAt()
	case product.FieldUpdatedAt:
		return m.UpdatedAt()
	case product.FieldName:
		return m.Name()
	case product.FieldDescription:
		return m.Description()
	case product.FieldYear:
		return m.Year()
	case product.FieldPrice:
		return m.Price()
	case product.FieldQty:
		return m.Qty()
	case product.FieldImageUrls:
		return m.ImageUrls()
	case product.FieldUnitOfMeasurement:
		return m.UnitOfMeasurement()
	case product.FieldType:
		return m.GetType()
	case product.FieldProvider:
		return m.Provider()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case product.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case product.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case product.FieldName:
		return m.OldName(ctx)
	case product.FieldDescription:
		return m.OldDescription(ctx)
	case product.FieldYear:
		return m.OldYear(ctx)
	case product.FieldPrice:
		return m.OldPrice(ctx)
	case product.FieldQty:
		return m.OldQty(ctx)
	case product.FieldImageUrls:
		return m.OldImageUrls(ctx)
	case product.FieldUnitOfMeasurement:
		return m.OldUnitOfMeasurement(ctx)
	case product.FieldType:
		return m.OldType(ctx)
	case product.FieldProvider:
		return m.OldProvider(ctx)
	}
	return nil, fmt.Errorf("unknown Product field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) SetField(name string, value ent.Value) error {
	switch name {
	case product.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case product.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case product.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case product.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case product.FieldYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYear(v)
		return nil
	case product.FieldPrice:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case product.FieldQty:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQty(v)
		return nil
	case product.FieldImageUrls:
		v, ok := value.([]url.URL)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImageUrls(v)
		return nil
	case product.FieldUnitOfMeasurement:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitOfMeasurement(v)
		return nil
	case product.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case product.FieldProvider:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvider(v)
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductMutation) AddedFields() []string {
	var fields []string
	if m.addyear != nil {
		fields = append(fields, product.FieldYear)
	}
	if m.addprice != nil {
		fields = append(fields, product.FieldPrice)
	}
	if m.addqty != nil {
		fields = append(fields, product.FieldQty)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case product.FieldYear:
		return m.AddedYear()
	case product.FieldPrice:
		return m.AddedPrice()
	case product.FieldQty:
		return m.AddedQty()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) AddField(name string, value ent.Value) error {
	switch name {
	case product.FieldYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddYear(v)
		return nil
	case product.FieldPrice:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case product.FieldQty:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQty(v)
		return nil
	}
	return fmt.Errorf("unknown Product numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(product.FieldDescription) {
		fields = append(fields, product.FieldDescription)
	}
	if m.FieldCleared(product.FieldImageUrls) {
		fields = append(fields, product.FieldImageUrls)
	}
	if m.FieldCleared(product.FieldUnitOfMeasurement) {
		fields = append(fields, product.FieldUnitOfMeasurement)
	}
	if m.FieldCleared(product.FieldType) {
		fields = append(fields, product.FieldType)
	}
	if m.FieldCleared(product.FieldProvider) {
		fields = append(fields, product.FieldProvider)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductMutation) ClearField(name string) error {
	switch name {
	case product.FieldDescription:
		m.ClearDescription()
		return nil
	case product.FieldImageUrls:
		m.ClearImageUrls()
		return nil
	case product.FieldUnitOfMeasurement:
		m.ClearUnitOfMeasurement()
		return nil
	case product.FieldType:
		m.ClearType()
		return nil
	case product.FieldProvider:
		m.ClearProvider()
		return nil
	}
	return fmt.Errorf("unknown Product nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductMutation) ResetField(name string) error {
	switch name {
	case product.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case product.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case product.FieldName:
		m.ResetName()
		return nil
	case product.FieldDescription:
		m.ResetDescription()
		return nil
	case product.FieldYear:
		m.ResetYear()
		return nil
	case product.FieldPrice:
		m.ResetPrice()
		return nil
	case product.FieldQty:
		m.ResetQty()
		return nil
	case product.FieldImageUrls:
		m.ResetImageUrls()
		return nil
	case product.FieldUnitOfMeasurement:
		m.ResetUnitOfMeasurement()
		return nil
	case product.FieldType:
		m.ResetType()
		return nil
	case product.FieldProvider:
		m.ResetProvider()
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tags != nil {
		edges = append(edges, product.EdgeTags)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case product.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedtags != nil {
		edges = append(edges, product.EdgeTags)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case product.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtags {
		edges = append(edges, product.EdgeTags)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductMutation) EdgeCleared(name string) bool {
	switch name {
	case product.EdgeTags:
		return m.clearedtags
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Product unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductMutation) ResetEdge(name string) error {
	switch name {
	case product.EdgeTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown Product edge %s", name)
}

// ProductTagMutation represents an operation that mutates the ProductTag nodes in the graph.
type ProductTagMutation struct {
	config
	op              Op
	typ             string
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	products        *uuid.UUID
	clearedproducts bool
	tags            *uuid.UUID
	clearedtags     bool
	done            bool
	oldValue        func(context.Context) (*ProductTag, error)
	predicates      []predicate.ProductTag
}

var _ ent.Mutation = (*ProductTagMutation)(nil)

// producttagOption allows management of the mutation configuration using functional options.
type producttagOption func(*ProductTagMutation)

// newProductTagMutation creates new mutation for the ProductTag entity.
func newProductTagMutation(c config, op Op, opts ...producttagOption) *ProductTagMutation {
	m := &ProductTagMutation{
		config:        c,
		op:            op,
		typ:           TypeProductTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductTagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductTagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ProductTagMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProductTagMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProductTagMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProductTagMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProductTagMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProductTagMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetProductID sets the "product_id" field.
func (m *ProductTagMutation) SetProductID(u uuid.UUID) {
	m.products = &u
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *ProductTagMutation) ProductID() (r uuid.UUID, exists bool) {
	v := m.products
	if v == nil {
		return
	}
	return *v, true
}

// ResetProductID resets all changes to the "product_id" field.
func (m *ProductTagMutation) ResetProductID() {
	m.products = nil
}

// SetTagID sets the "tag_id" field.
func (m *ProductTagMutation) SetTagID(u uuid.UUID) {
	m.tags = &u
}

// TagID returns the value of the "tag_id" field in the mutation.
func (m *ProductTagMutation) TagID() (r uuid.UUID, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// ResetTagID resets all changes to the "tag_id" field.
func (m *ProductTagMutation) ResetTagID() {
	m.tags = nil
}

// SetProductsID sets the "products" edge to the Product entity by id.
func (m *ProductTagMutation) SetProductsID(id uuid.UUID) {
	m.products = &id
}

// ClearProducts clears the "products" edge to the Product entity.
func (m *ProductTagMutation) ClearProducts() {
	m.clearedproducts = true
	m.clearedFields[producttag.FieldProductID] = struct{}{}
}

// ProductsCleared reports if the "products" edge to the Product entity was cleared.
func (m *ProductTagMutation) ProductsCleared() bool {
	return m.clearedproducts
}

// ProductsID returns the "products" edge ID in the mutation.
func (m *ProductTagMutation) ProductsID() (id uuid.UUID, exists bool) {
	if m.products != nil {
		return *m.products, true
	}
	return
}

// ProductsIDs returns the "products" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductsID instead. It exists only for internal usage by the builders.
func (m *ProductTagMutation) ProductsIDs() (ids []uuid.UUID) {
	if id := m.products; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProducts resets all changes to the "products" edge.
func (m *ProductTagMutation) ResetProducts() {
	m.products = nil
	m.clearedproducts = false
}

// SetTagsID sets the "tags" edge to the Tag entity by id.
func (m *ProductTagMutation) SetTagsID(id uuid.UUID) {
	m.tags = &id
}

// ClearTags clears the "tags" edge to the Tag entity.
func (m *ProductTagMutation) ClearTags() {
	m.clearedtags = true
	m.clearedFields[producttag.FieldTagID] = struct{}{}
}

// TagsCleared reports if the "tags" edge to the Tag entity was cleared.
func (m *ProductTagMutation) TagsCleared() bool {
	return m.clearedtags
}

// TagsID returns the "tags" edge ID in the mutation.
func (m *ProductTagMutation) TagsID() (id uuid.UUID, exists bool) {
	if m.tags != nil {
		return *m.tags, true
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TagsID instead. It exists only for internal usage by the builders.
func (m *ProductTagMutation) TagsIDs() (ids []uuid.UUID) {
	if id := m.tags; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *ProductTagMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
}

// Where appends a list predicates to the ProductTagMutation builder.
func (m *ProductTagMutation) Where(ps ...predicate.ProductTag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductTagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductTagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProductTag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductTagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductTagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProductTag).
func (m *ProductTagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductTagMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, producttag.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, producttag.FieldUpdatedAt)
	}
	if m.products != nil {
		fields = append(fields, producttag.FieldProductID)
	}
	if m.tags != nil {
		fields = append(fields, producttag.FieldTagID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductTagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case producttag.FieldCreatedAt:
		return m.CreatedAt()
	case producttag.FieldUpdatedAt:
		return m.UpdatedAt()
	case producttag.FieldProductID:
		return m.ProductID()
	case producttag.FieldTagID:
		return m.TagID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductTagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, errors.New("edge schema ProductTag does not support getting old values")
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductTagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case producttag.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case producttag.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case producttag.FieldProductID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case producttag.FieldTagID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTagID(v)
		return nil
	}
	return fmt.Errorf("unknown ProductTag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductTagMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductTagMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductTagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProductTag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductTagMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductTagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductTagMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProductTag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductTagMutation) ResetField(name string) error {
	switch name {
	case producttag.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case producttag.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case producttag.FieldProductID:
		m.ResetProductID()
		return nil
	case producttag.FieldTagID:
		m.ResetTagID()
		return nil
	}
	return fmt.Errorf("unknown ProductTag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductTagMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.products != nil {
		edges = append(edges, producttag.EdgeProducts)
	}
	if m.tags != nil {
		edges = append(edges, producttag.EdgeTags)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductTagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case producttag.EdgeProducts:
		if id := m.products; id != nil {
			return []ent.Value{*id}
		}
	case producttag.EdgeTags:
		if id := m.tags; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductTagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductTagMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductTagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproducts {
		edges = append(edges, producttag.EdgeProducts)
	}
	if m.clearedtags {
		edges = append(edges, producttag.EdgeTags)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductTagMutation) EdgeCleared(name string) bool {
	switch name {
	case producttag.EdgeProducts:
		return m.clearedproducts
	case producttag.EdgeTags:
		return m.clearedtags
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductTagMutation) ClearEdge(name string) error {
	switch name {
	case producttag.EdgeProducts:
		m.ClearProducts()
		return nil
	case producttag.EdgeTags:
		m.ClearTags()
		return nil
	}
	return fmt.Errorf("unknown ProductTag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductTagMutation) ResetEdge(name string) error {
	switch name {
	case producttag.EdgeProducts:
		m.ResetProducts()
		return nil
	case producttag.EdgeTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown ProductTag edge %s", name)
}

// TagMutation represents an operation that mutates the Tag nodes in the graph.
type TagMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	created_at      *time.Time
	updated_at      *time.Time
	title           *string
	clearedFields   map[string]struct{}
	products        map[uuid.UUID]struct{}
	removedproducts map[uuid.UUID]struct{}
	clearedproducts bool
	done            bool
	oldValue        func(context.Context) (*Tag, error)
	predicates      []predicate.Tag
}

var _ ent.Mutation = (*TagMutation)(nil)

// tagOption allows management of the mutation configuration using functional options.
type tagOption func(*TagMutation)

// newTagMutation creates new mutation for the Tag entity.
func newTagMutation(c config, op Op, opts ...tagOption) *TagMutation {
	m := &TagMutation{
		config:        c,
		op:            op,
		typ:           TypeTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTagID sets the ID field of the mutation.
func withTagID(id uuid.UUID) tagOption {
	return func(m *TagMutation) {
		var (
			err   error
			once  sync.Once
			value *Tag
		)
		m.oldValue = func(ctx context.Context) (*Tag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTag sets the old Tag of the mutation.
func withTag(node *Tag) tagOption {
	return func(m *TagMutation) {
		m.oldValue = func(context.Context) (*Tag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Tag entities.
func (m *TagMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TagMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TagMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TagMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TagMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TagMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TagMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TagMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TagMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTitle sets the "title" field.
func (m *TagMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *TagMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *TagMutation) ResetTitle() {
	m.title = nil
}

// AddProductIDs adds the "products" edge to the Product entity by ids.
func (m *TagMutation) AddProductIDs(ids ...uuid.UUID) {
	if m.products == nil {
		m.products = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.products[ids[i]] = struct{}{}
	}
}

// ClearProducts clears the "products" edge to the Product entity.
func (m *TagMutation) ClearProducts() {
	m.clearedproducts = true
}

// ProductsCleared reports if the "products" edge to the Product entity was cleared.
func (m *TagMutation) ProductsCleared() bool {
	return m.clearedproducts
}

// RemoveProductIDs removes the "products" edge to the Product entity by IDs.
func (m *TagMutation) RemoveProductIDs(ids ...uuid.UUID) {
	if m.removedproducts == nil {
		m.removedproducts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.products, ids[i])
		m.removedproducts[ids[i]] = struct{}{}
	}
}

// RemovedProducts returns the removed IDs of the "products" edge to the Product entity.
func (m *TagMutation) RemovedProductsIDs() (ids []uuid.UUID) {
	for id := range m.removedproducts {
		ids = append(ids, id)
	}
	return
}

// ProductsIDs returns the "products" edge IDs in the mutation.
func (m *TagMutation) ProductsIDs() (ids []uuid.UUID) {
	for id := range m.products {
		ids = append(ids, id)
	}
	return
}

// ResetProducts resets all changes to the "products" edge.
func (m *TagMutation) ResetProducts() {
	m.products = nil
	m.clearedproducts = false
	m.removedproducts = nil
}

// Where appends a list predicates to the TagMutation builder.
func (m *TagMutation) Where(ps ...predicate.Tag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tag).
func (m *TagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TagMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, tag.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tag.FieldUpdatedAt)
	}
	if m.title != nil {
		fields = append(fields, tag.FieldTitle)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tag.FieldCreatedAt:
		return m.CreatedAt()
	case tag.FieldUpdatedAt:
		return m.UpdatedAt()
	case tag.FieldTitle:
		return m.Title()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tag.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tag.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tag.FieldTitle:
		return m.OldTitle(ctx)
	}
	return nil, fmt.Errorf("unknown Tag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tag.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tag.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tag.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TagMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TagMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TagMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TagMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Tag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TagMutation) ResetField(name string) error {
	switch name {
	case tag.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tag.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tag.FieldTitle:
		m.ResetTitle()
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TagMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.products != nil {
		edges = append(edges, tag.EdgeProducts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.products))
		for id := range m.products {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedproducts != nil {
		edges = append(edges, tag.EdgeProducts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.removedproducts))
		for id := range m.removedproducts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedproducts {
		edges = append(edges, tag.EdgeProducts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TagMutation) EdgeCleared(name string) bool {
	switch name {
	case tag.EdgeProducts:
		return m.clearedproducts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TagMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TagMutation) ResetEdge(name string) error {
	switch name {
	case tag.EdgeProducts:
		m.ResetProducts()
		return nil
	}
	return fmt.Errorf("unknown Tag edge %s", name)
}

// TransactionTypeMutation represents an operation that mutates the TransactionType nodes in the graph.
type TransactionTypeMutation struct {
	config
	op               Op
	typ              string
	id               *int
	created_at       *time.Time
	updated_at       *time.Time
	transaction_type *string
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*TransactionType, error)
	predicates       []predicate.TransactionType
}

var _ ent.Mutation = (*TransactionTypeMutation)(nil)

// transactiontypeOption allows management of the mutation configuration using functional options.
type transactiontypeOption func(*TransactionTypeMutation)

// newTransactionTypeMutation creates new mutation for the TransactionType entity.
func newTransactionTypeMutation(c config, op Op, opts ...transactiontypeOption) *TransactionTypeMutation {
	m := &TransactionTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeTransactionType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTransactionTypeID sets the ID field of the mutation.
func withTransactionTypeID(id int) transactiontypeOption {
	return func(m *TransactionTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *TransactionType
		)
		m.oldValue = func(ctx context.Context) (*TransactionType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TransactionType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTransactionType sets the old TransactionType of the mutation.
func withTransactionType(node *TransactionType) transactiontypeOption {
	return func(m *TransactionTypeMutation) {
		m.oldValue = func(context.Context) (*TransactionType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TransactionTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TransactionTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TransactionTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TransactionTypeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TransactionType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TransactionTypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TransactionTypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TransactionType entity.
// If the TransactionType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionTypeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TransactionTypeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TransactionTypeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TransactionTypeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TransactionType entity.
// If the TransactionType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionTypeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TransactionTypeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTransactionType sets the "transaction_type" field.
func (m *TransactionTypeMutation) SetTransactionType(s string) {
	m.transaction_type = &s
}

// TransactionType returns the value of the "transaction_type" field in the mutation.
func (m *TransactionTypeMutation) TransactionType() (r string, exists bool) {
	v := m.transaction_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionType returns the old "transaction_type" field's value of the TransactionType entity.
// If the TransactionType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionTypeMutation) OldTransactionType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransactionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransactionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionType: %w", err)
	}
	return oldValue.TransactionType, nil
}

// ResetTransactionType resets all changes to the "transaction_type" field.
func (m *TransactionTypeMutation) ResetTransactionType() {
	m.transaction_type = nil
}

// Where appends a list predicates to the TransactionTypeMutation builder.
func (m *TransactionTypeMutation) Where(ps ...predicate.TransactionType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TransactionTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TransactionTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TransactionType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TransactionTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TransactionTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TransactionType).
func (m *TransactionTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TransactionTypeMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, transactiontype.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, transactiontype.FieldUpdatedAt)
	}
	if m.transaction_type != nil {
		fields = append(fields, transactiontype.FieldTransactionType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TransactionTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case transactiontype.FieldCreatedAt:
		return m.CreatedAt()
	case transactiontype.FieldUpdatedAt:
		return m.UpdatedAt()
	case transactiontype.FieldTransactionType:
		return m.TransactionType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TransactionTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case transactiontype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case transactiontype.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case transactiontype.FieldTransactionType:
		return m.OldTransactionType(ctx)
	}
	return nil, fmt.Errorf("unknown TransactionType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case transactiontype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case transactiontype.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case transactiontype.FieldTransactionType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionType(v)
		return nil
	}
	return fmt.Errorf("unknown TransactionType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TransactionTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TransactionTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TransactionType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TransactionTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TransactionTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TransactionTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TransactionType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TransactionTypeMutation) ResetField(name string) error {
	switch name {
	case transactiontype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case transactiontype.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case transactiontype.FieldTransactionType:
		m.ResetTransactionType()
		return nil
	}
	return fmt.Errorf("unknown TransactionType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TransactionTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TransactionTypeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TransactionTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TransactionTypeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TransactionTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TransactionTypeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TransactionTypeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TransactionType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TransactionTypeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TransactionType edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	created_at         *time.Time
	updated_at         *time.Time
	avatar_url         **url.URL
	email              *string
	last_reset         *time.Time
	last_verification  *time.Time
	name               *string
	password_hash      *string
	username           *string
	verified           *bool
	phone              *string
	role               *user.Role
	address            *string
	postal_code        *string
	other_address_info *string
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*User, error)
	predicates         []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetAvatarURL sets the "avatar_url" field.
func (m *UserMutation) SetAvatarURL(u *url.URL) {
	m.avatar_url = &u
}

// AvatarURL returns the value of the "avatar_url" field in the mutation.
func (m *UserMutation) AvatarURL() (r *url.URL, exists bool) {
	v := m.avatar_url
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarURL returns the old "avatar_url" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatarURL(ctx context.Context) (v *url.URL, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatarURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatarURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarURL: %w", err)
	}
	return oldValue.AvatarURL, nil
}

// ClearAvatarURL clears the value of the "avatar_url" field.
func (m *UserMutation) ClearAvatarURL() {
	m.avatar_url = nil
	m.clearedFields[user.FieldAvatarURL] = struct{}{}
}

// AvatarURLCleared returns if the "avatar_url" field was cleared in this mutation.
func (m *UserMutation) AvatarURLCleared() bool {
	_, ok := m.clearedFields[user.FieldAvatarURL]
	return ok
}

// ResetAvatarURL resets all changes to the "avatar_url" field.
func (m *UserMutation) ResetAvatarURL() {
	m.avatar_url = nil
	delete(m.clearedFields, user.FieldAvatarURL)
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetLastReset sets the "last_reset" field.
func (m *UserMutation) SetLastReset(t time.Time) {
	m.last_reset = &t
}

// LastReset returns the value of the "last_reset" field in the mutation.
func (m *UserMutation) LastReset() (r time.Time, exists bool) {
	v := m.last_reset
	if v == nil {
		return
	}
	return *v, true
}

// OldLastReset returns the old "last_reset" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastReset(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastReset is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastReset requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastReset: %w", err)
	}
	return oldValue.LastReset, nil
}

// ClearLastReset clears the value of the "last_reset" field.
func (m *UserMutation) ClearLastReset() {
	m.last_reset = nil
	m.clearedFields[user.FieldLastReset] = struct{}{}
}

// LastResetCleared returns if the "last_reset" field was cleared in this mutation.
func (m *UserMutation) LastResetCleared() bool {
	_, ok := m.clearedFields[user.FieldLastReset]
	return ok
}

// ResetLastReset resets all changes to the "last_reset" field.
func (m *UserMutation) ResetLastReset() {
	m.last_reset = nil
	delete(m.clearedFields, user.FieldLastReset)
}

// SetLastVerification sets the "last_verification" field.
func (m *UserMutation) SetLastVerification(t time.Time) {
	m.last_verification = &t
}

// LastVerification returns the value of the "last_verification" field in the mutation.
func (m *UserMutation) LastVerification() (r time.Time, exists bool) {
	v := m.last_verification
	if v == nil {
		return
	}
	return *v, true
}

// OldLastVerification returns the old "last_verification" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastVerification(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastVerification is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastVerification requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastVerification: %w", err)
	}
	return oldValue.LastVerification, nil
}

// ClearLastVerification clears the value of the "last_verification" field.
func (m *UserMutation) ClearLastVerification() {
	m.last_verification = nil
	m.clearedFields[user.FieldLastVerification] = struct{}{}
}

// LastVerificationCleared returns if the "last_verification" field was cleared in this mutation.
func (m *UserMutation) LastVerificationCleared() bool {
	_, ok := m.clearedFields[user.FieldLastVerification]
	return ok
}

// ResetLastVerification resets all changes to the "last_verification" field.
func (m *UserMutation) ResetLastVerification() {
	m.last_verification = nil
	delete(m.clearedFields, user.FieldLastVerification)
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetPasswordHash sets the "password_hash" field.
func (m *UserMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *UserMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *UserMutation) ResetPasswordHash() {
	m.password_hash = nil
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetVerified sets the "verified" field.
func (m *UserMutation) SetVerified(b bool) {
	m.verified = &b
}

// Verified returns the value of the "verified" field in the mutation.
func (m *UserMutation) Verified() (r bool, exists bool) {
	v := m.verified
	if v == nil {
		return
	}
	return *v, true
}

// OldVerified returns the old "verified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerified: %w", err)
	}
	return oldValue.Verified, nil
}

// ResetVerified resets all changes to the "verified" field.
func (m *UserMutation) ResetVerified() {
	m.verified = nil
}

// SetPhone sets the "phone" field.
func (m *UserMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *UserMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *UserMutation) ResetPhone() {
	m.phone = nil
}

// SetRole sets the "role" field.
func (m *UserMutation) SetRole(u user.Role) {
	m.role = &u
}

// Role returns the value of the "role" field in the mutation.
func (m *UserMutation) Role() (r user.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRole(ctx context.Context) (v user.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *UserMutation) ResetRole() {
	m.role = nil
}

// SetAddress sets the "address" field.
func (m *UserMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *UserMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *UserMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[user.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *UserMutation) AddressCleared() bool {
	_, ok := m.clearedFields[user.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *UserMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, user.FieldAddress)
}

// SetPostalCode sets the "postal_code" field.
func (m *UserMutation) SetPostalCode(s string) {
	m.postal_code = &s
}

// PostalCode returns the value of the "postal_code" field in the mutation.
func (m *UserMutation) PostalCode() (r string, exists bool) {
	v := m.postal_code
	if v == nil {
		return
	}
	return *v, true
}

// OldPostalCode returns the old "postal_code" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPostalCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostalCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostalCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostalCode: %w", err)
	}
	return oldValue.PostalCode, nil
}

// ClearPostalCode clears the value of the "postal_code" field.
func (m *UserMutation) ClearPostalCode() {
	m.postal_code = nil
	m.clearedFields[user.FieldPostalCode] = struct{}{}
}

// PostalCodeCleared returns if the "postal_code" field was cleared in this mutation.
func (m *UserMutation) PostalCodeCleared() bool {
	_, ok := m.clearedFields[user.FieldPostalCode]
	return ok
}

// ResetPostalCode resets all changes to the "postal_code" field.
func (m *UserMutation) ResetPostalCode() {
	m.postal_code = nil
	delete(m.clearedFields, user.FieldPostalCode)
}

// SetOtherAddressInfo sets the "other_address_info" field.
func (m *UserMutation) SetOtherAddressInfo(s string) {
	m.other_address_info = &s
}

// OtherAddressInfo returns the value of the "other_address_info" field in the mutation.
func (m *UserMutation) OtherAddressInfo() (r string, exists bool) {
	v := m.other_address_info
	if v == nil {
		return
	}
	return *v, true
}

// OldOtherAddressInfo returns the old "other_address_info" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldOtherAddressInfo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOtherAddressInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOtherAddressInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOtherAddressInfo: %w", err)
	}
	return oldValue.OtherAddressInfo, nil
}

// ClearOtherAddressInfo clears the value of the "other_address_info" field.
func (m *UserMutation) ClearOtherAddressInfo() {
	m.other_address_info = nil
	m.clearedFields[user.FieldOtherAddressInfo] = struct{}{}
}

// OtherAddressInfoCleared returns if the "other_address_info" field was cleared in this mutation.
func (m *UserMutation) OtherAddressInfoCleared() bool {
	_, ok := m.clearedFields[user.FieldOtherAddressInfo]
	return ok
}

// ResetOtherAddressInfo resets all changes to the "other_address_info" field.
func (m *UserMutation) ResetOtherAddressInfo() {
	m.other_address_info = nil
	delete(m.clearedFields, user.FieldOtherAddressInfo)
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.avatar_url != nil {
		fields = append(fields, user.FieldAvatarURL)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.last_reset != nil {
		fields = append(fields, user.FieldLastReset)
	}
	if m.last_verification != nil {
		fields = append(fields, user.FieldLastVerification)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.password_hash != nil {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.verified != nil {
		fields = append(fields, user.FieldVerified)
	}
	if m.phone != nil {
		fields = append(fields, user.FieldPhone)
	}
	if m.role != nil {
		fields = append(fields, user.FieldRole)
	}
	if m.address != nil {
		fields = append(fields, user.FieldAddress)
	}
	if m.postal_code != nil {
		fields = append(fields, user.FieldPostalCode)
	}
	if m.other_address_info != nil {
		fields = append(fields, user.FieldOtherAddressInfo)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldAvatarURL:
		return m.AvatarURL()
	case user.FieldEmail:
		return m.Email()
	case user.FieldLastReset:
		return m.LastReset()
	case user.FieldLastVerification:
		return m.LastVerification()
	case user.FieldName:
		return m.Name()
	case user.FieldPasswordHash:
		return m.PasswordHash()
	case user.FieldUsername:
		return m.Username()
	case user.FieldVerified:
		return m.Verified()
	case user.FieldPhone:
		return m.Phone()
	case user.FieldRole:
		return m.Role()
	case user.FieldAddress:
		return m.Address()
	case user.FieldPostalCode:
		return m.PostalCode()
	case user.FieldOtherAddressInfo:
		return m.OtherAddressInfo()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldAvatarURL:
		return m.OldAvatarURL(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldLastReset:
		return m.OldLastReset(ctx)
	case user.FieldLastVerification:
		return m.OldLastVerification(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldVerified:
		return m.OldVerified(ctx)
	case user.FieldPhone:
		return m.OldPhone(ctx)
	case user.FieldRole:
		return m.OldRole(ctx)
	case user.FieldAddress:
		return m.OldAddress(ctx)
	case user.FieldPostalCode:
		return m.OldPostalCode(ctx)
	case user.FieldOtherAddressInfo:
		return m.OldOtherAddressInfo(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldAvatarURL:
		v, ok := value.(*url.URL)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarURL(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldLastReset:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastReset(v)
		return nil
	case user.FieldLastVerification:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastVerification(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerified(v)
		return nil
	case user.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case user.FieldRole:
		v, ok := value.(user.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case user.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case user.FieldPostalCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostalCode(v)
		return nil
	case user.FieldOtherAddressInfo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOtherAddressInfo(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldAvatarURL) {
		fields = append(fields, user.FieldAvatarURL)
	}
	if m.FieldCleared(user.FieldLastReset) {
		fields = append(fields, user.FieldLastReset)
	}
	if m.FieldCleared(user.FieldLastVerification) {
		fields = append(fields, user.FieldLastVerification)
	}
	if m.FieldCleared(user.FieldAddress) {
		fields = append(fields, user.FieldAddress)
	}
	if m.FieldCleared(user.FieldPostalCode) {
		fields = append(fields, user.FieldPostalCode)
	}
	if m.FieldCleared(user.FieldOtherAddressInfo) {
		fields = append(fields, user.FieldOtherAddressInfo)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldAvatarURL:
		m.ClearAvatarURL()
		return nil
	case user.FieldLastReset:
		m.ClearLastReset()
		return nil
	case user.FieldLastVerification:
		m.ClearLastVerification()
		return nil
	case user.FieldAddress:
		m.ClearAddress()
		return nil
	case user.FieldPostalCode:
		m.ClearPostalCode()
		return nil
	case user.FieldOtherAddressInfo:
		m.ClearOtherAddressInfo()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldAvatarURL:
		m.ResetAvatarURL()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldLastReset:
		m.ResetLastReset()
		return nil
	case user.FieldLastVerification:
		m.ResetLastVerification()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldVerified:
		m.ResetVerified()
		return nil
	case user.FieldPhone:
		m.ResetPhone()
		return nil
	case user.FieldRole:
		m.ResetRole()
		return nil
	case user.FieldAddress:
		m.ResetAddress()
		return nil
	case user.FieldPostalCode:
		m.ResetPostalCode()
		return nil
	case user.FieldOtherAddressInfo:
		m.ResetOtherAddressInfo()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown User edge %s", name)
}
