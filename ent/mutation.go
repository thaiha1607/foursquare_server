// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
	"github.com/shopspring/decimal"
	"github.com/thaiha1607/foursquare_server/ent/address"
	"github.com/thaiha1607/foursquare_server/ent/conversation"
	"github.com/thaiha1607/foursquare_server/ent/deliveryassignment"
	"github.com/thaiha1607/foursquare_server/ent/invoice"
	"github.com/thaiha1607/foursquare_server/ent/message"
	"github.com/thaiha1607/foursquare_server/ent/order"
	"github.com/thaiha1607/foursquare_server/ent/orderitem"
	"github.com/thaiha1607/foursquare_server/ent/orderstatuscode"
	"github.com/thaiha1607/foursquare_server/ent/person"
	"github.com/thaiha1607/foursquare_server/ent/personaddress"
	"github.com/thaiha1607/foursquare_server/ent/predicate"
	"github.com/thaiha1607/foursquare_server/ent/productcolor"
	"github.com/thaiha1607/foursquare_server/ent/productimage"
	"github.com/thaiha1607/foursquare_server/ent/productinfo"
	"github.com/thaiha1607/foursquare_server/ent/productqty"
	"github.com/thaiha1607/foursquare_server/ent/producttag"
	"github.com/thaiha1607/foursquare_server/ent/shipment"
	"github.com/thaiha1607/foursquare_server/ent/shipmentitem"
	"github.com/thaiha1607/foursquare_server/ent/tag"
	"github.com/thaiha1607/foursquare_server/ent/warehouseassignment"
	"github.com/thaiha1607/foursquare_server/ent/workunitinfo"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAddress             = "Address"
	TypeConversation        = "Conversation"
	TypeDeliveryAssignment  = "DeliveryAssignment"
	TypeInvoice             = "Invoice"
	TypeMessage             = "Message"
	TypeOrder               = "Order"
	TypeOrderItem           = "OrderItem"
	TypeOrderStatusCode     = "OrderStatusCode"
	TypePerson              = "Person"
	TypePersonAddress       = "PersonAddress"
	TypeProductColor        = "ProductColor"
	TypeProductImage        = "ProductImage"
	TypeProductInfo         = "ProductInfo"
	TypeProductQty          = "ProductQty"
	TypeProductTag          = "ProductTag"
	TypeShipment            = "Shipment"
	TypeShipmentItem        = "ShipmentItem"
	TypeTag                 = "Tag"
	TypeWarehouseAssignment = "WarehouseAssignment"
	TypeWorkUnitInfo        = "WorkUnitInfo"
)

// AddressMutation represents an operation that mutates the Address nodes in the graph.
type AddressMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	created_at            *time.Time
	updated_at            *time.Time
	line1                 *string
	line2                 *string
	city                  *string
	state_or_province     *string
	zip_or_postcode       *string
	country               *string
	other_address_details *string
	clearedFields         map[string]struct{}
	persons               map[uuid.UUID]struct{}
	removedpersons        map[uuid.UUID]struct{}
	clearedpersons        bool
	done                  bool
	oldValue              func(context.Context) (*Address, error)
	predicates            []predicate.Address
}

var _ ent.Mutation = (*AddressMutation)(nil)

// addressOption allows management of the mutation configuration using functional options.
type addressOption func(*AddressMutation)

// newAddressMutation creates new mutation for the Address entity.
func newAddressMutation(c config, op Op, opts ...addressOption) *AddressMutation {
	m := &AddressMutation{
		config:        c,
		op:            op,
		typ:           TypeAddress,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAddressID sets the ID field of the mutation.
func withAddressID(id string) addressOption {
	return func(m *AddressMutation) {
		var (
			err   error
			once  sync.Once
			value *Address
		)
		m.oldValue = func(ctx context.Context) (*Address, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Address.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAddress sets the old Address of the mutation.
func withAddress(node *Address) addressOption {
	return func(m *AddressMutation) {
		m.oldValue = func(context.Context) (*Address, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AddressMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AddressMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Address entities.
func (m *AddressMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AddressMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AddressMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Address.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AddressMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AddressMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AddressMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AddressMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AddressMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AddressMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetLine1 sets the "line1" field.
func (m *AddressMutation) SetLine1(s string) {
	m.line1 = &s
}

// Line1 returns the value of the "line1" field in the mutation.
func (m *AddressMutation) Line1() (r string, exists bool) {
	v := m.line1
	if v == nil {
		return
	}
	return *v, true
}

// OldLine1 returns the old "line1" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldLine1(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLine1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLine1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLine1: %w", err)
	}
	return oldValue.Line1, nil
}

// ResetLine1 resets all changes to the "line1" field.
func (m *AddressMutation) ResetLine1() {
	m.line1 = nil
}

// SetLine2 sets the "line2" field.
func (m *AddressMutation) SetLine2(s string) {
	m.line2 = &s
}

// Line2 returns the value of the "line2" field in the mutation.
func (m *AddressMutation) Line2() (r string, exists bool) {
	v := m.line2
	if v == nil {
		return
	}
	return *v, true
}

// OldLine2 returns the old "line2" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldLine2(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLine2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLine2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLine2: %w", err)
	}
	return oldValue.Line2, nil
}

// ClearLine2 clears the value of the "line2" field.
func (m *AddressMutation) ClearLine2() {
	m.line2 = nil
	m.clearedFields[address.FieldLine2] = struct{}{}
}

// Line2Cleared returns if the "line2" field was cleared in this mutation.
func (m *AddressMutation) Line2Cleared() bool {
	_, ok := m.clearedFields[address.FieldLine2]
	return ok
}

// ResetLine2 resets all changes to the "line2" field.
func (m *AddressMutation) ResetLine2() {
	m.line2 = nil
	delete(m.clearedFields, address.FieldLine2)
}

// SetCity sets the "city" field.
func (m *AddressMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *AddressMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ResetCity resets all changes to the "city" field.
func (m *AddressMutation) ResetCity() {
	m.city = nil
}

// SetStateOrProvince sets the "state_or_province" field.
func (m *AddressMutation) SetStateOrProvince(s string) {
	m.state_or_province = &s
}

// StateOrProvince returns the value of the "state_or_province" field in the mutation.
func (m *AddressMutation) StateOrProvince() (r string, exists bool) {
	v := m.state_or_province
	if v == nil {
		return
	}
	return *v, true
}

// OldStateOrProvince returns the old "state_or_province" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldStateOrProvince(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStateOrProvince is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStateOrProvince requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStateOrProvince: %w", err)
	}
	return oldValue.StateOrProvince, nil
}

// ClearStateOrProvince clears the value of the "state_or_province" field.
func (m *AddressMutation) ClearStateOrProvince() {
	m.state_or_province = nil
	m.clearedFields[address.FieldStateOrProvince] = struct{}{}
}

// StateOrProvinceCleared returns if the "state_or_province" field was cleared in this mutation.
func (m *AddressMutation) StateOrProvinceCleared() bool {
	_, ok := m.clearedFields[address.FieldStateOrProvince]
	return ok
}

// ResetStateOrProvince resets all changes to the "state_or_province" field.
func (m *AddressMutation) ResetStateOrProvince() {
	m.state_or_province = nil
	delete(m.clearedFields, address.FieldStateOrProvince)
}

// SetZipOrPostcode sets the "zip_or_postcode" field.
func (m *AddressMutation) SetZipOrPostcode(s string) {
	m.zip_or_postcode = &s
}

// ZipOrPostcode returns the value of the "zip_or_postcode" field in the mutation.
func (m *AddressMutation) ZipOrPostcode() (r string, exists bool) {
	v := m.zip_or_postcode
	if v == nil {
		return
	}
	return *v, true
}

// OldZipOrPostcode returns the old "zip_or_postcode" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldZipOrPostcode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldZipOrPostcode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldZipOrPostcode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldZipOrPostcode: %w", err)
	}
	return oldValue.ZipOrPostcode, nil
}

// ResetZipOrPostcode resets all changes to the "zip_or_postcode" field.
func (m *AddressMutation) ResetZipOrPostcode() {
	m.zip_or_postcode = nil
}

// SetCountry sets the "country" field.
func (m *AddressMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *AddressMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ResetCountry resets all changes to the "country" field.
func (m *AddressMutation) ResetCountry() {
	m.country = nil
}

// SetOtherAddressDetails sets the "other_address_details" field.
func (m *AddressMutation) SetOtherAddressDetails(s string) {
	m.other_address_details = &s
}

// OtherAddressDetails returns the value of the "other_address_details" field in the mutation.
func (m *AddressMutation) OtherAddressDetails() (r string, exists bool) {
	v := m.other_address_details
	if v == nil {
		return
	}
	return *v, true
}

// OldOtherAddressDetails returns the old "other_address_details" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldOtherAddressDetails(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOtherAddressDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOtherAddressDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOtherAddressDetails: %w", err)
	}
	return oldValue.OtherAddressDetails, nil
}

// ClearOtherAddressDetails clears the value of the "other_address_details" field.
func (m *AddressMutation) ClearOtherAddressDetails() {
	m.other_address_details = nil
	m.clearedFields[address.FieldOtherAddressDetails] = struct{}{}
}

// OtherAddressDetailsCleared returns if the "other_address_details" field was cleared in this mutation.
func (m *AddressMutation) OtherAddressDetailsCleared() bool {
	_, ok := m.clearedFields[address.FieldOtherAddressDetails]
	return ok
}

// ResetOtherAddressDetails resets all changes to the "other_address_details" field.
func (m *AddressMutation) ResetOtherAddressDetails() {
	m.other_address_details = nil
	delete(m.clearedFields, address.FieldOtherAddressDetails)
}

// AddPersonIDs adds the "persons" edge to the Person entity by ids.
func (m *AddressMutation) AddPersonIDs(ids ...uuid.UUID) {
	if m.persons == nil {
		m.persons = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.persons[ids[i]] = struct{}{}
	}
}

// ClearPersons clears the "persons" edge to the Person entity.
func (m *AddressMutation) ClearPersons() {
	m.clearedpersons = true
}

// PersonsCleared reports if the "persons" edge to the Person entity was cleared.
func (m *AddressMutation) PersonsCleared() bool {
	return m.clearedpersons
}

// RemovePersonIDs removes the "persons" edge to the Person entity by IDs.
func (m *AddressMutation) RemovePersonIDs(ids ...uuid.UUID) {
	if m.removedpersons == nil {
		m.removedpersons = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.persons, ids[i])
		m.removedpersons[ids[i]] = struct{}{}
	}
}

// RemovedPersons returns the removed IDs of the "persons" edge to the Person entity.
func (m *AddressMutation) RemovedPersonsIDs() (ids []uuid.UUID) {
	for id := range m.removedpersons {
		ids = append(ids, id)
	}
	return
}

// PersonsIDs returns the "persons" edge IDs in the mutation.
func (m *AddressMutation) PersonsIDs() (ids []uuid.UUID) {
	for id := range m.persons {
		ids = append(ids, id)
	}
	return
}

// ResetPersons resets all changes to the "persons" edge.
func (m *AddressMutation) ResetPersons() {
	m.persons = nil
	m.clearedpersons = false
	m.removedpersons = nil
}

// Where appends a list predicates to the AddressMutation builder.
func (m *AddressMutation) Where(ps ...predicate.Address) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AddressMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AddressMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Address, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AddressMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AddressMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Address).
func (m *AddressMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AddressMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, address.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, address.FieldUpdatedAt)
	}
	if m.line1 != nil {
		fields = append(fields, address.FieldLine1)
	}
	if m.line2 != nil {
		fields = append(fields, address.FieldLine2)
	}
	if m.city != nil {
		fields = append(fields, address.FieldCity)
	}
	if m.state_or_province != nil {
		fields = append(fields, address.FieldStateOrProvince)
	}
	if m.zip_or_postcode != nil {
		fields = append(fields, address.FieldZipOrPostcode)
	}
	if m.country != nil {
		fields = append(fields, address.FieldCountry)
	}
	if m.other_address_details != nil {
		fields = append(fields, address.FieldOtherAddressDetails)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AddressMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case address.FieldCreatedAt:
		return m.CreatedAt()
	case address.FieldUpdatedAt:
		return m.UpdatedAt()
	case address.FieldLine1:
		return m.Line1()
	case address.FieldLine2:
		return m.Line2()
	case address.FieldCity:
		return m.City()
	case address.FieldStateOrProvince:
		return m.StateOrProvince()
	case address.FieldZipOrPostcode:
		return m.ZipOrPostcode()
	case address.FieldCountry:
		return m.Country()
	case address.FieldOtherAddressDetails:
		return m.OtherAddressDetails()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AddressMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case address.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case address.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case address.FieldLine1:
		return m.OldLine1(ctx)
	case address.FieldLine2:
		return m.OldLine2(ctx)
	case address.FieldCity:
		return m.OldCity(ctx)
	case address.FieldStateOrProvince:
		return m.OldStateOrProvince(ctx)
	case address.FieldZipOrPostcode:
		return m.OldZipOrPostcode(ctx)
	case address.FieldCountry:
		return m.OldCountry(ctx)
	case address.FieldOtherAddressDetails:
		return m.OldOtherAddressDetails(ctx)
	}
	return nil, fmt.Errorf("unknown Address field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AddressMutation) SetField(name string, value ent.Value) error {
	switch name {
	case address.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case address.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case address.FieldLine1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLine1(v)
		return nil
	case address.FieldLine2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLine2(v)
		return nil
	case address.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case address.FieldStateOrProvince:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStateOrProvince(v)
		return nil
	case address.FieldZipOrPostcode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetZipOrPostcode(v)
		return nil
	case address.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case address.FieldOtherAddressDetails:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOtherAddressDetails(v)
		return nil
	}
	return fmt.Errorf("unknown Address field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AddressMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AddressMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AddressMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Address numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AddressMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(address.FieldLine2) {
		fields = append(fields, address.FieldLine2)
	}
	if m.FieldCleared(address.FieldStateOrProvince) {
		fields = append(fields, address.FieldStateOrProvince)
	}
	if m.FieldCleared(address.FieldOtherAddressDetails) {
		fields = append(fields, address.FieldOtherAddressDetails)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AddressMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AddressMutation) ClearField(name string) error {
	switch name {
	case address.FieldLine2:
		m.ClearLine2()
		return nil
	case address.FieldStateOrProvince:
		m.ClearStateOrProvince()
		return nil
	case address.FieldOtherAddressDetails:
		m.ClearOtherAddressDetails()
		return nil
	}
	return fmt.Errorf("unknown Address nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AddressMutation) ResetField(name string) error {
	switch name {
	case address.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case address.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case address.FieldLine1:
		m.ResetLine1()
		return nil
	case address.FieldLine2:
		m.ResetLine2()
		return nil
	case address.FieldCity:
		m.ResetCity()
		return nil
	case address.FieldStateOrProvince:
		m.ResetStateOrProvince()
		return nil
	case address.FieldZipOrPostcode:
		m.ResetZipOrPostcode()
		return nil
	case address.FieldCountry:
		m.ResetCountry()
		return nil
	case address.FieldOtherAddressDetails:
		m.ResetOtherAddressDetails()
		return nil
	}
	return fmt.Errorf("unknown Address field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AddressMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.persons != nil {
		edges = append(edges, address.EdgePersons)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AddressMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case address.EdgePersons:
		ids := make([]ent.Value, 0, len(m.persons))
		for id := range m.persons {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AddressMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedpersons != nil {
		edges = append(edges, address.EdgePersons)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AddressMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case address.EdgePersons:
		ids := make([]ent.Value, 0, len(m.removedpersons))
		for id := range m.removedpersons {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AddressMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpersons {
		edges = append(edges, address.EdgePersons)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AddressMutation) EdgeCleared(name string) bool {
	switch name {
	case address.EdgePersons:
		return m.clearedpersons
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AddressMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Address unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AddressMutation) ResetEdge(name string) error {
	switch name {
	case address.EdgePersons:
		m.ResetPersons()
		return nil
	}
	return fmt.Errorf("unknown Address edge %s", name)
}

// ConversationMutation represents an operation that mutates the Conversation nodes in the graph.
type ConversationMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	created_at        *time.Time
	updated_at        *time.Time
	title             *string
	clearedFields     map[string]struct{}
	person_one        *uuid.UUID
	clearedperson_one bool
	person_two        *uuid.UUID
	clearedperson_two bool
	done              bool
	oldValue          func(context.Context) (*Conversation, error)
	predicates        []predicate.Conversation
}

var _ ent.Mutation = (*ConversationMutation)(nil)

// conversationOption allows management of the mutation configuration using functional options.
type conversationOption func(*ConversationMutation)

// newConversationMutation creates new mutation for the Conversation entity.
func newConversationMutation(c config, op Op, opts ...conversationOption) *ConversationMutation {
	m := &ConversationMutation{
		config:        c,
		op:            op,
		typ:           TypeConversation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConversationID sets the ID field of the mutation.
func withConversationID(id uuid.UUID) conversationOption {
	return func(m *ConversationMutation) {
		var (
			err   error
			once  sync.Once
			value *Conversation
		)
		m.oldValue = func(ctx context.Context) (*Conversation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Conversation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConversation sets the old Conversation of the mutation.
func withConversation(node *Conversation) conversationOption {
	return func(m *ConversationMutation) {
		m.oldValue = func(context.Context) (*Conversation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConversationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConversationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Conversation entities.
func (m *ConversationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ConversationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ConversationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Conversation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ConversationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ConversationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Conversation entity.
// If the Conversation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConversationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ConversationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ConversationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ConversationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Conversation entity.
// If the Conversation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConversationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ConversationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTitle sets the "title" field.
func (m *ConversationMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ConversationMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Conversation entity.
// If the Conversation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConversationMutation) OldTitle(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *ConversationMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[conversation.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *ConversationMutation) TitleCleared() bool {
	_, ok := m.clearedFields[conversation.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *ConversationMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, conversation.FieldTitle)
}

// SetPersonOneID sets the "person_one_id" field.
func (m *ConversationMutation) SetPersonOneID(u uuid.UUID) {
	m.person_one = &u
}

// PersonOneID returns the value of the "person_one_id" field in the mutation.
func (m *ConversationMutation) PersonOneID() (r uuid.UUID, exists bool) {
	v := m.person_one
	if v == nil {
		return
	}
	return *v, true
}

// OldPersonOneID returns the old "person_one_id" field's value of the Conversation entity.
// If the Conversation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConversationMutation) OldPersonOneID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPersonOneID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPersonOneID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPersonOneID: %w", err)
	}
	return oldValue.PersonOneID, nil
}

// ResetPersonOneID resets all changes to the "person_one_id" field.
func (m *ConversationMutation) ResetPersonOneID() {
	m.person_one = nil
}

// SetPersonTwoID sets the "person_two_id" field.
func (m *ConversationMutation) SetPersonTwoID(u uuid.UUID) {
	m.person_two = &u
}

// PersonTwoID returns the value of the "person_two_id" field in the mutation.
func (m *ConversationMutation) PersonTwoID() (r uuid.UUID, exists bool) {
	v := m.person_two
	if v == nil {
		return
	}
	return *v, true
}

// OldPersonTwoID returns the old "person_two_id" field's value of the Conversation entity.
// If the Conversation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConversationMutation) OldPersonTwoID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPersonTwoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPersonTwoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPersonTwoID: %w", err)
	}
	return oldValue.PersonTwoID, nil
}

// ResetPersonTwoID resets all changes to the "person_two_id" field.
func (m *ConversationMutation) ResetPersonTwoID() {
	m.person_two = nil
}

// ClearPersonOne clears the "person_one" edge to the Person entity.
func (m *ConversationMutation) ClearPersonOne() {
	m.clearedperson_one = true
	m.clearedFields[conversation.FieldPersonOneID] = struct{}{}
}

// PersonOneCleared reports if the "person_one" edge to the Person entity was cleared.
func (m *ConversationMutation) PersonOneCleared() bool {
	return m.clearedperson_one
}

// PersonOneIDs returns the "person_one" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PersonOneID instead. It exists only for internal usage by the builders.
func (m *ConversationMutation) PersonOneIDs() (ids []uuid.UUID) {
	if id := m.person_one; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPersonOne resets all changes to the "person_one" edge.
func (m *ConversationMutation) ResetPersonOne() {
	m.person_one = nil
	m.clearedperson_one = false
}

// ClearPersonTwo clears the "person_two" edge to the Person entity.
func (m *ConversationMutation) ClearPersonTwo() {
	m.clearedperson_two = true
	m.clearedFields[conversation.FieldPersonTwoID] = struct{}{}
}

// PersonTwoCleared reports if the "person_two" edge to the Person entity was cleared.
func (m *ConversationMutation) PersonTwoCleared() bool {
	return m.clearedperson_two
}

// PersonTwoIDs returns the "person_two" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PersonTwoID instead. It exists only for internal usage by the builders.
func (m *ConversationMutation) PersonTwoIDs() (ids []uuid.UUID) {
	if id := m.person_two; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPersonTwo resets all changes to the "person_two" edge.
func (m *ConversationMutation) ResetPersonTwo() {
	m.person_two = nil
	m.clearedperson_two = false
}

// Where appends a list predicates to the ConversationMutation builder.
func (m *ConversationMutation) Where(ps ...predicate.Conversation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ConversationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ConversationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Conversation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ConversationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ConversationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Conversation).
func (m *ConversationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ConversationMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, conversation.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, conversation.FieldUpdatedAt)
	}
	if m.title != nil {
		fields = append(fields, conversation.FieldTitle)
	}
	if m.person_one != nil {
		fields = append(fields, conversation.FieldPersonOneID)
	}
	if m.person_two != nil {
		fields = append(fields, conversation.FieldPersonTwoID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ConversationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case conversation.FieldCreatedAt:
		return m.CreatedAt()
	case conversation.FieldUpdatedAt:
		return m.UpdatedAt()
	case conversation.FieldTitle:
		return m.Title()
	case conversation.FieldPersonOneID:
		return m.PersonOneID()
	case conversation.FieldPersonTwoID:
		return m.PersonTwoID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ConversationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case conversation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case conversation.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case conversation.FieldTitle:
		return m.OldTitle(ctx)
	case conversation.FieldPersonOneID:
		return m.OldPersonOneID(ctx)
	case conversation.FieldPersonTwoID:
		return m.OldPersonTwoID(ctx)
	}
	return nil, fmt.Errorf("unknown Conversation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConversationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case conversation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case conversation.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case conversation.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case conversation.FieldPersonOneID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPersonOneID(v)
		return nil
	case conversation.FieldPersonTwoID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPersonTwoID(v)
		return nil
	}
	return fmt.Errorf("unknown Conversation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ConversationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ConversationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConversationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Conversation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ConversationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(conversation.FieldTitle) {
		fields = append(fields, conversation.FieldTitle)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ConversationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConversationMutation) ClearField(name string) error {
	switch name {
	case conversation.FieldTitle:
		m.ClearTitle()
		return nil
	}
	return fmt.Errorf("unknown Conversation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ConversationMutation) ResetField(name string) error {
	switch name {
	case conversation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case conversation.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case conversation.FieldTitle:
		m.ResetTitle()
		return nil
	case conversation.FieldPersonOneID:
		m.ResetPersonOneID()
		return nil
	case conversation.FieldPersonTwoID:
		m.ResetPersonTwoID()
		return nil
	}
	return fmt.Errorf("unknown Conversation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ConversationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.person_one != nil {
		edges = append(edges, conversation.EdgePersonOne)
	}
	if m.person_two != nil {
		edges = append(edges, conversation.EdgePersonTwo)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ConversationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case conversation.EdgePersonOne:
		if id := m.person_one; id != nil {
			return []ent.Value{*id}
		}
	case conversation.EdgePersonTwo:
		if id := m.person_two; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ConversationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ConversationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ConversationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedperson_one {
		edges = append(edges, conversation.EdgePersonOne)
	}
	if m.clearedperson_two {
		edges = append(edges, conversation.EdgePersonTwo)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ConversationMutation) EdgeCleared(name string) bool {
	switch name {
	case conversation.EdgePersonOne:
		return m.clearedperson_one
	case conversation.EdgePersonTwo:
		return m.clearedperson_two
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ConversationMutation) ClearEdge(name string) error {
	switch name {
	case conversation.EdgePersonOne:
		m.ClearPersonOne()
		return nil
	case conversation.EdgePersonTwo:
		m.ClearPersonTwo()
		return nil
	}
	return fmt.Errorf("unknown Conversation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ConversationMutation) ResetEdge(name string) error {
	switch name {
	case conversation.EdgePersonOne:
		m.ResetPersonOne()
		return nil
	case conversation.EdgePersonTwo:
		m.ResetPersonTwo()
		return nil
	}
	return fmt.Errorf("unknown Conversation edge %s", name)
}

// DeliveryAssignmentMutation represents an operation that mutates the DeliveryAssignment nodes in the graph.
type DeliveryAssignmentMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	created_at      *time.Time
	updated_at      *time.Time
	status          *deliveryassignment.Status
	note            *string
	clearedFields   map[string]struct{}
	shipment        *uuid.UUID
	clearedshipment bool
	staff           *uuid.UUID
	clearedstaff    bool
	done            bool
	oldValue        func(context.Context) (*DeliveryAssignment, error)
	predicates      []predicate.DeliveryAssignment
}

var _ ent.Mutation = (*DeliveryAssignmentMutation)(nil)

// deliveryassignmentOption allows management of the mutation configuration using functional options.
type deliveryassignmentOption func(*DeliveryAssignmentMutation)

// newDeliveryAssignmentMutation creates new mutation for the DeliveryAssignment entity.
func newDeliveryAssignmentMutation(c config, op Op, opts ...deliveryassignmentOption) *DeliveryAssignmentMutation {
	m := &DeliveryAssignmentMutation{
		config:        c,
		op:            op,
		typ:           TypeDeliveryAssignment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeliveryAssignmentID sets the ID field of the mutation.
func withDeliveryAssignmentID(id uuid.UUID) deliveryassignmentOption {
	return func(m *DeliveryAssignmentMutation) {
		var (
			err   error
			once  sync.Once
			value *DeliveryAssignment
		)
		m.oldValue = func(ctx context.Context) (*DeliveryAssignment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeliveryAssignment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeliveryAssignment sets the old DeliveryAssignment of the mutation.
func withDeliveryAssignment(node *DeliveryAssignment) deliveryassignmentOption {
	return func(m *DeliveryAssignmentMutation) {
		m.oldValue = func(context.Context) (*DeliveryAssignment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeliveryAssignmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeliveryAssignmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DeliveryAssignment entities.
func (m *DeliveryAssignmentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeliveryAssignmentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeliveryAssignmentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DeliveryAssignment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DeliveryAssignmentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DeliveryAssignmentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DeliveryAssignment entity.
// If the DeliveryAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliveryAssignmentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DeliveryAssignmentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DeliveryAssignmentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DeliveryAssignmentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DeliveryAssignment entity.
// If the DeliveryAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliveryAssignmentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DeliveryAssignmentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetShipmentID sets the "shipment_id" field.
func (m *DeliveryAssignmentMutation) SetShipmentID(u uuid.UUID) {
	m.shipment = &u
}

// ShipmentID returns the value of the "shipment_id" field in the mutation.
func (m *DeliveryAssignmentMutation) ShipmentID() (r uuid.UUID, exists bool) {
	v := m.shipment
	if v == nil {
		return
	}
	return *v, true
}

// OldShipmentID returns the old "shipment_id" field's value of the DeliveryAssignment entity.
// If the DeliveryAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliveryAssignmentMutation) OldShipmentID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShipmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShipmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShipmentID: %w", err)
	}
	return oldValue.ShipmentID, nil
}

// ResetShipmentID resets all changes to the "shipment_id" field.
func (m *DeliveryAssignmentMutation) ResetShipmentID() {
	m.shipment = nil
}

// SetStaffID sets the "staff_id" field.
func (m *DeliveryAssignmentMutation) SetStaffID(u uuid.UUID) {
	m.staff = &u
}

// StaffID returns the value of the "staff_id" field in the mutation.
func (m *DeliveryAssignmentMutation) StaffID() (r uuid.UUID, exists bool) {
	v := m.staff
	if v == nil {
		return
	}
	return *v, true
}

// OldStaffID returns the old "staff_id" field's value of the DeliveryAssignment entity.
// If the DeliveryAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliveryAssignmentMutation) OldStaffID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStaffID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStaffID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStaffID: %w", err)
	}
	return oldValue.StaffID, nil
}

// ResetStaffID resets all changes to the "staff_id" field.
func (m *DeliveryAssignmentMutation) ResetStaffID() {
	m.staff = nil
}

// SetStatus sets the "status" field.
func (m *DeliveryAssignmentMutation) SetStatus(d deliveryassignment.Status) {
	m.status = &d
}

// Status returns the value of the "status" field in the mutation.
func (m *DeliveryAssignmentMutation) Status() (r deliveryassignment.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the DeliveryAssignment entity.
// If the DeliveryAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliveryAssignmentMutation) OldStatus(ctx context.Context) (v deliveryassignment.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *DeliveryAssignmentMutation) ResetStatus() {
	m.status = nil
}

// SetNote sets the "note" field.
func (m *DeliveryAssignmentMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the value of the "note" field in the mutation.
func (m *DeliveryAssignmentMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "note" field's value of the DeliveryAssignment entity.
// If the DeliveryAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliveryAssignmentMutation) OldNote(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ClearNote clears the value of the "note" field.
func (m *DeliveryAssignmentMutation) ClearNote() {
	m.note = nil
	m.clearedFields[deliveryassignment.FieldNote] = struct{}{}
}

// NoteCleared returns if the "note" field was cleared in this mutation.
func (m *DeliveryAssignmentMutation) NoteCleared() bool {
	_, ok := m.clearedFields[deliveryassignment.FieldNote]
	return ok
}

// ResetNote resets all changes to the "note" field.
func (m *DeliveryAssignmentMutation) ResetNote() {
	m.note = nil
	delete(m.clearedFields, deliveryassignment.FieldNote)
}

// ClearShipment clears the "shipment" edge to the Shipment entity.
func (m *DeliveryAssignmentMutation) ClearShipment() {
	m.clearedshipment = true
	m.clearedFields[deliveryassignment.FieldShipmentID] = struct{}{}
}

// ShipmentCleared reports if the "shipment" edge to the Shipment entity was cleared.
func (m *DeliveryAssignmentMutation) ShipmentCleared() bool {
	return m.clearedshipment
}

// ShipmentIDs returns the "shipment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ShipmentID instead. It exists only for internal usage by the builders.
func (m *DeliveryAssignmentMutation) ShipmentIDs() (ids []uuid.UUID) {
	if id := m.shipment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetShipment resets all changes to the "shipment" edge.
func (m *DeliveryAssignmentMutation) ResetShipment() {
	m.shipment = nil
	m.clearedshipment = false
}

// ClearStaff clears the "staff" edge to the Person entity.
func (m *DeliveryAssignmentMutation) ClearStaff() {
	m.clearedstaff = true
	m.clearedFields[deliveryassignment.FieldStaffID] = struct{}{}
}

// StaffCleared reports if the "staff" edge to the Person entity was cleared.
func (m *DeliveryAssignmentMutation) StaffCleared() bool {
	return m.clearedstaff
}

// StaffIDs returns the "staff" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StaffID instead. It exists only for internal usage by the builders.
func (m *DeliveryAssignmentMutation) StaffIDs() (ids []uuid.UUID) {
	if id := m.staff; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStaff resets all changes to the "staff" edge.
func (m *DeliveryAssignmentMutation) ResetStaff() {
	m.staff = nil
	m.clearedstaff = false
}

// Where appends a list predicates to the DeliveryAssignmentMutation builder.
func (m *DeliveryAssignmentMutation) Where(ps ...predicate.DeliveryAssignment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeliveryAssignmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeliveryAssignmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DeliveryAssignment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeliveryAssignmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeliveryAssignmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DeliveryAssignment).
func (m *DeliveryAssignmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeliveryAssignmentMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, deliveryassignment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, deliveryassignment.FieldUpdatedAt)
	}
	if m.shipment != nil {
		fields = append(fields, deliveryassignment.FieldShipmentID)
	}
	if m.staff != nil {
		fields = append(fields, deliveryassignment.FieldStaffID)
	}
	if m.status != nil {
		fields = append(fields, deliveryassignment.FieldStatus)
	}
	if m.note != nil {
		fields = append(fields, deliveryassignment.FieldNote)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeliveryAssignmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case deliveryassignment.FieldCreatedAt:
		return m.CreatedAt()
	case deliveryassignment.FieldUpdatedAt:
		return m.UpdatedAt()
	case deliveryassignment.FieldShipmentID:
		return m.ShipmentID()
	case deliveryassignment.FieldStaffID:
		return m.StaffID()
	case deliveryassignment.FieldStatus:
		return m.Status()
	case deliveryassignment.FieldNote:
		return m.Note()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeliveryAssignmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case deliveryassignment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case deliveryassignment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case deliveryassignment.FieldShipmentID:
		return m.OldShipmentID(ctx)
	case deliveryassignment.FieldStaffID:
		return m.OldStaffID(ctx)
	case deliveryassignment.FieldStatus:
		return m.OldStatus(ctx)
	case deliveryassignment.FieldNote:
		return m.OldNote(ctx)
	}
	return nil, fmt.Errorf("unknown DeliveryAssignment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeliveryAssignmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case deliveryassignment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case deliveryassignment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case deliveryassignment.FieldShipmentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShipmentID(v)
		return nil
	case deliveryassignment.FieldStaffID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStaffID(v)
		return nil
	case deliveryassignment.FieldStatus:
		v, ok := value.(deliveryassignment.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case deliveryassignment.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	}
	return fmt.Errorf("unknown DeliveryAssignment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeliveryAssignmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeliveryAssignmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeliveryAssignmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DeliveryAssignment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeliveryAssignmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(deliveryassignment.FieldNote) {
		fields = append(fields, deliveryassignment.FieldNote)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeliveryAssignmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeliveryAssignmentMutation) ClearField(name string) error {
	switch name {
	case deliveryassignment.FieldNote:
		m.ClearNote()
		return nil
	}
	return fmt.Errorf("unknown DeliveryAssignment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeliveryAssignmentMutation) ResetField(name string) error {
	switch name {
	case deliveryassignment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case deliveryassignment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case deliveryassignment.FieldShipmentID:
		m.ResetShipmentID()
		return nil
	case deliveryassignment.FieldStaffID:
		m.ResetStaffID()
		return nil
	case deliveryassignment.FieldStatus:
		m.ResetStatus()
		return nil
	case deliveryassignment.FieldNote:
		m.ResetNote()
		return nil
	}
	return fmt.Errorf("unknown DeliveryAssignment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeliveryAssignmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.shipment != nil {
		edges = append(edges, deliveryassignment.EdgeShipment)
	}
	if m.staff != nil {
		edges = append(edges, deliveryassignment.EdgeStaff)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeliveryAssignmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case deliveryassignment.EdgeShipment:
		if id := m.shipment; id != nil {
			return []ent.Value{*id}
		}
	case deliveryassignment.EdgeStaff:
		if id := m.staff; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeliveryAssignmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeliveryAssignmentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeliveryAssignmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedshipment {
		edges = append(edges, deliveryassignment.EdgeShipment)
	}
	if m.clearedstaff {
		edges = append(edges, deliveryassignment.EdgeStaff)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeliveryAssignmentMutation) EdgeCleared(name string) bool {
	switch name {
	case deliveryassignment.EdgeShipment:
		return m.clearedshipment
	case deliveryassignment.EdgeStaff:
		return m.clearedstaff
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeliveryAssignmentMutation) ClearEdge(name string) error {
	switch name {
	case deliveryassignment.EdgeShipment:
		m.ClearShipment()
		return nil
	case deliveryassignment.EdgeStaff:
		m.ClearStaff()
		return nil
	}
	return fmt.Errorf("unknown DeliveryAssignment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeliveryAssignmentMutation) ResetEdge(name string) error {
	switch name {
	case deliveryassignment.EdgeShipment:
		m.ResetShipment()
		return nil
	case deliveryassignment.EdgeStaff:
		m.ResetStaff()
		return nil
	}
	return fmt.Errorf("unknown DeliveryAssignment edge %s", name)
}

// InvoiceMutation represents an operation that mutates the Invoice nodes in the graph.
type InvoiceMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	created_at     *time.Time
	updated_at     *time.Time
	total          *decimal.Decimal
	addtotal       *decimal.Decimal
	note           *string
	_type          *invoice.Type
	status         *invoice.Status
	payment_method *invoice.PaymentMethod
	clearedFields  map[string]struct{}
	_order         *uuid.UUID
	cleared_order  bool
	done           bool
	oldValue       func(context.Context) (*Invoice, error)
	predicates     []predicate.Invoice
}

var _ ent.Mutation = (*InvoiceMutation)(nil)

// invoiceOption allows management of the mutation configuration using functional options.
type invoiceOption func(*InvoiceMutation)

// newInvoiceMutation creates new mutation for the Invoice entity.
func newInvoiceMutation(c config, op Op, opts ...invoiceOption) *InvoiceMutation {
	m := &InvoiceMutation{
		config:        c,
		op:            op,
		typ:           TypeInvoice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInvoiceID sets the ID field of the mutation.
func withInvoiceID(id uuid.UUID) invoiceOption {
	return func(m *InvoiceMutation) {
		var (
			err   error
			once  sync.Once
			value *Invoice
		)
		m.oldValue = func(ctx context.Context) (*Invoice, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Invoice.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInvoice sets the old Invoice of the mutation.
func withInvoice(node *Invoice) invoiceOption {
	return func(m *InvoiceMutation) {
		m.oldValue = func(context.Context) (*Invoice, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InvoiceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InvoiceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Invoice entities.
func (m *InvoiceMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InvoiceMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InvoiceMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Invoice.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *InvoiceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InvoiceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InvoiceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *InvoiceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *InvoiceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *InvoiceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetOrderID sets the "order_id" field.
func (m *InvoiceMutation) SetOrderID(u uuid.UUID) {
	m._order = &u
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *InvoiceMutation) OrderID() (r uuid.UUID, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldOrderID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *InvoiceMutation) ResetOrderID() {
	m._order = nil
}

// SetTotal sets the "total" field.
func (m *InvoiceMutation) SetTotal(d decimal.Decimal) {
	m.total = &d
	m.addtotal = nil
}

// Total returns the value of the "total" field in the mutation.
func (m *InvoiceMutation) Total() (r decimal.Decimal, exists bool) {
	v := m.total
	if v == nil {
		return
	}
	return *v, true
}

// OldTotal returns the old "total" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldTotal(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotal: %w", err)
	}
	return oldValue.Total, nil
}

// AddTotal adds d to the "total" field.
func (m *InvoiceMutation) AddTotal(d decimal.Decimal) {
	if m.addtotal != nil {
		*m.addtotal = m.addtotal.Add(d)
	} else {
		m.addtotal = &d
	}
}

// AddedTotal returns the value that was added to the "total" field in this mutation.
func (m *InvoiceMutation) AddedTotal() (r decimal.Decimal, exists bool) {
	v := m.addtotal
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotal resets all changes to the "total" field.
func (m *InvoiceMutation) ResetTotal() {
	m.total = nil
	m.addtotal = nil
}

// SetNote sets the "note" field.
func (m *InvoiceMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the value of the "note" field in the mutation.
func (m *InvoiceMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "note" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldNote(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ClearNote clears the value of the "note" field.
func (m *InvoiceMutation) ClearNote() {
	m.note = nil
	m.clearedFields[invoice.FieldNote] = struct{}{}
}

// NoteCleared returns if the "note" field was cleared in this mutation.
func (m *InvoiceMutation) NoteCleared() bool {
	_, ok := m.clearedFields[invoice.FieldNote]
	return ok
}

// ResetNote resets all changes to the "note" field.
func (m *InvoiceMutation) ResetNote() {
	m.note = nil
	delete(m.clearedFields, invoice.FieldNote)
}

// SetType sets the "type" field.
func (m *InvoiceMutation) SetType(i invoice.Type) {
	m._type = &i
}

// GetType returns the value of the "type" field in the mutation.
func (m *InvoiceMutation) GetType() (r invoice.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldType(ctx context.Context) (v invoice.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *InvoiceMutation) ResetType() {
	m._type = nil
}

// SetStatus sets the "status" field.
func (m *InvoiceMutation) SetStatus(i invoice.Status) {
	m.status = &i
}

// Status returns the value of the "status" field in the mutation.
func (m *InvoiceMutation) Status() (r invoice.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldStatus(ctx context.Context) (v invoice.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *InvoiceMutation) ResetStatus() {
	m.status = nil
}

// SetPaymentMethod sets the "payment_method" field.
func (m *InvoiceMutation) SetPaymentMethod(im invoice.PaymentMethod) {
	m.payment_method = &im
}

// PaymentMethod returns the value of the "payment_method" field in the mutation.
func (m *InvoiceMutation) PaymentMethod() (r invoice.PaymentMethod, exists bool) {
	v := m.payment_method
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentMethod returns the old "payment_method" field's value of the Invoice entity.
// If the Invoice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceMutation) OldPaymentMethod(ctx context.Context) (v *invoice.PaymentMethod, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentMethod: %w", err)
	}
	return oldValue.PaymentMethod, nil
}

// ClearPaymentMethod clears the value of the "payment_method" field.
func (m *InvoiceMutation) ClearPaymentMethod() {
	m.payment_method = nil
	m.clearedFields[invoice.FieldPaymentMethod] = struct{}{}
}

// PaymentMethodCleared returns if the "payment_method" field was cleared in this mutation.
func (m *InvoiceMutation) PaymentMethodCleared() bool {
	_, ok := m.clearedFields[invoice.FieldPaymentMethod]
	return ok
}

// ResetPaymentMethod resets all changes to the "payment_method" field.
func (m *InvoiceMutation) ResetPaymentMethod() {
	m.payment_method = nil
	delete(m.clearedFields, invoice.FieldPaymentMethod)
}

// ClearOrder clears the "order" edge to the Order entity.
func (m *InvoiceMutation) ClearOrder() {
	m.cleared_order = true
	m.clearedFields[invoice.FieldOrderID] = struct{}{}
}

// OrderCleared reports if the "order" edge to the Order entity was cleared.
func (m *InvoiceMutation) OrderCleared() bool {
	return m.cleared_order
}

// OrderIDs returns the "order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderID instead. It exists only for internal usage by the builders.
func (m *InvoiceMutation) OrderIDs() (ids []uuid.UUID) {
	if id := m._order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrder resets all changes to the "order" edge.
func (m *InvoiceMutation) ResetOrder() {
	m._order = nil
	m.cleared_order = false
}

// Where appends a list predicates to the InvoiceMutation builder.
func (m *InvoiceMutation) Where(ps ...predicate.Invoice) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InvoiceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InvoiceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Invoice, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InvoiceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InvoiceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Invoice).
func (m *InvoiceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InvoiceMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, invoice.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, invoice.FieldUpdatedAt)
	}
	if m._order != nil {
		fields = append(fields, invoice.FieldOrderID)
	}
	if m.total != nil {
		fields = append(fields, invoice.FieldTotal)
	}
	if m.note != nil {
		fields = append(fields, invoice.FieldNote)
	}
	if m._type != nil {
		fields = append(fields, invoice.FieldType)
	}
	if m.status != nil {
		fields = append(fields, invoice.FieldStatus)
	}
	if m.payment_method != nil {
		fields = append(fields, invoice.FieldPaymentMethod)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InvoiceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case invoice.FieldCreatedAt:
		return m.CreatedAt()
	case invoice.FieldUpdatedAt:
		return m.UpdatedAt()
	case invoice.FieldOrderID:
		return m.OrderID()
	case invoice.FieldTotal:
		return m.Total()
	case invoice.FieldNote:
		return m.Note()
	case invoice.FieldType:
		return m.GetType()
	case invoice.FieldStatus:
		return m.Status()
	case invoice.FieldPaymentMethod:
		return m.PaymentMethod()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InvoiceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case invoice.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case invoice.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case invoice.FieldOrderID:
		return m.OldOrderID(ctx)
	case invoice.FieldTotal:
		return m.OldTotal(ctx)
	case invoice.FieldNote:
		return m.OldNote(ctx)
	case invoice.FieldType:
		return m.OldType(ctx)
	case invoice.FieldStatus:
		return m.OldStatus(ctx)
	case invoice.FieldPaymentMethod:
		return m.OldPaymentMethod(ctx)
	}
	return nil, fmt.Errorf("unknown Invoice field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvoiceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case invoice.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case invoice.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case invoice.FieldOrderID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case invoice.FieldTotal:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotal(v)
		return nil
	case invoice.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	case invoice.FieldType:
		v, ok := value.(invoice.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case invoice.FieldStatus:
		v, ok := value.(invoice.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case invoice.FieldPaymentMethod:
		v, ok := value.(invoice.PaymentMethod)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentMethod(v)
		return nil
	}
	return fmt.Errorf("unknown Invoice field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InvoiceMutation) AddedFields() []string {
	var fields []string
	if m.addtotal != nil {
		fields = append(fields, invoice.FieldTotal)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InvoiceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case invoice.FieldTotal:
		return m.AddedTotal()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvoiceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case invoice.FieldTotal:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotal(v)
		return nil
	}
	return fmt.Errorf("unknown Invoice numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InvoiceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(invoice.FieldNote) {
		fields = append(fields, invoice.FieldNote)
	}
	if m.FieldCleared(invoice.FieldPaymentMethod) {
		fields = append(fields, invoice.FieldPaymentMethod)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InvoiceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InvoiceMutation) ClearField(name string) error {
	switch name {
	case invoice.FieldNote:
		m.ClearNote()
		return nil
	case invoice.FieldPaymentMethod:
		m.ClearPaymentMethod()
		return nil
	}
	return fmt.Errorf("unknown Invoice nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InvoiceMutation) ResetField(name string) error {
	switch name {
	case invoice.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case invoice.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case invoice.FieldOrderID:
		m.ResetOrderID()
		return nil
	case invoice.FieldTotal:
		m.ResetTotal()
		return nil
	case invoice.FieldNote:
		m.ResetNote()
		return nil
	case invoice.FieldType:
		m.ResetType()
		return nil
	case invoice.FieldStatus:
		m.ResetStatus()
		return nil
	case invoice.FieldPaymentMethod:
		m.ResetPaymentMethod()
		return nil
	}
	return fmt.Errorf("unknown Invoice field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InvoiceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._order != nil {
		edges = append(edges, invoice.EdgeOrder)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InvoiceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case invoice.EdgeOrder:
		if id := m._order; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InvoiceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InvoiceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InvoiceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_order {
		edges = append(edges, invoice.EdgeOrder)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InvoiceMutation) EdgeCleared(name string) bool {
	switch name {
	case invoice.EdgeOrder:
		return m.cleared_order
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InvoiceMutation) ClearEdge(name string) error {
	switch name {
	case invoice.EdgeOrder:
		m.ClearOrder()
		return nil
	}
	return fmt.Errorf("unknown Invoice unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InvoiceMutation) ResetEdge(name string) error {
	switch name {
	case invoice.EdgeOrder:
		m.ResetOrder()
		return nil
	}
	return fmt.Errorf("unknown Invoice edge %s", name)
}

// MessageMutation represents an operation that mutates the Message nodes in the graph.
type MessageMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	created_at          *time.Time
	updated_at          *time.Time
	_type               *message.Type
	content             *string
	is_read             *bool
	clearedFields       map[string]struct{}
	conversation        *uuid.UUID
	clearedconversation bool
	sender              *uuid.UUID
	clearedsender       bool
	done                bool
	oldValue            func(context.Context) (*Message, error)
	predicates          []predicate.Message
}

var _ ent.Mutation = (*MessageMutation)(nil)

// messageOption allows management of the mutation configuration using functional options.
type messageOption func(*MessageMutation)

// newMessageMutation creates new mutation for the Message entity.
func newMessageMutation(c config, op Op, opts ...messageOption) *MessageMutation {
	m := &MessageMutation{
		config:        c,
		op:            op,
		typ:           TypeMessage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMessageID sets the ID field of the mutation.
func withMessageID(id uuid.UUID) messageOption {
	return func(m *MessageMutation) {
		var (
			err   error
			once  sync.Once
			value *Message
		)
		m.oldValue = func(ctx context.Context) (*Message, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Message.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMessage sets the old Message of the mutation.
func withMessage(node *Message) messageOption {
	return func(m *MessageMutation) {
		m.oldValue = func(context.Context) (*Message, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MessageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MessageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Message entities.
func (m *MessageMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MessageMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MessageMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Message.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MessageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MessageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MessageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MessageMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MessageMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MessageMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetConversationID sets the "conversation_id" field.
func (m *MessageMutation) SetConversationID(u uuid.UUID) {
	m.conversation = &u
}

// ConversationID returns the value of the "conversation_id" field in the mutation.
func (m *MessageMutation) ConversationID() (r uuid.UUID, exists bool) {
	v := m.conversation
	if v == nil {
		return
	}
	return *v, true
}

// OldConversationID returns the old "conversation_id" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldConversationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConversationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConversationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConversationID: %w", err)
	}
	return oldValue.ConversationID, nil
}

// ResetConversationID resets all changes to the "conversation_id" field.
func (m *MessageMutation) ResetConversationID() {
	m.conversation = nil
}

// SetSenderID sets the "sender_id" field.
func (m *MessageMutation) SetSenderID(u uuid.UUID) {
	m.sender = &u
}

// SenderID returns the value of the "sender_id" field in the mutation.
func (m *MessageMutation) SenderID() (r uuid.UUID, exists bool) {
	v := m.sender
	if v == nil {
		return
	}
	return *v, true
}

// OldSenderID returns the old "sender_id" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldSenderID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSenderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSenderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSenderID: %w", err)
	}
	return oldValue.SenderID, nil
}

// ResetSenderID resets all changes to the "sender_id" field.
func (m *MessageMutation) ResetSenderID() {
	m.sender = nil
}

// SetType sets the "type" field.
func (m *MessageMutation) SetType(value message.Type) {
	m._type = &value
}

// GetType returns the value of the "type" field in the mutation.
func (m *MessageMutation) GetType() (r message.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldType(ctx context.Context) (v message.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *MessageMutation) ResetType() {
	m._type = nil
}

// SetContent sets the "content" field.
func (m *MessageMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *MessageMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *MessageMutation) ResetContent() {
	m.content = nil
}

// SetIsRead sets the "is_read" field.
func (m *MessageMutation) SetIsRead(b bool) {
	m.is_read = &b
}

// IsRead returns the value of the "is_read" field in the mutation.
func (m *MessageMutation) IsRead() (r bool, exists bool) {
	v := m.is_read
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRead returns the old "is_read" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldIsRead(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsRead is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsRead requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRead: %w", err)
	}
	return oldValue.IsRead, nil
}

// ResetIsRead resets all changes to the "is_read" field.
func (m *MessageMutation) ResetIsRead() {
	m.is_read = nil
}

// ClearConversation clears the "conversation" edge to the Conversation entity.
func (m *MessageMutation) ClearConversation() {
	m.clearedconversation = true
	m.clearedFields[message.FieldConversationID] = struct{}{}
}

// ConversationCleared reports if the "conversation" edge to the Conversation entity was cleared.
func (m *MessageMutation) ConversationCleared() bool {
	return m.clearedconversation
}

// ConversationIDs returns the "conversation" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ConversationID instead. It exists only for internal usage by the builders.
func (m *MessageMutation) ConversationIDs() (ids []uuid.UUID) {
	if id := m.conversation; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConversation resets all changes to the "conversation" edge.
func (m *MessageMutation) ResetConversation() {
	m.conversation = nil
	m.clearedconversation = false
}

// ClearSender clears the "sender" edge to the Person entity.
func (m *MessageMutation) ClearSender() {
	m.clearedsender = true
	m.clearedFields[message.FieldSenderID] = struct{}{}
}

// SenderCleared reports if the "sender" edge to the Person entity was cleared.
func (m *MessageMutation) SenderCleared() bool {
	return m.clearedsender
}

// SenderIDs returns the "sender" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SenderID instead. It exists only for internal usage by the builders.
func (m *MessageMutation) SenderIDs() (ids []uuid.UUID) {
	if id := m.sender; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSender resets all changes to the "sender" edge.
func (m *MessageMutation) ResetSender() {
	m.sender = nil
	m.clearedsender = false
}

// Where appends a list predicates to the MessageMutation builder.
func (m *MessageMutation) Where(ps ...predicate.Message) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MessageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MessageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Message, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MessageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MessageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Message).
func (m *MessageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MessageMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, message.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, message.FieldUpdatedAt)
	}
	if m.conversation != nil {
		fields = append(fields, message.FieldConversationID)
	}
	if m.sender != nil {
		fields = append(fields, message.FieldSenderID)
	}
	if m._type != nil {
		fields = append(fields, message.FieldType)
	}
	if m.content != nil {
		fields = append(fields, message.FieldContent)
	}
	if m.is_read != nil {
		fields = append(fields, message.FieldIsRead)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MessageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case message.FieldCreatedAt:
		return m.CreatedAt()
	case message.FieldUpdatedAt:
		return m.UpdatedAt()
	case message.FieldConversationID:
		return m.ConversationID()
	case message.FieldSenderID:
		return m.SenderID()
	case message.FieldType:
		return m.GetType()
	case message.FieldContent:
		return m.Content()
	case message.FieldIsRead:
		return m.IsRead()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MessageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case message.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case message.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case message.FieldConversationID:
		return m.OldConversationID(ctx)
	case message.FieldSenderID:
		return m.OldSenderID(ctx)
	case message.FieldType:
		return m.OldType(ctx)
	case message.FieldContent:
		return m.OldContent(ctx)
	case message.FieldIsRead:
		return m.OldIsRead(ctx)
	}
	return nil, fmt.Errorf("unknown Message field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case message.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case message.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case message.FieldConversationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConversationID(v)
		return nil
	case message.FieldSenderID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSenderID(v)
		return nil
	case message.FieldType:
		v, ok := value.(message.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case message.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case message.FieldIsRead:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRead(v)
		return nil
	}
	return fmt.Errorf("unknown Message field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MessageMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MessageMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Message numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MessageMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MessageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MessageMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Message nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MessageMutation) ResetField(name string) error {
	switch name {
	case message.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case message.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case message.FieldConversationID:
		m.ResetConversationID()
		return nil
	case message.FieldSenderID:
		m.ResetSenderID()
		return nil
	case message.FieldType:
		m.ResetType()
		return nil
	case message.FieldContent:
		m.ResetContent()
		return nil
	case message.FieldIsRead:
		m.ResetIsRead()
		return nil
	}
	return fmt.Errorf("unknown Message field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MessageMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.conversation != nil {
		edges = append(edges, message.EdgeConversation)
	}
	if m.sender != nil {
		edges = append(edges, message.EdgeSender)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MessageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case message.EdgeConversation:
		if id := m.conversation; id != nil {
			return []ent.Value{*id}
		}
	case message.EdgeSender:
		if id := m.sender; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MessageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MessageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MessageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedconversation {
		edges = append(edges, message.EdgeConversation)
	}
	if m.clearedsender {
		edges = append(edges, message.EdgeSender)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MessageMutation) EdgeCleared(name string) bool {
	switch name {
	case message.EdgeConversation:
		return m.clearedconversation
	case message.EdgeSender:
		return m.clearedsender
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MessageMutation) ClearEdge(name string) error {
	switch name {
	case message.EdgeConversation:
		m.ClearConversation()
		return nil
	case message.EdgeSender:
		m.ClearSender()
		return nil
	}
	return fmt.Errorf("unknown Message unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MessageMutation) ResetEdge(name string) error {
	switch name {
	case message.EdgeConversation:
		m.ResetConversation()
		return nil
	case message.EdgeSender:
		m.ResetSender()
		return nil
	}
	return fmt.Errorf("unknown Message edge %s", name)
}

// OrderMutation represents an operation that mutates the Order nodes in the graph.
type OrderMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	note                 *string
	priority             *int
	addpriority          *int
	_type                *order.Type
	internal_note        *string
	is_internal          *bool
	clearedFields        map[string]struct{}
	customer             *uuid.UUID
	clearedcustomer      bool
	creator              *uuid.UUID
	clearedcreator       bool
	parent_order         *uuid.UUID
	clearedparent_order  bool
	order_status         *int
	clearedorder_status  bool
	staff                *uuid.UUID
	clearedstaff         bool
	order_address        *string
	clearedorder_address bool
	done                 bool
	oldValue             func(context.Context) (*Order, error)
	predicates           []predicate.Order
}

var _ ent.Mutation = (*OrderMutation)(nil)

// orderOption allows management of the mutation configuration using functional options.
type orderOption func(*OrderMutation)

// newOrderMutation creates new mutation for the Order entity.
func newOrderMutation(c config, op Op, opts ...orderOption) *OrderMutation {
	m := &OrderMutation{
		config:        c,
		op:            op,
		typ:           TypeOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderID sets the ID field of the mutation.
func withOrderID(id uuid.UUID) orderOption {
	return func(m *OrderMutation) {
		var (
			err   error
			once  sync.Once
			value *Order
		)
		m.oldValue = func(ctx context.Context) (*Order, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Order.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrder sets the old Order of the mutation.
func withOrder(node *Order) orderOption {
	return func(m *OrderMutation) {
		m.oldValue = func(context.Context) (*Order, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Order entities.
func (m *OrderMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Order.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCustomerID sets the "customer_id" field.
func (m *OrderMutation) SetCustomerID(u uuid.UUID) {
	m.customer = &u
}

// CustomerID returns the value of the "customer_id" field in the mutation.
func (m *OrderMutation) CustomerID() (r uuid.UUID, exists bool) {
	v := m.customer
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerID returns the old "customer_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCustomerID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerID: %w", err)
	}
	return oldValue.CustomerID, nil
}

// ResetCustomerID resets all changes to the "customer_id" field.
func (m *OrderMutation) ResetCustomerID() {
	m.customer = nil
}

// SetNote sets the "note" field.
func (m *OrderMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the value of the "note" field in the mutation.
func (m *OrderMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "note" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldNote(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ClearNote clears the value of the "note" field.
func (m *OrderMutation) ClearNote() {
	m.note = nil
	m.clearedFields[order.FieldNote] = struct{}{}
}

// NoteCleared returns if the "note" field was cleared in this mutation.
func (m *OrderMutation) NoteCleared() bool {
	_, ok := m.clearedFields[order.FieldNote]
	return ok
}

// ResetNote resets all changes to the "note" field.
func (m *OrderMutation) ResetNote() {
	m.note = nil
	delete(m.clearedFields, order.FieldNote)
}

// SetCreatedBy sets the "created_by" field.
func (m *OrderMutation) SetCreatedBy(u uuid.UUID) {
	m.creator = &u
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *OrderMutation) CreatedBy() (r uuid.UUID, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCreatedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *OrderMutation) ResetCreatedBy() {
	m.creator = nil
}

// SetParentOrderID sets the "parent_order_id" field.
func (m *OrderMutation) SetParentOrderID(u uuid.UUID) {
	m.parent_order = &u
}

// ParentOrderID returns the value of the "parent_order_id" field in the mutation.
func (m *OrderMutation) ParentOrderID() (r uuid.UUID, exists bool) {
	v := m.parent_order
	if v == nil {
		return
	}
	return *v, true
}

// OldParentOrderID returns the old "parent_order_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldParentOrderID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentOrderID: %w", err)
	}
	return oldValue.ParentOrderID, nil
}

// ClearParentOrderID clears the value of the "parent_order_id" field.
func (m *OrderMutation) ClearParentOrderID() {
	m.parent_order = nil
	m.clearedFields[order.FieldParentOrderID] = struct{}{}
}

// ParentOrderIDCleared returns if the "parent_order_id" field was cleared in this mutation.
func (m *OrderMutation) ParentOrderIDCleared() bool {
	_, ok := m.clearedFields[order.FieldParentOrderID]
	return ok
}

// ResetParentOrderID resets all changes to the "parent_order_id" field.
func (m *OrderMutation) ResetParentOrderID() {
	m.parent_order = nil
	delete(m.clearedFields, order.FieldParentOrderID)
}

// SetPriority sets the "priority" field.
func (m *OrderMutation) SetPriority(i int) {
	m.priority = &i
	m.addpriority = nil
}

// Priority returns the value of the "priority" field in the mutation.
func (m *OrderMutation) Priority() (r int, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldPriority(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// AddPriority adds i to the "priority" field.
func (m *OrderMutation) AddPriority(i int) {
	if m.addpriority != nil {
		*m.addpriority += i
	} else {
		m.addpriority = &i
	}
}

// AddedPriority returns the value that was added to the "priority" field in this mutation.
func (m *OrderMutation) AddedPriority() (r int, exists bool) {
	v := m.addpriority
	if v == nil {
		return
	}
	return *v, true
}

// ResetPriority resets all changes to the "priority" field.
func (m *OrderMutation) ResetPriority() {
	m.priority = nil
	m.addpriority = nil
}

// SetType sets the "type" field.
func (m *OrderMutation) SetType(o order.Type) {
	m._type = &o
}

// GetType returns the value of the "type" field in the mutation.
func (m *OrderMutation) GetType() (r order.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldType(ctx context.Context) (v order.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *OrderMutation) ResetType() {
	m._type = nil
}

// SetStatusCode sets the "status_code" field.
func (m *OrderMutation) SetStatusCode(i int) {
	m.order_status = &i
}

// StatusCode returns the value of the "status_code" field in the mutation.
func (m *OrderMutation) StatusCode() (r int, exists bool) {
	v := m.order_status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusCode returns the old "status_code" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldStatusCode(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatusCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatusCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusCode: %w", err)
	}
	return oldValue.StatusCode, nil
}

// ResetStatusCode resets all changes to the "status_code" field.
func (m *OrderMutation) ResetStatusCode() {
	m.order_status = nil
}

// SetStaffID sets the "staff_id" field.
func (m *OrderMutation) SetStaffID(u uuid.UUID) {
	m.staff = &u
}

// StaffID returns the value of the "staff_id" field in the mutation.
func (m *OrderMutation) StaffID() (r uuid.UUID, exists bool) {
	v := m.staff
	if v == nil {
		return
	}
	return *v, true
}

// OldStaffID returns the old "staff_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldStaffID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStaffID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStaffID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStaffID: %w", err)
	}
	return oldValue.StaffID, nil
}

// ResetStaffID resets all changes to the "staff_id" field.
func (m *OrderMutation) ResetStaffID() {
	m.staff = nil
}

// SetInternalNote sets the "internal_note" field.
func (m *OrderMutation) SetInternalNote(s string) {
	m.internal_note = &s
}

// InternalNote returns the value of the "internal_note" field in the mutation.
func (m *OrderMutation) InternalNote() (r string, exists bool) {
	v := m.internal_note
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalNote returns the old "internal_note" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldInternalNote(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalNote: %w", err)
	}
	return oldValue.InternalNote, nil
}

// ClearInternalNote clears the value of the "internal_note" field.
func (m *OrderMutation) ClearInternalNote() {
	m.internal_note = nil
	m.clearedFields[order.FieldInternalNote] = struct{}{}
}

// InternalNoteCleared returns if the "internal_note" field was cleared in this mutation.
func (m *OrderMutation) InternalNoteCleared() bool {
	_, ok := m.clearedFields[order.FieldInternalNote]
	return ok
}

// ResetInternalNote resets all changes to the "internal_note" field.
func (m *OrderMutation) ResetInternalNote() {
	m.internal_note = nil
	delete(m.clearedFields, order.FieldInternalNote)
}

// SetIsInternal sets the "is_internal" field.
func (m *OrderMutation) SetIsInternal(b bool) {
	m.is_internal = &b
}

// IsInternal returns the value of the "is_internal" field in the mutation.
func (m *OrderMutation) IsInternal() (r bool, exists bool) {
	v := m.is_internal
	if v == nil {
		return
	}
	return *v, true
}

// OldIsInternal returns the old "is_internal" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldIsInternal(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsInternal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsInternal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsInternal: %w", err)
	}
	return oldValue.IsInternal, nil
}

// ResetIsInternal resets all changes to the "is_internal" field.
func (m *OrderMutation) ResetIsInternal() {
	m.is_internal = nil
}

// SetAddressID sets the "address_id" field.
func (m *OrderMutation) SetAddressID(s string) {
	m.order_address = &s
}

// AddressID returns the value of the "address_id" field in the mutation.
func (m *OrderMutation) AddressID() (r string, exists bool) {
	v := m.order_address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddressID returns the old "address_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldAddressID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddressID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddressID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddressID: %w", err)
	}
	return oldValue.AddressID, nil
}

// ResetAddressID resets all changes to the "address_id" field.
func (m *OrderMutation) ResetAddressID() {
	m.order_address = nil
}

// ClearCustomer clears the "customer" edge to the Person entity.
func (m *OrderMutation) ClearCustomer() {
	m.clearedcustomer = true
	m.clearedFields[order.FieldCustomerID] = struct{}{}
}

// CustomerCleared reports if the "customer" edge to the Person entity was cleared.
func (m *OrderMutation) CustomerCleared() bool {
	return m.clearedcustomer
}

// CustomerIDs returns the "customer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CustomerID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) CustomerIDs() (ids []uuid.UUID) {
	if id := m.customer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomer resets all changes to the "customer" edge.
func (m *OrderMutation) ResetCustomer() {
	m.customer = nil
	m.clearedcustomer = false
}

// SetCreatorID sets the "creator" edge to the Person entity by id.
func (m *OrderMutation) SetCreatorID(id uuid.UUID) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the Person entity.
func (m *OrderMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[order.FieldCreatedBy] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the Person entity was cleared.
func (m *OrderMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *OrderMutation) CreatorID() (id uuid.UUID, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) CreatorIDs() (ids []uuid.UUID) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *OrderMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// ClearParentOrder clears the "parent_order" edge to the Order entity.
func (m *OrderMutation) ClearParentOrder() {
	m.clearedparent_order = true
	m.clearedFields[order.FieldParentOrderID] = struct{}{}
}

// ParentOrderCleared reports if the "parent_order" edge to the Order entity was cleared.
func (m *OrderMutation) ParentOrderCleared() bool {
	return m.ParentOrderIDCleared() || m.clearedparent_order
}

// ParentOrderIDs returns the "parent_order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentOrderID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) ParentOrderIDs() (ids []uuid.UUID) {
	if id := m.parent_order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParentOrder resets all changes to the "parent_order" edge.
func (m *OrderMutation) ResetParentOrder() {
	m.parent_order = nil
	m.clearedparent_order = false
}

// SetOrderStatusID sets the "order_status" edge to the OrderStatusCode entity by id.
func (m *OrderMutation) SetOrderStatusID(id int) {
	m.order_status = &id
}

// ClearOrderStatus clears the "order_status" edge to the OrderStatusCode entity.
func (m *OrderMutation) ClearOrderStatus() {
	m.clearedorder_status = true
	m.clearedFields[order.FieldStatusCode] = struct{}{}
}

// OrderStatusCleared reports if the "order_status" edge to the OrderStatusCode entity was cleared.
func (m *OrderMutation) OrderStatusCleared() bool {
	return m.clearedorder_status
}

// OrderStatusID returns the "order_status" edge ID in the mutation.
func (m *OrderMutation) OrderStatusID() (id int, exists bool) {
	if m.order_status != nil {
		return *m.order_status, true
	}
	return
}

// OrderStatusIDs returns the "order_status" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderStatusID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) OrderStatusIDs() (ids []int) {
	if id := m.order_status; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrderStatus resets all changes to the "order_status" edge.
func (m *OrderMutation) ResetOrderStatus() {
	m.order_status = nil
	m.clearedorder_status = false
}

// ClearStaff clears the "staff" edge to the Person entity.
func (m *OrderMutation) ClearStaff() {
	m.clearedstaff = true
	m.clearedFields[order.FieldStaffID] = struct{}{}
}

// StaffCleared reports if the "staff" edge to the Person entity was cleared.
func (m *OrderMutation) StaffCleared() bool {
	return m.clearedstaff
}

// StaffIDs returns the "staff" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StaffID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) StaffIDs() (ids []uuid.UUID) {
	if id := m.staff; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStaff resets all changes to the "staff" edge.
func (m *OrderMutation) ResetStaff() {
	m.staff = nil
	m.clearedstaff = false
}

// SetOrderAddressID sets the "order_address" edge to the Address entity by id.
func (m *OrderMutation) SetOrderAddressID(id string) {
	m.order_address = &id
}

// ClearOrderAddress clears the "order_address" edge to the Address entity.
func (m *OrderMutation) ClearOrderAddress() {
	m.clearedorder_address = true
	m.clearedFields[order.FieldAddressID] = struct{}{}
}

// OrderAddressCleared reports if the "order_address" edge to the Address entity was cleared.
func (m *OrderMutation) OrderAddressCleared() bool {
	return m.clearedorder_address
}

// OrderAddressID returns the "order_address" edge ID in the mutation.
func (m *OrderMutation) OrderAddressID() (id string, exists bool) {
	if m.order_address != nil {
		return *m.order_address, true
	}
	return
}

// OrderAddressIDs returns the "order_address" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderAddressID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) OrderAddressIDs() (ids []string) {
	if id := m.order_address; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrderAddress resets all changes to the "order_address" edge.
func (m *OrderMutation) ResetOrderAddress() {
	m.order_address = nil
	m.clearedorder_address = false
}

// Where appends a list predicates to the OrderMutation builder.
func (m *OrderMutation) Where(ps ...predicate.Order) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Order, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Order).
func (m *OrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, order.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, order.FieldUpdatedAt)
	}
	if m.customer != nil {
		fields = append(fields, order.FieldCustomerID)
	}
	if m.note != nil {
		fields = append(fields, order.FieldNote)
	}
	if m.creator != nil {
		fields = append(fields, order.FieldCreatedBy)
	}
	if m.parent_order != nil {
		fields = append(fields, order.FieldParentOrderID)
	}
	if m.priority != nil {
		fields = append(fields, order.FieldPriority)
	}
	if m._type != nil {
		fields = append(fields, order.FieldType)
	}
	if m.order_status != nil {
		fields = append(fields, order.FieldStatusCode)
	}
	if m.staff != nil {
		fields = append(fields, order.FieldStaffID)
	}
	if m.internal_note != nil {
		fields = append(fields, order.FieldInternalNote)
	}
	if m.is_internal != nil {
		fields = append(fields, order.FieldIsInternal)
	}
	if m.order_address != nil {
		fields = append(fields, order.FieldAddressID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case order.FieldCreatedAt:
		return m.CreatedAt()
	case order.FieldUpdatedAt:
		return m.UpdatedAt()
	case order.FieldCustomerID:
		return m.CustomerID()
	case order.FieldNote:
		return m.Note()
	case order.FieldCreatedBy:
		return m.CreatedBy()
	case order.FieldParentOrderID:
		return m.ParentOrderID()
	case order.FieldPriority:
		return m.Priority()
	case order.FieldType:
		return m.GetType()
	case order.FieldStatusCode:
		return m.StatusCode()
	case order.FieldStaffID:
		return m.StaffID()
	case order.FieldInternalNote:
		return m.InternalNote()
	case order.FieldIsInternal:
		return m.IsInternal()
	case order.FieldAddressID:
		return m.AddressID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case order.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case order.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case order.FieldCustomerID:
		return m.OldCustomerID(ctx)
	case order.FieldNote:
		return m.OldNote(ctx)
	case order.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case order.FieldParentOrderID:
		return m.OldParentOrderID(ctx)
	case order.FieldPriority:
		return m.OldPriority(ctx)
	case order.FieldType:
		return m.OldType(ctx)
	case order.FieldStatusCode:
		return m.OldStatusCode(ctx)
	case order.FieldStaffID:
		return m.OldStaffID(ctx)
	case order.FieldInternalNote:
		return m.OldInternalNote(ctx)
	case order.FieldIsInternal:
		return m.OldIsInternal(ctx)
	case order.FieldAddressID:
		return m.OldAddressID(ctx)
	}
	return nil, fmt.Errorf("unknown Order field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case order.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case order.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case order.FieldCustomerID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerID(v)
		return nil
	case order.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	case order.FieldCreatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case order.FieldParentOrderID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentOrderID(v)
		return nil
	case order.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case order.FieldType:
		v, ok := value.(order.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case order.FieldStatusCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusCode(v)
		return nil
	case order.FieldStaffID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStaffID(v)
		return nil
	case order.FieldInternalNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalNote(v)
		return nil
	case order.FieldIsInternal:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsInternal(v)
		return nil
	case order.FieldAddressID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddressID(v)
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderMutation) AddedFields() []string {
	var fields []string
	if m.addpriority != nil {
		fields = append(fields, order.FieldPriority)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case order.FieldPriority:
		return m.AddedPriority()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case order.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriority(v)
		return nil
	}
	return fmt.Errorf("unknown Order numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(order.FieldNote) {
		fields = append(fields, order.FieldNote)
	}
	if m.FieldCleared(order.FieldParentOrderID) {
		fields = append(fields, order.FieldParentOrderID)
	}
	if m.FieldCleared(order.FieldInternalNote) {
		fields = append(fields, order.FieldInternalNote)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderMutation) ClearField(name string) error {
	switch name {
	case order.FieldNote:
		m.ClearNote()
		return nil
	case order.FieldParentOrderID:
		m.ClearParentOrderID()
		return nil
	case order.FieldInternalNote:
		m.ClearInternalNote()
		return nil
	}
	return fmt.Errorf("unknown Order nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderMutation) ResetField(name string) error {
	switch name {
	case order.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case order.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case order.FieldCustomerID:
		m.ResetCustomerID()
		return nil
	case order.FieldNote:
		m.ResetNote()
		return nil
	case order.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case order.FieldParentOrderID:
		m.ResetParentOrderID()
		return nil
	case order.FieldPriority:
		m.ResetPriority()
		return nil
	case order.FieldType:
		m.ResetType()
		return nil
	case order.FieldStatusCode:
		m.ResetStatusCode()
		return nil
	case order.FieldStaffID:
		m.ResetStaffID()
		return nil
	case order.FieldInternalNote:
		m.ResetInternalNote()
		return nil
	case order.FieldIsInternal:
		m.ResetIsInternal()
		return nil
	case order.FieldAddressID:
		m.ResetAddressID()
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.customer != nil {
		edges = append(edges, order.EdgeCustomer)
	}
	if m.creator != nil {
		edges = append(edges, order.EdgeCreator)
	}
	if m.parent_order != nil {
		edges = append(edges, order.EdgeParentOrder)
	}
	if m.order_status != nil {
		edges = append(edges, order.EdgeOrderStatus)
	}
	if m.staff != nil {
		edges = append(edges, order.EdgeStaff)
	}
	if m.order_address != nil {
		edges = append(edges, order.EdgeOrderAddress)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case order.EdgeCustomer:
		if id := m.customer; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeParentOrder:
		if id := m.parent_order; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeOrderStatus:
		if id := m.order_status; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeStaff:
		if id := m.staff; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeOrderAddress:
		if id := m.order_address; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedcustomer {
		edges = append(edges, order.EdgeCustomer)
	}
	if m.clearedcreator {
		edges = append(edges, order.EdgeCreator)
	}
	if m.clearedparent_order {
		edges = append(edges, order.EdgeParentOrder)
	}
	if m.clearedorder_status {
		edges = append(edges, order.EdgeOrderStatus)
	}
	if m.clearedstaff {
		edges = append(edges, order.EdgeStaff)
	}
	if m.clearedorder_address {
		edges = append(edges, order.EdgeOrderAddress)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderMutation) EdgeCleared(name string) bool {
	switch name {
	case order.EdgeCustomer:
		return m.clearedcustomer
	case order.EdgeCreator:
		return m.clearedcreator
	case order.EdgeParentOrder:
		return m.clearedparent_order
	case order.EdgeOrderStatus:
		return m.clearedorder_status
	case order.EdgeStaff:
		return m.clearedstaff
	case order.EdgeOrderAddress:
		return m.clearedorder_address
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderMutation) ClearEdge(name string) error {
	switch name {
	case order.EdgeCustomer:
		m.ClearCustomer()
		return nil
	case order.EdgeCreator:
		m.ClearCreator()
		return nil
	case order.EdgeParentOrder:
		m.ClearParentOrder()
		return nil
	case order.EdgeOrderStatus:
		m.ClearOrderStatus()
		return nil
	case order.EdgeStaff:
		m.ClearStaff()
		return nil
	case order.EdgeOrderAddress:
		m.ClearOrderAddress()
		return nil
	}
	return fmt.Errorf("unknown Order unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderMutation) ResetEdge(name string) error {
	switch name {
	case order.EdgeCustomer:
		m.ResetCustomer()
		return nil
	case order.EdgeCreator:
		m.ResetCreator()
		return nil
	case order.EdgeParentOrder:
		m.ResetParentOrder()
		return nil
	case order.EdgeOrderStatus:
		m.ResetOrderStatus()
		return nil
	case order.EdgeStaff:
		m.ResetStaff()
		return nil
	case order.EdgeOrderAddress:
		m.ResetOrderAddress()
		return nil
	}
	return fmt.Errorf("unknown Order edge %s", name)
}

// OrderItemMutation represents an operation that mutates the OrderItem nodes in the graph.
type OrderItemMutation struct {
	config
	op                           Op
	typ                          string
	id                           *uuid.UUID
	created_at                   *time.Time
	updated_at                   *time.Time
	qty                          *decimal.Decimal
	addqty                       *decimal.Decimal
	price_per_unit               *decimal.Decimal
	addprice_per_unit            *decimal.Decimal
	status                       *orderitem.Status
	clearedFields                map[string]struct{}
	_order                       *uuid.UUID
	cleared_order                bool
	product                      *string
	clearedproduct               bool
	product_color                *string
	clearedproduct_color         bool
	source_work_unit             *uuid.UUID
	clearedsource_work_unit      bool
	destination_work_unit        *uuid.UUID
	cleareddestination_work_unit bool
	done                         bool
	oldValue                     func(context.Context) (*OrderItem, error)
	predicates                   []predicate.OrderItem
}

var _ ent.Mutation = (*OrderItemMutation)(nil)

// orderitemOption allows management of the mutation configuration using functional options.
type orderitemOption func(*OrderItemMutation)

// newOrderItemMutation creates new mutation for the OrderItem entity.
func newOrderItemMutation(c config, op Op, opts ...orderitemOption) *OrderItemMutation {
	m := &OrderItemMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderItemID sets the ID field of the mutation.
func withOrderItemID(id uuid.UUID) orderitemOption {
	return func(m *OrderItemMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderItem
		)
		m.oldValue = func(ctx context.Context) (*OrderItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderItem sets the old OrderItem of the mutation.
func withOrderItem(node *OrderItem) orderitemOption {
	return func(m *OrderItemMutation) {
		m.oldValue = func(context.Context) (*OrderItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrderItem entities.
func (m *OrderItemMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderItemMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderItemMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderItemMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderItemMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderItemMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderItemMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderItemMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderItemMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetOrderID sets the "order_id" field.
func (m *OrderItemMutation) SetOrderID(u uuid.UUID) {
	m._order = &u
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *OrderItemMutation) OrderID() (r uuid.UUID, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldOrderID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *OrderItemMutation) ResetOrderID() {
	m._order = nil
}

// SetProductID sets the "product_id" field.
func (m *OrderItemMutation) SetProductID(s string) {
	m.product = &s
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *OrderItemMutation) ProductID() (r string, exists bool) {
	v := m.product
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldProductID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// ResetProductID resets all changes to the "product_id" field.
func (m *OrderItemMutation) ResetProductID() {
	m.product = nil
}

// SetProductColorID sets the "product_color_id" field.
func (m *OrderItemMutation) SetProductColorID(s string) {
	m.product_color = &s
}

// ProductColorID returns the value of the "product_color_id" field in the mutation.
func (m *OrderItemMutation) ProductColorID() (r string, exists bool) {
	v := m.product_color
	if v == nil {
		return
	}
	return *v, true
}

// OldProductColorID returns the old "product_color_id" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldProductColorID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductColorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductColorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductColorID: %w", err)
	}
	return oldValue.ProductColorID, nil
}

// ResetProductColorID resets all changes to the "product_color_id" field.
func (m *OrderItemMutation) ResetProductColorID() {
	m.product_color = nil
}

// SetSrcUnitID sets the "src_unit_id" field.
func (m *OrderItemMutation) SetSrcUnitID(u uuid.UUID) {
	m.source_work_unit = &u
}

// SrcUnitID returns the value of the "src_unit_id" field in the mutation.
func (m *OrderItemMutation) SrcUnitID() (r uuid.UUID, exists bool) {
	v := m.source_work_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldSrcUnitID returns the old "src_unit_id" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldSrcUnitID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSrcUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSrcUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSrcUnitID: %w", err)
	}
	return oldValue.SrcUnitID, nil
}

// ClearSrcUnitID clears the value of the "src_unit_id" field.
func (m *OrderItemMutation) ClearSrcUnitID() {
	m.source_work_unit = nil
	m.clearedFields[orderitem.FieldSrcUnitID] = struct{}{}
}

// SrcUnitIDCleared returns if the "src_unit_id" field was cleared in this mutation.
func (m *OrderItemMutation) SrcUnitIDCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldSrcUnitID]
	return ok
}

// ResetSrcUnitID resets all changes to the "src_unit_id" field.
func (m *OrderItemMutation) ResetSrcUnitID() {
	m.source_work_unit = nil
	delete(m.clearedFields, orderitem.FieldSrcUnitID)
}

// SetDstUnitID sets the "dst_unit_id" field.
func (m *OrderItemMutation) SetDstUnitID(u uuid.UUID) {
	m.destination_work_unit = &u
}

// DstUnitID returns the value of the "dst_unit_id" field in the mutation.
func (m *OrderItemMutation) DstUnitID() (r uuid.UUID, exists bool) {
	v := m.destination_work_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldDstUnitID returns the old "dst_unit_id" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldDstUnitID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDstUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDstUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDstUnitID: %w", err)
	}
	return oldValue.DstUnitID, nil
}

// ClearDstUnitID clears the value of the "dst_unit_id" field.
func (m *OrderItemMutation) ClearDstUnitID() {
	m.destination_work_unit = nil
	m.clearedFields[orderitem.FieldDstUnitID] = struct{}{}
}

// DstUnitIDCleared returns if the "dst_unit_id" field was cleared in this mutation.
func (m *OrderItemMutation) DstUnitIDCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldDstUnitID]
	return ok
}

// ResetDstUnitID resets all changes to the "dst_unit_id" field.
func (m *OrderItemMutation) ResetDstUnitID() {
	m.destination_work_unit = nil
	delete(m.clearedFields, orderitem.FieldDstUnitID)
}

// SetQty sets the "qty" field.
func (m *OrderItemMutation) SetQty(d decimal.Decimal) {
	m.qty = &d
	m.addqty = nil
}

// Qty returns the value of the "qty" field in the mutation.
func (m *OrderItemMutation) Qty() (r decimal.Decimal, exists bool) {
	v := m.qty
	if v == nil {
		return
	}
	return *v, true
}

// OldQty returns the old "qty" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldQty(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQty: %w", err)
	}
	return oldValue.Qty, nil
}

// AddQty adds d to the "qty" field.
func (m *OrderItemMutation) AddQty(d decimal.Decimal) {
	if m.addqty != nil {
		*m.addqty = m.addqty.Add(d)
	} else {
		m.addqty = &d
	}
}

// AddedQty returns the value that was added to the "qty" field in this mutation.
func (m *OrderItemMutation) AddedQty() (r decimal.Decimal, exists bool) {
	v := m.addqty
	if v == nil {
		return
	}
	return *v, true
}

// ResetQty resets all changes to the "qty" field.
func (m *OrderItemMutation) ResetQty() {
	m.qty = nil
	m.addqty = nil
}

// SetPricePerUnit sets the "price_per_unit" field.
func (m *OrderItemMutation) SetPricePerUnit(d decimal.Decimal) {
	m.price_per_unit = &d
	m.addprice_per_unit = nil
}

// PricePerUnit returns the value of the "price_per_unit" field in the mutation.
func (m *OrderItemMutation) PricePerUnit() (r decimal.Decimal, exists bool) {
	v := m.price_per_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldPricePerUnit returns the old "price_per_unit" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldPricePerUnit(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPricePerUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPricePerUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPricePerUnit: %w", err)
	}
	return oldValue.PricePerUnit, nil
}

// AddPricePerUnit adds d to the "price_per_unit" field.
func (m *OrderItemMutation) AddPricePerUnit(d decimal.Decimal) {
	if m.addprice_per_unit != nil {
		*m.addprice_per_unit = m.addprice_per_unit.Add(d)
	} else {
		m.addprice_per_unit = &d
	}
}

// AddedPricePerUnit returns the value that was added to the "price_per_unit" field in this mutation.
func (m *OrderItemMutation) AddedPricePerUnit() (r decimal.Decimal, exists bool) {
	v := m.addprice_per_unit
	if v == nil {
		return
	}
	return *v, true
}

// ResetPricePerUnit resets all changes to the "price_per_unit" field.
func (m *OrderItemMutation) ResetPricePerUnit() {
	m.price_per_unit = nil
	m.addprice_per_unit = nil
}

// SetStatus sets the "status" field.
func (m *OrderItemMutation) SetStatus(o orderitem.Status) {
	m.status = &o
}

// Status returns the value of the "status" field in the mutation.
func (m *OrderItemMutation) Status() (r orderitem.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldStatus(ctx context.Context) (v orderitem.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *OrderItemMutation) ResetStatus() {
	m.status = nil
}

// ClearOrder clears the "order" edge to the Order entity.
func (m *OrderItemMutation) ClearOrder() {
	m.cleared_order = true
	m.clearedFields[orderitem.FieldOrderID] = struct{}{}
}

// OrderCleared reports if the "order" edge to the Order entity was cleared.
func (m *OrderItemMutation) OrderCleared() bool {
	return m.cleared_order
}

// OrderIDs returns the "order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderID instead. It exists only for internal usage by the builders.
func (m *OrderItemMutation) OrderIDs() (ids []uuid.UUID) {
	if id := m._order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrder resets all changes to the "order" edge.
func (m *OrderItemMutation) ResetOrder() {
	m._order = nil
	m.cleared_order = false
}

// ClearProduct clears the "product" edge to the ProductInfo entity.
func (m *OrderItemMutation) ClearProduct() {
	m.clearedproduct = true
	m.clearedFields[orderitem.FieldProductID] = struct{}{}
}

// ProductCleared reports if the "product" edge to the ProductInfo entity was cleared.
func (m *OrderItemMutation) ProductCleared() bool {
	return m.clearedproduct
}

// ProductIDs returns the "product" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductID instead. It exists only for internal usage by the builders.
func (m *OrderItemMutation) ProductIDs() (ids []string) {
	if id := m.product; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProduct resets all changes to the "product" edge.
func (m *OrderItemMutation) ResetProduct() {
	m.product = nil
	m.clearedproduct = false
}

// ClearProductColor clears the "product_color" edge to the ProductColor entity.
func (m *OrderItemMutation) ClearProductColor() {
	m.clearedproduct_color = true
	m.clearedFields[orderitem.FieldProductColorID] = struct{}{}
}

// ProductColorCleared reports if the "product_color" edge to the ProductColor entity was cleared.
func (m *OrderItemMutation) ProductColorCleared() bool {
	return m.clearedproduct_color
}

// ProductColorIDs returns the "product_color" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductColorID instead. It exists only for internal usage by the builders.
func (m *OrderItemMutation) ProductColorIDs() (ids []string) {
	if id := m.product_color; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProductColor resets all changes to the "product_color" edge.
func (m *OrderItemMutation) ResetProductColor() {
	m.product_color = nil
	m.clearedproduct_color = false
}

// SetSourceWorkUnitID sets the "source_work_unit" edge to the WorkUnitInfo entity by id.
func (m *OrderItemMutation) SetSourceWorkUnitID(id uuid.UUID) {
	m.source_work_unit = &id
}

// ClearSourceWorkUnit clears the "source_work_unit" edge to the WorkUnitInfo entity.
func (m *OrderItemMutation) ClearSourceWorkUnit() {
	m.clearedsource_work_unit = true
	m.clearedFields[orderitem.FieldSrcUnitID] = struct{}{}
}

// SourceWorkUnitCleared reports if the "source_work_unit" edge to the WorkUnitInfo entity was cleared.
func (m *OrderItemMutation) SourceWorkUnitCleared() bool {
	return m.SrcUnitIDCleared() || m.clearedsource_work_unit
}

// SourceWorkUnitID returns the "source_work_unit" edge ID in the mutation.
func (m *OrderItemMutation) SourceWorkUnitID() (id uuid.UUID, exists bool) {
	if m.source_work_unit != nil {
		return *m.source_work_unit, true
	}
	return
}

// SourceWorkUnitIDs returns the "source_work_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SourceWorkUnitID instead. It exists only for internal usage by the builders.
func (m *OrderItemMutation) SourceWorkUnitIDs() (ids []uuid.UUID) {
	if id := m.source_work_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSourceWorkUnit resets all changes to the "source_work_unit" edge.
func (m *OrderItemMutation) ResetSourceWorkUnit() {
	m.source_work_unit = nil
	m.clearedsource_work_unit = false
}

// SetDestinationWorkUnitID sets the "destination_work_unit" edge to the WorkUnitInfo entity by id.
func (m *OrderItemMutation) SetDestinationWorkUnitID(id uuid.UUID) {
	m.destination_work_unit = &id
}

// ClearDestinationWorkUnit clears the "destination_work_unit" edge to the WorkUnitInfo entity.
func (m *OrderItemMutation) ClearDestinationWorkUnit() {
	m.cleareddestination_work_unit = true
	m.clearedFields[orderitem.FieldDstUnitID] = struct{}{}
}

// DestinationWorkUnitCleared reports if the "destination_work_unit" edge to the WorkUnitInfo entity was cleared.
func (m *OrderItemMutation) DestinationWorkUnitCleared() bool {
	return m.DstUnitIDCleared() || m.cleareddestination_work_unit
}

// DestinationWorkUnitID returns the "destination_work_unit" edge ID in the mutation.
func (m *OrderItemMutation) DestinationWorkUnitID() (id uuid.UUID, exists bool) {
	if m.destination_work_unit != nil {
		return *m.destination_work_unit, true
	}
	return
}

// DestinationWorkUnitIDs returns the "destination_work_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DestinationWorkUnitID instead. It exists only for internal usage by the builders.
func (m *OrderItemMutation) DestinationWorkUnitIDs() (ids []uuid.UUID) {
	if id := m.destination_work_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDestinationWorkUnit resets all changes to the "destination_work_unit" edge.
func (m *OrderItemMutation) ResetDestinationWorkUnit() {
	m.destination_work_unit = nil
	m.cleareddestination_work_unit = false
}

// Where appends a list predicates to the OrderItemMutation builder.
func (m *OrderItemMutation) Where(ps ...predicate.OrderItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrderItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrderItem).
func (m *OrderItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderItemMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, orderitem.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, orderitem.FieldUpdatedAt)
	}
	if m._order != nil {
		fields = append(fields, orderitem.FieldOrderID)
	}
	if m.product != nil {
		fields = append(fields, orderitem.FieldProductID)
	}
	if m.product_color != nil {
		fields = append(fields, orderitem.FieldProductColorID)
	}
	if m.source_work_unit != nil {
		fields = append(fields, orderitem.FieldSrcUnitID)
	}
	if m.destination_work_unit != nil {
		fields = append(fields, orderitem.FieldDstUnitID)
	}
	if m.qty != nil {
		fields = append(fields, orderitem.FieldQty)
	}
	if m.price_per_unit != nil {
		fields = append(fields, orderitem.FieldPricePerUnit)
	}
	if m.status != nil {
		fields = append(fields, orderitem.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderitem.FieldCreatedAt:
		return m.CreatedAt()
	case orderitem.FieldUpdatedAt:
		return m.UpdatedAt()
	case orderitem.FieldOrderID:
		return m.OrderID()
	case orderitem.FieldProductID:
		return m.ProductID()
	case orderitem.FieldProductColorID:
		return m.ProductColorID()
	case orderitem.FieldSrcUnitID:
		return m.SrcUnitID()
	case orderitem.FieldDstUnitID:
		return m.DstUnitID()
	case orderitem.FieldQty:
		return m.Qty()
	case orderitem.FieldPricePerUnit:
		return m.PricePerUnit()
	case orderitem.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderitem.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case orderitem.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case orderitem.FieldOrderID:
		return m.OldOrderID(ctx)
	case orderitem.FieldProductID:
		return m.OldProductID(ctx)
	case orderitem.FieldProductColorID:
		return m.OldProductColorID(ctx)
	case orderitem.FieldSrcUnitID:
		return m.OldSrcUnitID(ctx)
	case orderitem.FieldDstUnitID:
		return m.OldDstUnitID(ctx)
	case orderitem.FieldQty:
		return m.OldQty(ctx)
	case orderitem.FieldPricePerUnit:
		return m.OldPricePerUnit(ctx)
	case orderitem.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown OrderItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderitem.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case orderitem.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case orderitem.FieldOrderID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case orderitem.FieldProductID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case orderitem.FieldProductColorID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductColorID(v)
		return nil
	case orderitem.FieldSrcUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSrcUnitID(v)
		return nil
	case orderitem.FieldDstUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDstUnitID(v)
		return nil
	case orderitem.FieldQty:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQty(v)
		return nil
	case orderitem.FieldPricePerUnit:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPricePerUnit(v)
		return nil
	case orderitem.FieldStatus:
		v, ok := value.(orderitem.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown OrderItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderItemMutation) AddedFields() []string {
	var fields []string
	if m.addqty != nil {
		fields = append(fields, orderitem.FieldQty)
	}
	if m.addprice_per_unit != nil {
		fields = append(fields, orderitem.FieldPricePerUnit)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderitem.FieldQty:
		return m.AddedQty()
	case orderitem.FieldPricePerUnit:
		return m.AddedPricePerUnit()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderitem.FieldQty:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQty(v)
		return nil
	case orderitem.FieldPricePerUnit:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPricePerUnit(v)
		return nil
	}
	return fmt.Errorf("unknown OrderItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orderitem.FieldSrcUnitID) {
		fields = append(fields, orderitem.FieldSrcUnitID)
	}
	if m.FieldCleared(orderitem.FieldDstUnitID) {
		fields = append(fields, orderitem.FieldDstUnitID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderItemMutation) ClearField(name string) error {
	switch name {
	case orderitem.FieldSrcUnitID:
		m.ClearSrcUnitID()
		return nil
	case orderitem.FieldDstUnitID:
		m.ClearDstUnitID()
		return nil
	}
	return fmt.Errorf("unknown OrderItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderItemMutation) ResetField(name string) error {
	switch name {
	case orderitem.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case orderitem.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case orderitem.FieldOrderID:
		m.ResetOrderID()
		return nil
	case orderitem.FieldProductID:
		m.ResetProductID()
		return nil
	case orderitem.FieldProductColorID:
		m.ResetProductColorID()
		return nil
	case orderitem.FieldSrcUnitID:
		m.ResetSrcUnitID()
		return nil
	case orderitem.FieldDstUnitID:
		m.ResetDstUnitID()
		return nil
	case orderitem.FieldQty:
		m.ResetQty()
		return nil
	case orderitem.FieldPricePerUnit:
		m.ResetPricePerUnit()
		return nil
	case orderitem.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown OrderItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m._order != nil {
		edges = append(edges, orderitem.EdgeOrder)
	}
	if m.product != nil {
		edges = append(edges, orderitem.EdgeProduct)
	}
	if m.product_color != nil {
		edges = append(edges, orderitem.EdgeProductColor)
	}
	if m.source_work_unit != nil {
		edges = append(edges, orderitem.EdgeSourceWorkUnit)
	}
	if m.destination_work_unit != nil {
		edges = append(edges, orderitem.EdgeDestinationWorkUnit)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orderitem.EdgeOrder:
		if id := m._order; id != nil {
			return []ent.Value{*id}
		}
	case orderitem.EdgeProduct:
		if id := m.product; id != nil {
			return []ent.Value{*id}
		}
	case orderitem.EdgeProductColor:
		if id := m.product_color; id != nil {
			return []ent.Value{*id}
		}
	case orderitem.EdgeSourceWorkUnit:
		if id := m.source_work_unit; id != nil {
			return []ent.Value{*id}
		}
	case orderitem.EdgeDestinationWorkUnit:
		if id := m.destination_work_unit; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderItemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.cleared_order {
		edges = append(edges, orderitem.EdgeOrder)
	}
	if m.clearedproduct {
		edges = append(edges, orderitem.EdgeProduct)
	}
	if m.clearedproduct_color {
		edges = append(edges, orderitem.EdgeProductColor)
	}
	if m.clearedsource_work_unit {
		edges = append(edges, orderitem.EdgeSourceWorkUnit)
	}
	if m.cleareddestination_work_unit {
		edges = append(edges, orderitem.EdgeDestinationWorkUnit)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderItemMutation) EdgeCleared(name string) bool {
	switch name {
	case orderitem.EdgeOrder:
		return m.cleared_order
	case orderitem.EdgeProduct:
		return m.clearedproduct
	case orderitem.EdgeProductColor:
		return m.clearedproduct_color
	case orderitem.EdgeSourceWorkUnit:
		return m.clearedsource_work_unit
	case orderitem.EdgeDestinationWorkUnit:
		return m.cleareddestination_work_unit
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderItemMutation) ClearEdge(name string) error {
	switch name {
	case orderitem.EdgeOrder:
		m.ClearOrder()
		return nil
	case orderitem.EdgeProduct:
		m.ClearProduct()
		return nil
	case orderitem.EdgeProductColor:
		m.ClearProductColor()
		return nil
	case orderitem.EdgeSourceWorkUnit:
		m.ClearSourceWorkUnit()
		return nil
	case orderitem.EdgeDestinationWorkUnit:
		m.ClearDestinationWorkUnit()
		return nil
	}
	return fmt.Errorf("unknown OrderItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderItemMutation) ResetEdge(name string) error {
	switch name {
	case orderitem.EdgeOrder:
		m.ResetOrder()
		return nil
	case orderitem.EdgeProduct:
		m.ResetProduct()
		return nil
	case orderitem.EdgeProductColor:
		m.ResetProductColor()
		return nil
	case orderitem.EdgeSourceWorkUnit:
		m.ResetSourceWorkUnit()
		return nil
	case orderitem.EdgeDestinationWorkUnit:
		m.ResetDestinationWorkUnit()
		return nil
	}
	return fmt.Errorf("unknown OrderItem edge %s", name)
}

// OrderStatusCodeMutation represents an operation that mutates the OrderStatusCode nodes in the graph.
type OrderStatusCodeMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	order_status  *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*OrderStatusCode, error)
	predicates    []predicate.OrderStatusCode
}

var _ ent.Mutation = (*OrderStatusCodeMutation)(nil)

// orderstatuscodeOption allows management of the mutation configuration using functional options.
type orderstatuscodeOption func(*OrderStatusCodeMutation)

// newOrderStatusCodeMutation creates new mutation for the OrderStatusCode entity.
func newOrderStatusCodeMutation(c config, op Op, opts ...orderstatuscodeOption) *OrderStatusCodeMutation {
	m := &OrderStatusCodeMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderStatusCode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderStatusCodeID sets the ID field of the mutation.
func withOrderStatusCodeID(id int) orderstatuscodeOption {
	return func(m *OrderStatusCodeMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderStatusCode
		)
		m.oldValue = func(ctx context.Context) (*OrderStatusCode, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderStatusCode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderStatusCode sets the old OrderStatusCode of the mutation.
func withOrderStatusCode(node *OrderStatusCode) orderstatuscodeOption {
	return func(m *OrderStatusCodeMutation) {
		m.oldValue = func(context.Context) (*OrderStatusCode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderStatusCodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderStatusCodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrderStatusCode entities.
func (m *OrderStatusCodeMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderStatusCodeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderStatusCodeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderStatusCode.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderStatusCodeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderStatusCodeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrderStatusCode entity.
// If the OrderStatusCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderStatusCodeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderStatusCodeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderStatusCodeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderStatusCodeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrderStatusCode entity.
// If the OrderStatusCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderStatusCodeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderStatusCodeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetOrderStatus sets the "order_status" field.
func (m *OrderStatusCodeMutation) SetOrderStatus(s string) {
	m.order_status = &s
}

// OrderStatus returns the value of the "order_status" field in the mutation.
func (m *OrderStatusCodeMutation) OrderStatus() (r string, exists bool) {
	v := m.order_status
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderStatus returns the old "order_status" field's value of the OrderStatusCode entity.
// If the OrderStatusCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderStatusCodeMutation) OldOrderStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderStatus: %w", err)
	}
	return oldValue.OrderStatus, nil
}

// ResetOrderStatus resets all changes to the "order_status" field.
func (m *OrderStatusCodeMutation) ResetOrderStatus() {
	m.order_status = nil
}

// Where appends a list predicates to the OrderStatusCodeMutation builder.
func (m *OrderStatusCodeMutation) Where(ps ...predicate.OrderStatusCode) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderStatusCodeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderStatusCodeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrderStatusCode, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderStatusCodeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderStatusCodeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrderStatusCode).
func (m *OrderStatusCodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderStatusCodeMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, orderstatuscode.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, orderstatuscode.FieldUpdatedAt)
	}
	if m.order_status != nil {
		fields = append(fields, orderstatuscode.FieldOrderStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderStatusCodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderstatuscode.FieldCreatedAt:
		return m.CreatedAt()
	case orderstatuscode.FieldUpdatedAt:
		return m.UpdatedAt()
	case orderstatuscode.FieldOrderStatus:
		return m.OrderStatus()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderStatusCodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderstatuscode.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case orderstatuscode.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case orderstatuscode.FieldOrderStatus:
		return m.OldOrderStatus(ctx)
	}
	return nil, fmt.Errorf("unknown OrderStatusCode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderStatusCodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderstatuscode.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case orderstatuscode.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case orderstatuscode.FieldOrderStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderStatus(v)
		return nil
	}
	return fmt.Errorf("unknown OrderStatusCode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderStatusCodeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderStatusCodeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderStatusCodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OrderStatusCode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderStatusCodeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderStatusCodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderStatusCodeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OrderStatusCode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderStatusCodeMutation) ResetField(name string) error {
	switch name {
	case orderstatuscode.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case orderstatuscode.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case orderstatuscode.FieldOrderStatus:
		m.ResetOrderStatus()
		return nil
	}
	return fmt.Errorf("unknown OrderStatusCode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderStatusCodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderStatusCodeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderStatusCodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderStatusCodeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderStatusCodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderStatusCodeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderStatusCodeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown OrderStatusCode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderStatusCodeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown OrderStatusCode edge %s", name)
}

// PersonMutation represents an operation that mutates the Person nodes in the graph.
type PersonMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	created_at        *time.Time
	updated_at        *time.Time
	avatar_url        *string
	email             *string
	name              *string
	phone             *string
	role              *person.Role
	password_hash     *[]byte
	is_email_verified *bool
	is_phone_verified *bool
	clearedFields     map[string]struct{}
	work_unit         *uuid.UUID
	clearedwork_unit  bool
	addresses         map[string]struct{}
	removedaddresses  map[string]struct{}
	clearedaddresses  bool
	done              bool
	oldValue          func(context.Context) (*Person, error)
	predicates        []predicate.Person
}

var _ ent.Mutation = (*PersonMutation)(nil)

// personOption allows management of the mutation configuration using functional options.
type personOption func(*PersonMutation)

// newPersonMutation creates new mutation for the Person entity.
func newPersonMutation(c config, op Op, opts ...personOption) *PersonMutation {
	m := &PersonMutation{
		config:        c,
		op:            op,
		typ:           TypePerson,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPersonID sets the ID field of the mutation.
func withPersonID(id uuid.UUID) personOption {
	return func(m *PersonMutation) {
		var (
			err   error
			once  sync.Once
			value *Person
		)
		m.oldValue = func(ctx context.Context) (*Person, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Person.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPerson sets the old Person of the mutation.
func withPerson(node *Person) personOption {
	return func(m *PersonMutation) {
		m.oldValue = func(context.Context) (*Person, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PersonMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PersonMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Person entities.
func (m *PersonMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PersonMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PersonMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Person.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PersonMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PersonMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PersonMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PersonMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PersonMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PersonMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetAvatarURL sets the "avatar_url" field.
func (m *PersonMutation) SetAvatarURL(s string) {
	m.avatar_url = &s
}

// AvatarURL returns the value of the "avatar_url" field in the mutation.
func (m *PersonMutation) AvatarURL() (r string, exists bool) {
	v := m.avatar_url
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarURL returns the old "avatar_url" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldAvatarURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatarURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatarURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarURL: %w", err)
	}
	return oldValue.AvatarURL, nil
}

// ClearAvatarURL clears the value of the "avatar_url" field.
func (m *PersonMutation) ClearAvatarURL() {
	m.avatar_url = nil
	m.clearedFields[person.FieldAvatarURL] = struct{}{}
}

// AvatarURLCleared returns if the "avatar_url" field was cleared in this mutation.
func (m *PersonMutation) AvatarURLCleared() bool {
	_, ok := m.clearedFields[person.FieldAvatarURL]
	return ok
}

// ResetAvatarURL resets all changes to the "avatar_url" field.
func (m *PersonMutation) ResetAvatarURL() {
	m.avatar_url = nil
	delete(m.clearedFields, person.FieldAvatarURL)
}

// SetEmail sets the "email" field.
func (m *PersonMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *PersonMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *PersonMutation) ResetEmail() {
	m.email = nil
}

// SetName sets the "name" field.
func (m *PersonMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PersonMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PersonMutation) ResetName() {
	m.name = nil
}

// SetPhone sets the "phone" field.
func (m *PersonMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *PersonMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldPhone(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "phone" field.
func (m *PersonMutation) ClearPhone() {
	m.phone = nil
	m.clearedFields[person.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "phone" field was cleared in this mutation.
func (m *PersonMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[person.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "phone" field.
func (m *PersonMutation) ResetPhone() {
	m.phone = nil
	delete(m.clearedFields, person.FieldPhone)
}

// SetRole sets the "role" field.
func (m *PersonMutation) SetRole(pe person.Role) {
	m.role = &pe
}

// Role returns the value of the "role" field in the mutation.
func (m *PersonMutation) Role() (r person.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldRole(ctx context.Context) (v person.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *PersonMutation) ResetRole() {
	m.role = nil
}

// SetPasswordHash sets the "password_hash" field.
func (m *PersonMutation) SetPasswordHash(b []byte) {
	m.password_hash = &b
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *PersonMutation) PasswordHash() (r []byte, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldPasswordHash(ctx context.Context) (v *[]byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ClearPasswordHash clears the value of the "password_hash" field.
func (m *PersonMutation) ClearPasswordHash() {
	m.password_hash = nil
	m.clearedFields[person.FieldPasswordHash] = struct{}{}
}

// PasswordHashCleared returns if the "password_hash" field was cleared in this mutation.
func (m *PersonMutation) PasswordHashCleared() bool {
	_, ok := m.clearedFields[person.FieldPasswordHash]
	return ok
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *PersonMutation) ResetPasswordHash() {
	m.password_hash = nil
	delete(m.clearedFields, person.FieldPasswordHash)
}

// SetIsEmailVerified sets the "is_email_verified" field.
func (m *PersonMutation) SetIsEmailVerified(b bool) {
	m.is_email_verified = &b
}

// IsEmailVerified returns the value of the "is_email_verified" field in the mutation.
func (m *PersonMutation) IsEmailVerified() (r bool, exists bool) {
	v := m.is_email_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldIsEmailVerified returns the old "is_email_verified" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldIsEmailVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsEmailVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsEmailVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsEmailVerified: %w", err)
	}
	return oldValue.IsEmailVerified, nil
}

// ResetIsEmailVerified resets all changes to the "is_email_verified" field.
func (m *PersonMutation) ResetIsEmailVerified() {
	m.is_email_verified = nil
}

// SetIsPhoneVerified sets the "is_phone_verified" field.
func (m *PersonMutation) SetIsPhoneVerified(b bool) {
	m.is_phone_verified = &b
}

// IsPhoneVerified returns the value of the "is_phone_verified" field in the mutation.
func (m *PersonMutation) IsPhoneVerified() (r bool, exists bool) {
	v := m.is_phone_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPhoneVerified returns the old "is_phone_verified" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldIsPhoneVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPhoneVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPhoneVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPhoneVerified: %w", err)
	}
	return oldValue.IsPhoneVerified, nil
}

// ResetIsPhoneVerified resets all changes to the "is_phone_verified" field.
func (m *PersonMutation) ResetIsPhoneVerified() {
	m.is_phone_verified = nil
}

// SetWorkUnitID sets the "work_unit_id" field.
func (m *PersonMutation) SetWorkUnitID(u uuid.UUID) {
	m.work_unit = &u
}

// WorkUnitID returns the value of the "work_unit_id" field in the mutation.
func (m *PersonMutation) WorkUnitID() (r uuid.UUID, exists bool) {
	v := m.work_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkUnitID returns the old "work_unit_id" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldWorkUnitID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkUnitID: %w", err)
	}
	return oldValue.WorkUnitID, nil
}

// ClearWorkUnitID clears the value of the "work_unit_id" field.
func (m *PersonMutation) ClearWorkUnitID() {
	m.work_unit = nil
	m.clearedFields[person.FieldWorkUnitID] = struct{}{}
}

// WorkUnitIDCleared returns if the "work_unit_id" field was cleared in this mutation.
func (m *PersonMutation) WorkUnitIDCleared() bool {
	_, ok := m.clearedFields[person.FieldWorkUnitID]
	return ok
}

// ResetWorkUnitID resets all changes to the "work_unit_id" field.
func (m *PersonMutation) ResetWorkUnitID() {
	m.work_unit = nil
	delete(m.clearedFields, person.FieldWorkUnitID)
}

// ClearWorkUnit clears the "work_unit" edge to the WorkUnitInfo entity.
func (m *PersonMutation) ClearWorkUnit() {
	m.clearedwork_unit = true
	m.clearedFields[person.FieldWorkUnitID] = struct{}{}
}

// WorkUnitCleared reports if the "work_unit" edge to the WorkUnitInfo entity was cleared.
func (m *PersonMutation) WorkUnitCleared() bool {
	return m.WorkUnitIDCleared() || m.clearedwork_unit
}

// WorkUnitIDs returns the "work_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkUnitID instead. It exists only for internal usage by the builders.
func (m *PersonMutation) WorkUnitIDs() (ids []uuid.UUID) {
	if id := m.work_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkUnit resets all changes to the "work_unit" edge.
func (m *PersonMutation) ResetWorkUnit() {
	m.work_unit = nil
	m.clearedwork_unit = false
}

// AddAddressIDs adds the "addresses" edge to the Address entity by ids.
func (m *PersonMutation) AddAddressIDs(ids ...string) {
	if m.addresses == nil {
		m.addresses = make(map[string]struct{})
	}
	for i := range ids {
		m.addresses[ids[i]] = struct{}{}
	}
}

// ClearAddresses clears the "addresses" edge to the Address entity.
func (m *PersonMutation) ClearAddresses() {
	m.clearedaddresses = true
}

// AddressesCleared reports if the "addresses" edge to the Address entity was cleared.
func (m *PersonMutation) AddressesCleared() bool {
	return m.clearedaddresses
}

// RemoveAddressIDs removes the "addresses" edge to the Address entity by IDs.
func (m *PersonMutation) RemoveAddressIDs(ids ...string) {
	if m.removedaddresses == nil {
		m.removedaddresses = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.addresses, ids[i])
		m.removedaddresses[ids[i]] = struct{}{}
	}
}

// RemovedAddresses returns the removed IDs of the "addresses" edge to the Address entity.
func (m *PersonMutation) RemovedAddressesIDs() (ids []string) {
	for id := range m.removedaddresses {
		ids = append(ids, id)
	}
	return
}

// AddressesIDs returns the "addresses" edge IDs in the mutation.
func (m *PersonMutation) AddressesIDs() (ids []string) {
	for id := range m.addresses {
		ids = append(ids, id)
	}
	return
}

// ResetAddresses resets all changes to the "addresses" edge.
func (m *PersonMutation) ResetAddresses() {
	m.addresses = nil
	m.clearedaddresses = false
	m.removedaddresses = nil
}

// Where appends a list predicates to the PersonMutation builder.
func (m *PersonMutation) Where(ps ...predicate.Person) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PersonMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PersonMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Person, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PersonMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PersonMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Person).
func (m *PersonMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PersonMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, person.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, person.FieldUpdatedAt)
	}
	if m.avatar_url != nil {
		fields = append(fields, person.FieldAvatarURL)
	}
	if m.email != nil {
		fields = append(fields, person.FieldEmail)
	}
	if m.name != nil {
		fields = append(fields, person.FieldName)
	}
	if m.phone != nil {
		fields = append(fields, person.FieldPhone)
	}
	if m.role != nil {
		fields = append(fields, person.FieldRole)
	}
	if m.password_hash != nil {
		fields = append(fields, person.FieldPasswordHash)
	}
	if m.is_email_verified != nil {
		fields = append(fields, person.FieldIsEmailVerified)
	}
	if m.is_phone_verified != nil {
		fields = append(fields, person.FieldIsPhoneVerified)
	}
	if m.work_unit != nil {
		fields = append(fields, person.FieldWorkUnitID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PersonMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case person.FieldCreatedAt:
		return m.CreatedAt()
	case person.FieldUpdatedAt:
		return m.UpdatedAt()
	case person.FieldAvatarURL:
		return m.AvatarURL()
	case person.FieldEmail:
		return m.Email()
	case person.FieldName:
		return m.Name()
	case person.FieldPhone:
		return m.Phone()
	case person.FieldRole:
		return m.Role()
	case person.FieldPasswordHash:
		return m.PasswordHash()
	case person.FieldIsEmailVerified:
		return m.IsEmailVerified()
	case person.FieldIsPhoneVerified:
		return m.IsPhoneVerified()
	case person.FieldWorkUnitID:
		return m.WorkUnitID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PersonMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case person.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case person.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case person.FieldAvatarURL:
		return m.OldAvatarURL(ctx)
	case person.FieldEmail:
		return m.OldEmail(ctx)
	case person.FieldName:
		return m.OldName(ctx)
	case person.FieldPhone:
		return m.OldPhone(ctx)
	case person.FieldRole:
		return m.OldRole(ctx)
	case person.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case person.FieldIsEmailVerified:
		return m.OldIsEmailVerified(ctx)
	case person.FieldIsPhoneVerified:
		return m.OldIsPhoneVerified(ctx)
	case person.FieldWorkUnitID:
		return m.OldWorkUnitID(ctx)
	}
	return nil, fmt.Errorf("unknown Person field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PersonMutation) SetField(name string, value ent.Value) error {
	switch name {
	case person.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case person.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case person.FieldAvatarURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarURL(v)
		return nil
	case person.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case person.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case person.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case person.FieldRole:
		v, ok := value.(person.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case person.FieldPasswordHash:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case person.FieldIsEmailVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsEmailVerified(v)
		return nil
	case person.FieldIsPhoneVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPhoneVerified(v)
		return nil
	case person.FieldWorkUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkUnitID(v)
		return nil
	}
	return fmt.Errorf("unknown Person field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PersonMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PersonMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PersonMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Person numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PersonMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(person.FieldAvatarURL) {
		fields = append(fields, person.FieldAvatarURL)
	}
	if m.FieldCleared(person.FieldPhone) {
		fields = append(fields, person.FieldPhone)
	}
	if m.FieldCleared(person.FieldPasswordHash) {
		fields = append(fields, person.FieldPasswordHash)
	}
	if m.FieldCleared(person.FieldWorkUnitID) {
		fields = append(fields, person.FieldWorkUnitID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PersonMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PersonMutation) ClearField(name string) error {
	switch name {
	case person.FieldAvatarURL:
		m.ClearAvatarURL()
		return nil
	case person.FieldPhone:
		m.ClearPhone()
		return nil
	case person.FieldPasswordHash:
		m.ClearPasswordHash()
		return nil
	case person.FieldWorkUnitID:
		m.ClearWorkUnitID()
		return nil
	}
	return fmt.Errorf("unknown Person nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PersonMutation) ResetField(name string) error {
	switch name {
	case person.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case person.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case person.FieldAvatarURL:
		m.ResetAvatarURL()
		return nil
	case person.FieldEmail:
		m.ResetEmail()
		return nil
	case person.FieldName:
		m.ResetName()
		return nil
	case person.FieldPhone:
		m.ResetPhone()
		return nil
	case person.FieldRole:
		m.ResetRole()
		return nil
	case person.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case person.FieldIsEmailVerified:
		m.ResetIsEmailVerified()
		return nil
	case person.FieldIsPhoneVerified:
		m.ResetIsPhoneVerified()
		return nil
	case person.FieldWorkUnitID:
		m.ResetWorkUnitID()
		return nil
	}
	return fmt.Errorf("unknown Person field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PersonMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.work_unit != nil {
		edges = append(edges, person.EdgeWorkUnit)
	}
	if m.addresses != nil {
		edges = append(edges, person.EdgeAddresses)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PersonMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case person.EdgeWorkUnit:
		if id := m.work_unit; id != nil {
			return []ent.Value{*id}
		}
	case person.EdgeAddresses:
		ids := make([]ent.Value, 0, len(m.addresses))
		for id := range m.addresses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PersonMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedaddresses != nil {
		edges = append(edges, person.EdgeAddresses)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PersonMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case person.EdgeAddresses:
		ids := make([]ent.Value, 0, len(m.removedaddresses))
		for id := range m.removedaddresses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PersonMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedwork_unit {
		edges = append(edges, person.EdgeWorkUnit)
	}
	if m.clearedaddresses {
		edges = append(edges, person.EdgeAddresses)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PersonMutation) EdgeCleared(name string) bool {
	switch name {
	case person.EdgeWorkUnit:
		return m.clearedwork_unit
	case person.EdgeAddresses:
		return m.clearedaddresses
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PersonMutation) ClearEdge(name string) error {
	switch name {
	case person.EdgeWorkUnit:
		m.ClearWorkUnit()
		return nil
	}
	return fmt.Errorf("unknown Person unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PersonMutation) ResetEdge(name string) error {
	switch name {
	case person.EdgeWorkUnit:
		m.ResetWorkUnit()
		return nil
	case person.EdgeAddresses:
		m.ResetAddresses()
		return nil
	}
	return fmt.Errorf("unknown Person edge %s", name)
}

// PersonAddressMutation represents an operation that mutates the PersonAddress nodes in the graph.
type PersonAddressMutation struct {
	config
	op               Op
	typ              string
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	persons          *uuid.UUID
	clearedpersons   bool
	addresses        *string
	clearedaddresses bool
	done             bool
	oldValue         func(context.Context) (*PersonAddress, error)
	predicates       []predicate.PersonAddress
}

var _ ent.Mutation = (*PersonAddressMutation)(nil)

// personaddressOption allows management of the mutation configuration using functional options.
type personaddressOption func(*PersonAddressMutation)

// newPersonAddressMutation creates new mutation for the PersonAddress entity.
func newPersonAddressMutation(c config, op Op, opts ...personaddressOption) *PersonAddressMutation {
	m := &PersonAddressMutation{
		config:        c,
		op:            op,
		typ:           TypePersonAddress,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PersonAddressMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PersonAddressMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PersonAddressMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PersonAddressMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PersonAddressMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PersonAddressMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PersonAddressMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PersonAddressMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetPersonID sets the "person_id" field.
func (m *PersonAddressMutation) SetPersonID(u uuid.UUID) {
	m.persons = &u
}

// PersonID returns the value of the "person_id" field in the mutation.
func (m *PersonAddressMutation) PersonID() (r uuid.UUID, exists bool) {
	v := m.persons
	if v == nil {
		return
	}
	return *v, true
}

// ResetPersonID resets all changes to the "person_id" field.
func (m *PersonAddressMutation) ResetPersonID() {
	m.persons = nil
}

// SetAddressID sets the "address_id" field.
func (m *PersonAddressMutation) SetAddressID(s string) {
	m.addresses = &s
}

// AddressID returns the value of the "address_id" field in the mutation.
func (m *PersonAddressMutation) AddressID() (r string, exists bool) {
	v := m.addresses
	if v == nil {
		return
	}
	return *v, true
}

// ResetAddressID resets all changes to the "address_id" field.
func (m *PersonAddressMutation) ResetAddressID() {
	m.addresses = nil
}

// SetPersonsID sets the "persons" edge to the Person entity by id.
func (m *PersonAddressMutation) SetPersonsID(id uuid.UUID) {
	m.persons = &id
}

// ClearPersons clears the "persons" edge to the Person entity.
func (m *PersonAddressMutation) ClearPersons() {
	m.clearedpersons = true
	m.clearedFields[personaddress.FieldPersonID] = struct{}{}
}

// PersonsCleared reports if the "persons" edge to the Person entity was cleared.
func (m *PersonAddressMutation) PersonsCleared() bool {
	return m.clearedpersons
}

// PersonsID returns the "persons" edge ID in the mutation.
func (m *PersonAddressMutation) PersonsID() (id uuid.UUID, exists bool) {
	if m.persons != nil {
		return *m.persons, true
	}
	return
}

// PersonsIDs returns the "persons" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PersonsID instead. It exists only for internal usage by the builders.
func (m *PersonAddressMutation) PersonsIDs() (ids []uuid.UUID) {
	if id := m.persons; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPersons resets all changes to the "persons" edge.
func (m *PersonAddressMutation) ResetPersons() {
	m.persons = nil
	m.clearedpersons = false
}

// SetAddressesID sets the "addresses" edge to the Address entity by id.
func (m *PersonAddressMutation) SetAddressesID(id string) {
	m.addresses = &id
}

// ClearAddresses clears the "addresses" edge to the Address entity.
func (m *PersonAddressMutation) ClearAddresses() {
	m.clearedaddresses = true
	m.clearedFields[personaddress.FieldAddressID] = struct{}{}
}

// AddressesCleared reports if the "addresses" edge to the Address entity was cleared.
func (m *PersonAddressMutation) AddressesCleared() bool {
	return m.clearedaddresses
}

// AddressesID returns the "addresses" edge ID in the mutation.
func (m *PersonAddressMutation) AddressesID() (id string, exists bool) {
	if m.addresses != nil {
		return *m.addresses, true
	}
	return
}

// AddressesIDs returns the "addresses" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AddressesID instead. It exists only for internal usage by the builders.
func (m *PersonAddressMutation) AddressesIDs() (ids []string) {
	if id := m.addresses; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAddresses resets all changes to the "addresses" edge.
func (m *PersonAddressMutation) ResetAddresses() {
	m.addresses = nil
	m.clearedaddresses = false
}

// Where appends a list predicates to the PersonAddressMutation builder.
func (m *PersonAddressMutation) Where(ps ...predicate.PersonAddress) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PersonAddressMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PersonAddressMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PersonAddress, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PersonAddressMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PersonAddressMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PersonAddress).
func (m *PersonAddressMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PersonAddressMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, personaddress.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, personaddress.FieldUpdatedAt)
	}
	if m.persons != nil {
		fields = append(fields, personaddress.FieldPersonID)
	}
	if m.addresses != nil {
		fields = append(fields, personaddress.FieldAddressID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PersonAddressMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case personaddress.FieldCreatedAt:
		return m.CreatedAt()
	case personaddress.FieldUpdatedAt:
		return m.UpdatedAt()
	case personaddress.FieldPersonID:
		return m.PersonID()
	case personaddress.FieldAddressID:
		return m.AddressID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PersonAddressMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, errors.New("edge schema PersonAddress does not support getting old values")
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PersonAddressMutation) SetField(name string, value ent.Value) error {
	switch name {
	case personaddress.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case personaddress.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case personaddress.FieldPersonID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPersonID(v)
		return nil
	case personaddress.FieldAddressID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddressID(v)
		return nil
	}
	return fmt.Errorf("unknown PersonAddress field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PersonAddressMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PersonAddressMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PersonAddressMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PersonAddress numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PersonAddressMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PersonAddressMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PersonAddressMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PersonAddress nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PersonAddressMutation) ResetField(name string) error {
	switch name {
	case personaddress.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case personaddress.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case personaddress.FieldPersonID:
		m.ResetPersonID()
		return nil
	case personaddress.FieldAddressID:
		m.ResetAddressID()
		return nil
	}
	return fmt.Errorf("unknown PersonAddress field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PersonAddressMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.persons != nil {
		edges = append(edges, personaddress.EdgePersons)
	}
	if m.addresses != nil {
		edges = append(edges, personaddress.EdgeAddresses)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PersonAddressMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case personaddress.EdgePersons:
		if id := m.persons; id != nil {
			return []ent.Value{*id}
		}
	case personaddress.EdgeAddresses:
		if id := m.addresses; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PersonAddressMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PersonAddressMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PersonAddressMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedpersons {
		edges = append(edges, personaddress.EdgePersons)
	}
	if m.clearedaddresses {
		edges = append(edges, personaddress.EdgeAddresses)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PersonAddressMutation) EdgeCleared(name string) bool {
	switch name {
	case personaddress.EdgePersons:
		return m.clearedpersons
	case personaddress.EdgeAddresses:
		return m.clearedaddresses
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PersonAddressMutation) ClearEdge(name string) error {
	switch name {
	case personaddress.EdgePersons:
		m.ClearPersons()
		return nil
	case personaddress.EdgeAddresses:
		m.ClearAddresses()
		return nil
	}
	return fmt.Errorf("unknown PersonAddress unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PersonAddressMutation) ResetEdge(name string) error {
	switch name {
	case personaddress.EdgePersons:
		m.ResetPersons()
		return nil
	case personaddress.EdgeAddresses:
		m.ResetAddresses()
		return nil
	}
	return fmt.Errorf("unknown PersonAddress edge %s", name)
}

// ProductColorMutation represents an operation that mutates the ProductColor nodes in the graph.
type ProductColorMutation struct {
	config
	op            Op
	typ           string
	id            *string
	created_at    *time.Time
	updated_at    *time.Time
	name          *string
	color_code    *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ProductColor, error)
	predicates    []predicate.ProductColor
}

var _ ent.Mutation = (*ProductColorMutation)(nil)

// productcolorOption allows management of the mutation configuration using functional options.
type productcolorOption func(*ProductColorMutation)

// newProductColorMutation creates new mutation for the ProductColor entity.
func newProductColorMutation(c config, op Op, opts ...productcolorOption) *ProductColorMutation {
	m := &ProductColorMutation{
		config:        c,
		op:            op,
		typ:           TypeProductColor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductColorID sets the ID field of the mutation.
func withProductColorID(id string) productcolorOption {
	return func(m *ProductColorMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductColor
		)
		m.oldValue = func(ctx context.Context) (*ProductColor, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductColor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductColor sets the old ProductColor of the mutation.
func withProductColor(node *ProductColor) productcolorOption {
	return func(m *ProductColorMutation) {
		m.oldValue = func(context.Context) (*ProductColor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductColorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductColorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProductColor entities.
func (m *ProductColorMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductColorMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductColorMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProductColor.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProductColorMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProductColorMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProductColor entity.
// If the ProductColor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductColorMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProductColorMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProductColorMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProductColorMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProductColor entity.
// If the ProductColor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductColorMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProductColorMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *ProductColorMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProductColorMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ProductColor entity.
// If the ProductColor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductColorMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProductColorMutation) ResetName() {
	m.name = nil
}

// SetColorCode sets the "color_code" field.
func (m *ProductColorMutation) SetColorCode(s string) {
	m.color_code = &s
}

// ColorCode returns the value of the "color_code" field in the mutation.
func (m *ProductColorMutation) ColorCode() (r string, exists bool) {
	v := m.color_code
	if v == nil {
		return
	}
	return *v, true
}

// OldColorCode returns the old "color_code" field's value of the ProductColor entity.
// If the ProductColor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductColorMutation) OldColorCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColorCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColorCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColorCode: %w", err)
	}
	return oldValue.ColorCode, nil
}

// ResetColorCode resets all changes to the "color_code" field.
func (m *ProductColorMutation) ResetColorCode() {
	m.color_code = nil
}

// Where appends a list predicates to the ProductColorMutation builder.
func (m *ProductColorMutation) Where(ps ...predicate.ProductColor) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductColorMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductColorMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProductColor, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductColorMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductColorMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProductColor).
func (m *ProductColorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductColorMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, productcolor.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, productcolor.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, productcolor.FieldName)
	}
	if m.color_code != nil {
		fields = append(fields, productcolor.FieldColorCode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductColorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productcolor.FieldCreatedAt:
		return m.CreatedAt()
	case productcolor.FieldUpdatedAt:
		return m.UpdatedAt()
	case productcolor.FieldName:
		return m.Name()
	case productcolor.FieldColorCode:
		return m.ColorCode()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductColorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productcolor.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case productcolor.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case productcolor.FieldName:
		return m.OldName(ctx)
	case productcolor.FieldColorCode:
		return m.OldColorCode(ctx)
	}
	return nil, fmt.Errorf("unknown ProductColor field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductColorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productcolor.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case productcolor.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case productcolor.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case productcolor.FieldColorCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColorCode(v)
		return nil
	}
	return fmt.Errorf("unknown ProductColor field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductColorMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductColorMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductColorMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProductColor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductColorMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductColorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductColorMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProductColor nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductColorMutation) ResetField(name string) error {
	switch name {
	case productcolor.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case productcolor.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case productcolor.FieldName:
		m.ResetName()
		return nil
	case productcolor.FieldColorCode:
		m.ResetColorCode()
		return nil
	}
	return fmt.Errorf("unknown ProductColor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductColorMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductColorMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductColorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductColorMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductColorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductColorMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductColorMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ProductColor unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductColorMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ProductColor edge %s", name)
}

// ProductImageMutation represents an operation that mutates the ProductImage nodes in the graph.
type ProductImageMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	created_at     *time.Time
	updated_at     *time.Time
	image_url      *string
	clearedFields  map[string]struct{}
	product        *string
	clearedproduct bool
	done           bool
	oldValue       func(context.Context) (*ProductImage, error)
	predicates     []predicate.ProductImage
}

var _ ent.Mutation = (*ProductImageMutation)(nil)

// productimageOption allows management of the mutation configuration using functional options.
type productimageOption func(*ProductImageMutation)

// newProductImageMutation creates new mutation for the ProductImage entity.
func newProductImageMutation(c config, op Op, opts ...productimageOption) *ProductImageMutation {
	m := &ProductImageMutation{
		config:        c,
		op:            op,
		typ:           TypeProductImage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductImageID sets the ID field of the mutation.
func withProductImageID(id uuid.UUID) productimageOption {
	return func(m *ProductImageMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductImage
		)
		m.oldValue = func(ctx context.Context) (*ProductImage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductImage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductImage sets the old ProductImage of the mutation.
func withProductImage(node *ProductImage) productimageOption {
	return func(m *ProductImageMutation) {
		m.oldValue = func(context.Context) (*ProductImage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductImageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductImageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProductImage entities.
func (m *ProductImageMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductImageMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductImageMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProductImage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProductImageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProductImageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProductImage entity.
// If the ProductImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductImageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProductImageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProductImageMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProductImageMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProductImage entity.
// If the ProductImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductImageMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProductImageMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetProductID sets the "product_id" field.
func (m *ProductImageMutation) SetProductID(s string) {
	m.product = &s
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *ProductImageMutation) ProductID() (r string, exists bool) {
	v := m.product
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the ProductImage entity.
// If the ProductImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductImageMutation) OldProductID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// ResetProductID resets all changes to the "product_id" field.
func (m *ProductImageMutation) ResetProductID() {
	m.product = nil
}

// SetImageURL sets the "image_url" field.
func (m *ProductImageMutation) SetImageURL(s string) {
	m.image_url = &s
}

// ImageURL returns the value of the "image_url" field in the mutation.
func (m *ProductImageMutation) ImageURL() (r string, exists bool) {
	v := m.image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldImageURL returns the old "image_url" field's value of the ProductImage entity.
// If the ProductImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductImageMutation) OldImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImageURL: %w", err)
	}
	return oldValue.ImageURL, nil
}

// ResetImageURL resets all changes to the "image_url" field.
func (m *ProductImageMutation) ResetImageURL() {
	m.image_url = nil
}

// ClearProduct clears the "product" edge to the ProductInfo entity.
func (m *ProductImageMutation) ClearProduct() {
	m.clearedproduct = true
	m.clearedFields[productimage.FieldProductID] = struct{}{}
}

// ProductCleared reports if the "product" edge to the ProductInfo entity was cleared.
func (m *ProductImageMutation) ProductCleared() bool {
	return m.clearedproduct
}

// ProductIDs returns the "product" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductID instead. It exists only for internal usage by the builders.
func (m *ProductImageMutation) ProductIDs() (ids []string) {
	if id := m.product; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProduct resets all changes to the "product" edge.
func (m *ProductImageMutation) ResetProduct() {
	m.product = nil
	m.clearedproduct = false
}

// Where appends a list predicates to the ProductImageMutation builder.
func (m *ProductImageMutation) Where(ps ...predicate.ProductImage) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductImageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductImageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProductImage, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductImageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductImageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProductImage).
func (m *ProductImageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductImageMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, productimage.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, productimage.FieldUpdatedAt)
	}
	if m.product != nil {
		fields = append(fields, productimage.FieldProductID)
	}
	if m.image_url != nil {
		fields = append(fields, productimage.FieldImageURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductImageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productimage.FieldCreatedAt:
		return m.CreatedAt()
	case productimage.FieldUpdatedAt:
		return m.UpdatedAt()
	case productimage.FieldProductID:
		return m.ProductID()
	case productimage.FieldImageURL:
		return m.ImageURL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductImageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productimage.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case productimage.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case productimage.FieldProductID:
		return m.OldProductID(ctx)
	case productimage.FieldImageURL:
		return m.OldImageURL(ctx)
	}
	return nil, fmt.Errorf("unknown ProductImage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductImageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productimage.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case productimage.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case productimage.FieldProductID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case productimage.FieldImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImageURL(v)
		return nil
	}
	return fmt.Errorf("unknown ProductImage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductImageMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductImageMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductImageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProductImage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductImageMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductImageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductImageMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProductImage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductImageMutation) ResetField(name string) error {
	switch name {
	case productimage.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case productimage.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case productimage.FieldProductID:
		m.ResetProductID()
		return nil
	case productimage.FieldImageURL:
		m.ResetImageURL()
		return nil
	}
	return fmt.Errorf("unknown ProductImage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductImageMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.product != nil {
		edges = append(edges, productimage.EdgeProduct)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductImageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case productimage.EdgeProduct:
		if id := m.product; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductImageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductImageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductImageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedproduct {
		edges = append(edges, productimage.EdgeProduct)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductImageMutation) EdgeCleared(name string) bool {
	switch name {
	case productimage.EdgeProduct:
		return m.clearedproduct
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductImageMutation) ClearEdge(name string) error {
	switch name {
	case productimage.EdgeProduct:
		m.ClearProduct()
		return nil
	}
	return fmt.Errorf("unknown ProductImage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductImageMutation) ResetEdge(name string) error {
	switch name {
	case productimage.EdgeProduct:
		m.ResetProduct()
		return nil
	}
	return fmt.Errorf("unknown ProductImage edge %s", name)
}

// ProductInfoMutation represents an operation that mutates the ProductInfo nodes in the graph.
type ProductInfoMutation struct {
	config
	op            Op
	typ           string
	id            *string
	created_at    *time.Time
	updated_at    *time.Time
	name          *string
	description   *string
	year          *int
	addyear       *int
	provider      *string
	clearedFields map[string]struct{}
	tags          map[string]struct{}
	removedtags   map[string]struct{}
	clearedtags   bool
	done          bool
	oldValue      func(context.Context) (*ProductInfo, error)
	predicates    []predicate.ProductInfo
}

var _ ent.Mutation = (*ProductInfoMutation)(nil)

// productinfoOption allows management of the mutation configuration using functional options.
type productinfoOption func(*ProductInfoMutation)

// newProductInfoMutation creates new mutation for the ProductInfo entity.
func newProductInfoMutation(c config, op Op, opts ...productinfoOption) *ProductInfoMutation {
	m := &ProductInfoMutation{
		config:        c,
		op:            op,
		typ:           TypeProductInfo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductInfoID sets the ID field of the mutation.
func withProductInfoID(id string) productinfoOption {
	return func(m *ProductInfoMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductInfo
		)
		m.oldValue = func(ctx context.Context) (*ProductInfo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductInfo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductInfo sets the old ProductInfo of the mutation.
func withProductInfo(node *ProductInfo) productinfoOption {
	return func(m *ProductInfoMutation) {
		m.oldValue = func(context.Context) (*ProductInfo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductInfoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductInfoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProductInfo entities.
func (m *ProductInfoMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductInfoMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductInfoMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProductInfo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProductInfoMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProductInfoMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProductInfo entity.
// If the ProductInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductInfoMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProductInfoMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProductInfoMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProductInfoMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProductInfo entity.
// If the ProductInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductInfoMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProductInfoMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *ProductInfoMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProductInfoMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ProductInfo entity.
// If the ProductInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductInfoMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProductInfoMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ProductInfoMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProductInfoMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ProductInfo entity.
// If the ProductInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductInfoMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProductInfoMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[productinfo.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProductInfoMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[productinfo.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProductInfoMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, productinfo.FieldDescription)
}

// SetYear sets the "year" field.
func (m *ProductInfoMutation) SetYear(i int) {
	m.year = &i
	m.addyear = nil
}

// Year returns the value of the "year" field in the mutation.
func (m *ProductInfoMutation) Year() (r int, exists bool) {
	v := m.year
	if v == nil {
		return
	}
	return *v, true
}

// OldYear returns the old "year" field's value of the ProductInfo entity.
// If the ProductInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductInfoMutation) OldYear(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYear is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYear: %w", err)
	}
	return oldValue.Year, nil
}

// AddYear adds i to the "year" field.
func (m *ProductInfoMutation) AddYear(i int) {
	if m.addyear != nil {
		*m.addyear += i
	} else {
		m.addyear = &i
	}
}

// AddedYear returns the value that was added to the "year" field in this mutation.
func (m *ProductInfoMutation) AddedYear() (r int, exists bool) {
	v := m.addyear
	if v == nil {
		return
	}
	return *v, true
}

// ClearYear clears the value of the "year" field.
func (m *ProductInfoMutation) ClearYear() {
	m.year = nil
	m.addyear = nil
	m.clearedFields[productinfo.FieldYear] = struct{}{}
}

// YearCleared returns if the "year" field was cleared in this mutation.
func (m *ProductInfoMutation) YearCleared() bool {
	_, ok := m.clearedFields[productinfo.FieldYear]
	return ok
}

// ResetYear resets all changes to the "year" field.
func (m *ProductInfoMutation) ResetYear() {
	m.year = nil
	m.addyear = nil
	delete(m.clearedFields, productinfo.FieldYear)
}

// SetProvider sets the "provider" field.
func (m *ProductInfoMutation) SetProvider(s string) {
	m.provider = &s
}

// Provider returns the value of the "provider" field in the mutation.
func (m *ProductInfoMutation) Provider() (r string, exists bool) {
	v := m.provider
	if v == nil {
		return
	}
	return *v, true
}

// OldProvider returns the old "provider" field's value of the ProductInfo entity.
// If the ProductInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductInfoMutation) OldProvider(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvider is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvider requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvider: %w", err)
	}
	return oldValue.Provider, nil
}

// ClearProvider clears the value of the "provider" field.
func (m *ProductInfoMutation) ClearProvider() {
	m.provider = nil
	m.clearedFields[productinfo.FieldProvider] = struct{}{}
}

// ProviderCleared returns if the "provider" field was cleared in this mutation.
func (m *ProductInfoMutation) ProviderCleared() bool {
	_, ok := m.clearedFields[productinfo.FieldProvider]
	return ok
}

// ResetProvider resets all changes to the "provider" field.
func (m *ProductInfoMutation) ResetProvider() {
	m.provider = nil
	delete(m.clearedFields, productinfo.FieldProvider)
}

// AddTagIDs adds the "tags" edge to the Tag entity by ids.
func (m *ProductInfoMutation) AddTagIDs(ids ...string) {
	if m.tags == nil {
		m.tags = make(map[string]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the Tag entity.
func (m *ProductInfoMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the Tag entity was cleared.
func (m *ProductInfoMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the Tag entity by IDs.
func (m *ProductInfoMutation) RemoveTagIDs(ids ...string) {
	if m.removedtags == nil {
		m.removedtags = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the Tag entity.
func (m *ProductInfoMutation) RemovedTagsIDs() (ids []string) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *ProductInfoMutation) TagsIDs() (ids []string) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *ProductInfoMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// Where appends a list predicates to the ProductInfoMutation builder.
func (m *ProductInfoMutation) Where(ps ...predicate.ProductInfo) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductInfoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductInfoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProductInfo, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductInfoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductInfoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProductInfo).
func (m *ProductInfoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductInfoMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, productinfo.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, productinfo.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, productinfo.FieldName)
	}
	if m.description != nil {
		fields = append(fields, productinfo.FieldDescription)
	}
	if m.year != nil {
		fields = append(fields, productinfo.FieldYear)
	}
	if m.provider != nil {
		fields = append(fields, productinfo.FieldProvider)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductInfoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productinfo.FieldCreatedAt:
		return m.CreatedAt()
	case productinfo.FieldUpdatedAt:
		return m.UpdatedAt()
	case productinfo.FieldName:
		return m.Name()
	case productinfo.FieldDescription:
		return m.Description()
	case productinfo.FieldYear:
		return m.Year()
	case productinfo.FieldProvider:
		return m.Provider()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductInfoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productinfo.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case productinfo.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case productinfo.FieldName:
		return m.OldName(ctx)
	case productinfo.FieldDescription:
		return m.OldDescription(ctx)
	case productinfo.FieldYear:
		return m.OldYear(ctx)
	case productinfo.FieldProvider:
		return m.OldProvider(ctx)
	}
	return nil, fmt.Errorf("unknown ProductInfo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductInfoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productinfo.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case productinfo.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case productinfo.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case productinfo.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case productinfo.FieldYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYear(v)
		return nil
	case productinfo.FieldProvider:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvider(v)
		return nil
	}
	return fmt.Errorf("unknown ProductInfo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductInfoMutation) AddedFields() []string {
	var fields []string
	if m.addyear != nil {
		fields = append(fields, productinfo.FieldYear)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductInfoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case productinfo.FieldYear:
		return m.AddedYear()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductInfoMutation) AddField(name string, value ent.Value) error {
	switch name {
	case productinfo.FieldYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddYear(v)
		return nil
	}
	return fmt.Errorf("unknown ProductInfo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductInfoMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(productinfo.FieldDescription) {
		fields = append(fields, productinfo.FieldDescription)
	}
	if m.FieldCleared(productinfo.FieldYear) {
		fields = append(fields, productinfo.FieldYear)
	}
	if m.FieldCleared(productinfo.FieldProvider) {
		fields = append(fields, productinfo.FieldProvider)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductInfoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductInfoMutation) ClearField(name string) error {
	switch name {
	case productinfo.FieldDescription:
		m.ClearDescription()
		return nil
	case productinfo.FieldYear:
		m.ClearYear()
		return nil
	case productinfo.FieldProvider:
		m.ClearProvider()
		return nil
	}
	return fmt.Errorf("unknown ProductInfo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductInfoMutation) ResetField(name string) error {
	switch name {
	case productinfo.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case productinfo.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case productinfo.FieldName:
		m.ResetName()
		return nil
	case productinfo.FieldDescription:
		m.ResetDescription()
		return nil
	case productinfo.FieldYear:
		m.ResetYear()
		return nil
	case productinfo.FieldProvider:
		m.ResetProvider()
		return nil
	}
	return fmt.Errorf("unknown ProductInfo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductInfoMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tags != nil {
		edges = append(edges, productinfo.EdgeTags)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductInfoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case productinfo.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductInfoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedtags != nil {
		edges = append(edges, productinfo.EdgeTags)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductInfoMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case productinfo.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductInfoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtags {
		edges = append(edges, productinfo.EdgeTags)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductInfoMutation) EdgeCleared(name string) bool {
	switch name {
	case productinfo.EdgeTags:
		return m.clearedtags
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductInfoMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ProductInfo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductInfoMutation) ResetEdge(name string) error {
	switch name {
	case productinfo.EdgeTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown ProductInfo edge %s", name)
}

// ProductQtyMutation represents an operation that mutates the ProductQty nodes in the graph.
type ProductQtyMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	price_per_unit       *decimal.Decimal
	addprice_per_unit    *decimal.Decimal
	qty                  *decimal.Decimal
	addqty               *decimal.Decimal
	clearedFields        map[string]struct{}
	work_unit            *uuid.UUID
	clearedwork_unit     bool
	product              *string
	clearedproduct       bool
	product_color        *string
	clearedproduct_color bool
	done                 bool
	oldValue             func(context.Context) (*ProductQty, error)
	predicates           []predicate.ProductQty
}

var _ ent.Mutation = (*ProductQtyMutation)(nil)

// productqtyOption allows management of the mutation configuration using functional options.
type productqtyOption func(*ProductQtyMutation)

// newProductQtyMutation creates new mutation for the ProductQty entity.
func newProductQtyMutation(c config, op Op, opts ...productqtyOption) *ProductQtyMutation {
	m := &ProductQtyMutation{
		config:        c,
		op:            op,
		typ:           TypeProductQty,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductQtyID sets the ID field of the mutation.
func withProductQtyID(id uuid.UUID) productqtyOption {
	return func(m *ProductQtyMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductQty
		)
		m.oldValue = func(ctx context.Context) (*ProductQty, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductQty.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductQty sets the old ProductQty of the mutation.
func withProductQty(node *ProductQty) productqtyOption {
	return func(m *ProductQtyMutation) {
		m.oldValue = func(context.Context) (*ProductQty, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductQtyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductQtyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProductQty entities.
func (m *ProductQtyMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductQtyMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductQtyMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProductQty.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProductQtyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProductQtyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProductQty entity.
// If the ProductQty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductQtyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProductQtyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProductQtyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProductQtyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProductQty entity.
// If the ProductQty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductQtyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProductQtyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetWorkUnitID sets the "work_unit_id" field.
func (m *ProductQtyMutation) SetWorkUnitID(u uuid.UUID) {
	m.work_unit = &u
}

// WorkUnitID returns the value of the "work_unit_id" field in the mutation.
func (m *ProductQtyMutation) WorkUnitID() (r uuid.UUID, exists bool) {
	v := m.work_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkUnitID returns the old "work_unit_id" field's value of the ProductQty entity.
// If the ProductQty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductQtyMutation) OldWorkUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkUnitID: %w", err)
	}
	return oldValue.WorkUnitID, nil
}

// ResetWorkUnitID resets all changes to the "work_unit_id" field.
func (m *ProductQtyMutation) ResetWorkUnitID() {
	m.work_unit = nil
}

// SetProductID sets the "product_id" field.
func (m *ProductQtyMutation) SetProductID(s string) {
	m.product = &s
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *ProductQtyMutation) ProductID() (r string, exists bool) {
	v := m.product
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the ProductQty entity.
// If the ProductQty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductQtyMutation) OldProductID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// ResetProductID resets all changes to the "product_id" field.
func (m *ProductQtyMutation) ResetProductID() {
	m.product = nil
}

// SetProductColorID sets the "product_color_id" field.
func (m *ProductQtyMutation) SetProductColorID(s string) {
	m.product_color = &s
}

// ProductColorID returns the value of the "product_color_id" field in the mutation.
func (m *ProductQtyMutation) ProductColorID() (r string, exists bool) {
	v := m.product_color
	if v == nil {
		return
	}
	return *v, true
}

// OldProductColorID returns the old "product_color_id" field's value of the ProductQty entity.
// If the ProductQty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductQtyMutation) OldProductColorID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductColorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductColorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductColorID: %w", err)
	}
	return oldValue.ProductColorID, nil
}

// ResetProductColorID resets all changes to the "product_color_id" field.
func (m *ProductQtyMutation) ResetProductColorID() {
	m.product_color = nil
}

// SetPricePerUnit sets the "price_per_unit" field.
func (m *ProductQtyMutation) SetPricePerUnit(d decimal.Decimal) {
	m.price_per_unit = &d
	m.addprice_per_unit = nil
}

// PricePerUnit returns the value of the "price_per_unit" field in the mutation.
func (m *ProductQtyMutation) PricePerUnit() (r decimal.Decimal, exists bool) {
	v := m.price_per_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldPricePerUnit returns the old "price_per_unit" field's value of the ProductQty entity.
// If the ProductQty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductQtyMutation) OldPricePerUnit(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPricePerUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPricePerUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPricePerUnit: %w", err)
	}
	return oldValue.PricePerUnit, nil
}

// AddPricePerUnit adds d to the "price_per_unit" field.
func (m *ProductQtyMutation) AddPricePerUnit(d decimal.Decimal) {
	if m.addprice_per_unit != nil {
		*m.addprice_per_unit = m.addprice_per_unit.Add(d)
	} else {
		m.addprice_per_unit = &d
	}
}

// AddedPricePerUnit returns the value that was added to the "price_per_unit" field in this mutation.
func (m *ProductQtyMutation) AddedPricePerUnit() (r decimal.Decimal, exists bool) {
	v := m.addprice_per_unit
	if v == nil {
		return
	}
	return *v, true
}

// ResetPricePerUnit resets all changes to the "price_per_unit" field.
func (m *ProductQtyMutation) ResetPricePerUnit() {
	m.price_per_unit = nil
	m.addprice_per_unit = nil
}

// SetQty sets the "qty" field.
func (m *ProductQtyMutation) SetQty(d decimal.Decimal) {
	m.qty = &d
	m.addqty = nil
}

// Qty returns the value of the "qty" field in the mutation.
func (m *ProductQtyMutation) Qty() (r decimal.Decimal, exists bool) {
	v := m.qty
	if v == nil {
		return
	}
	return *v, true
}

// OldQty returns the old "qty" field's value of the ProductQty entity.
// If the ProductQty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductQtyMutation) OldQty(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQty: %w", err)
	}
	return oldValue.Qty, nil
}

// AddQty adds d to the "qty" field.
func (m *ProductQtyMutation) AddQty(d decimal.Decimal) {
	if m.addqty != nil {
		*m.addqty = m.addqty.Add(d)
	} else {
		m.addqty = &d
	}
}

// AddedQty returns the value that was added to the "qty" field in this mutation.
func (m *ProductQtyMutation) AddedQty() (r decimal.Decimal, exists bool) {
	v := m.addqty
	if v == nil {
		return
	}
	return *v, true
}

// ResetQty resets all changes to the "qty" field.
func (m *ProductQtyMutation) ResetQty() {
	m.qty = nil
	m.addqty = nil
}

// ClearWorkUnit clears the "work_unit" edge to the WorkUnitInfo entity.
func (m *ProductQtyMutation) ClearWorkUnit() {
	m.clearedwork_unit = true
	m.clearedFields[productqty.FieldWorkUnitID] = struct{}{}
}

// WorkUnitCleared reports if the "work_unit" edge to the WorkUnitInfo entity was cleared.
func (m *ProductQtyMutation) WorkUnitCleared() bool {
	return m.clearedwork_unit
}

// WorkUnitIDs returns the "work_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkUnitID instead. It exists only for internal usage by the builders.
func (m *ProductQtyMutation) WorkUnitIDs() (ids []uuid.UUID) {
	if id := m.work_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkUnit resets all changes to the "work_unit" edge.
func (m *ProductQtyMutation) ResetWorkUnit() {
	m.work_unit = nil
	m.clearedwork_unit = false
}

// ClearProduct clears the "product" edge to the ProductInfo entity.
func (m *ProductQtyMutation) ClearProduct() {
	m.clearedproduct = true
	m.clearedFields[productqty.FieldProductID] = struct{}{}
}

// ProductCleared reports if the "product" edge to the ProductInfo entity was cleared.
func (m *ProductQtyMutation) ProductCleared() bool {
	return m.clearedproduct
}

// ProductIDs returns the "product" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductID instead. It exists only for internal usage by the builders.
func (m *ProductQtyMutation) ProductIDs() (ids []string) {
	if id := m.product; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProduct resets all changes to the "product" edge.
func (m *ProductQtyMutation) ResetProduct() {
	m.product = nil
	m.clearedproduct = false
}

// ClearProductColor clears the "product_color" edge to the ProductColor entity.
func (m *ProductQtyMutation) ClearProductColor() {
	m.clearedproduct_color = true
	m.clearedFields[productqty.FieldProductColorID] = struct{}{}
}

// ProductColorCleared reports if the "product_color" edge to the ProductColor entity was cleared.
func (m *ProductQtyMutation) ProductColorCleared() bool {
	return m.clearedproduct_color
}

// ProductColorIDs returns the "product_color" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductColorID instead. It exists only for internal usage by the builders.
func (m *ProductQtyMutation) ProductColorIDs() (ids []string) {
	if id := m.product_color; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProductColor resets all changes to the "product_color" edge.
func (m *ProductQtyMutation) ResetProductColor() {
	m.product_color = nil
	m.clearedproduct_color = false
}

// Where appends a list predicates to the ProductQtyMutation builder.
func (m *ProductQtyMutation) Where(ps ...predicate.ProductQty) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductQtyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductQtyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProductQty, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductQtyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductQtyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProductQty).
func (m *ProductQtyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductQtyMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, productqty.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, productqty.FieldUpdatedAt)
	}
	if m.work_unit != nil {
		fields = append(fields, productqty.FieldWorkUnitID)
	}
	if m.product != nil {
		fields = append(fields, productqty.FieldProductID)
	}
	if m.product_color != nil {
		fields = append(fields, productqty.FieldProductColorID)
	}
	if m.price_per_unit != nil {
		fields = append(fields, productqty.FieldPricePerUnit)
	}
	if m.qty != nil {
		fields = append(fields, productqty.FieldQty)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductQtyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productqty.FieldCreatedAt:
		return m.CreatedAt()
	case productqty.FieldUpdatedAt:
		return m.UpdatedAt()
	case productqty.FieldWorkUnitID:
		return m.WorkUnitID()
	case productqty.FieldProductID:
		return m.ProductID()
	case productqty.FieldProductColorID:
		return m.ProductColorID()
	case productqty.FieldPricePerUnit:
		return m.PricePerUnit()
	case productqty.FieldQty:
		return m.Qty()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductQtyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productqty.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case productqty.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case productqty.FieldWorkUnitID:
		return m.OldWorkUnitID(ctx)
	case productqty.FieldProductID:
		return m.OldProductID(ctx)
	case productqty.FieldProductColorID:
		return m.OldProductColorID(ctx)
	case productqty.FieldPricePerUnit:
		return m.OldPricePerUnit(ctx)
	case productqty.FieldQty:
		return m.OldQty(ctx)
	}
	return nil, fmt.Errorf("unknown ProductQty field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductQtyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productqty.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case productqty.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case productqty.FieldWorkUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkUnitID(v)
		return nil
	case productqty.FieldProductID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case productqty.FieldProductColorID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductColorID(v)
		return nil
	case productqty.FieldPricePerUnit:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPricePerUnit(v)
		return nil
	case productqty.FieldQty:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQty(v)
		return nil
	}
	return fmt.Errorf("unknown ProductQty field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductQtyMutation) AddedFields() []string {
	var fields []string
	if m.addprice_per_unit != nil {
		fields = append(fields, productqty.FieldPricePerUnit)
	}
	if m.addqty != nil {
		fields = append(fields, productqty.FieldQty)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductQtyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case productqty.FieldPricePerUnit:
		return m.AddedPricePerUnit()
	case productqty.FieldQty:
		return m.AddedQty()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductQtyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case productqty.FieldPricePerUnit:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPricePerUnit(v)
		return nil
	case productqty.FieldQty:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQty(v)
		return nil
	}
	return fmt.Errorf("unknown ProductQty numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductQtyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductQtyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductQtyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProductQty nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductQtyMutation) ResetField(name string) error {
	switch name {
	case productqty.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case productqty.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case productqty.FieldWorkUnitID:
		m.ResetWorkUnitID()
		return nil
	case productqty.FieldProductID:
		m.ResetProductID()
		return nil
	case productqty.FieldProductColorID:
		m.ResetProductColorID()
		return nil
	case productqty.FieldPricePerUnit:
		m.ResetPricePerUnit()
		return nil
	case productqty.FieldQty:
		m.ResetQty()
		return nil
	}
	return fmt.Errorf("unknown ProductQty field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductQtyMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.work_unit != nil {
		edges = append(edges, productqty.EdgeWorkUnit)
	}
	if m.product != nil {
		edges = append(edges, productqty.EdgeProduct)
	}
	if m.product_color != nil {
		edges = append(edges, productqty.EdgeProductColor)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductQtyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case productqty.EdgeWorkUnit:
		if id := m.work_unit; id != nil {
			return []ent.Value{*id}
		}
	case productqty.EdgeProduct:
		if id := m.product; id != nil {
			return []ent.Value{*id}
		}
	case productqty.EdgeProductColor:
		if id := m.product_color; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductQtyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductQtyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductQtyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedwork_unit {
		edges = append(edges, productqty.EdgeWorkUnit)
	}
	if m.clearedproduct {
		edges = append(edges, productqty.EdgeProduct)
	}
	if m.clearedproduct_color {
		edges = append(edges, productqty.EdgeProductColor)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductQtyMutation) EdgeCleared(name string) bool {
	switch name {
	case productqty.EdgeWorkUnit:
		return m.clearedwork_unit
	case productqty.EdgeProduct:
		return m.clearedproduct
	case productqty.EdgeProductColor:
		return m.clearedproduct_color
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductQtyMutation) ClearEdge(name string) error {
	switch name {
	case productqty.EdgeWorkUnit:
		m.ClearWorkUnit()
		return nil
	case productqty.EdgeProduct:
		m.ClearProduct()
		return nil
	case productqty.EdgeProductColor:
		m.ClearProductColor()
		return nil
	}
	return fmt.Errorf("unknown ProductQty unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductQtyMutation) ResetEdge(name string) error {
	switch name {
	case productqty.EdgeWorkUnit:
		m.ResetWorkUnit()
		return nil
	case productqty.EdgeProduct:
		m.ResetProduct()
		return nil
	case productqty.EdgeProductColor:
		m.ResetProductColor()
		return nil
	}
	return fmt.Errorf("unknown ProductQty edge %s", name)
}

// ProductTagMutation represents an operation that mutates the ProductTag nodes in the graph.
type ProductTagMutation struct {
	config
	op              Op
	typ             string
	clearedFields   map[string]struct{}
	products        *string
	clearedproducts bool
	tags            *string
	clearedtags     bool
	done            bool
	oldValue        func(context.Context) (*ProductTag, error)
	predicates      []predicate.ProductTag
}

var _ ent.Mutation = (*ProductTagMutation)(nil)

// producttagOption allows management of the mutation configuration using functional options.
type producttagOption func(*ProductTagMutation)

// newProductTagMutation creates new mutation for the ProductTag entity.
func newProductTagMutation(c config, op Op, opts ...producttagOption) *ProductTagMutation {
	m := &ProductTagMutation{
		config:        c,
		op:            op,
		typ:           TypeProductTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductTagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductTagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetProductID sets the "product_id" field.
func (m *ProductTagMutation) SetProductID(s string) {
	m.products = &s
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *ProductTagMutation) ProductID() (r string, exists bool) {
	v := m.products
	if v == nil {
		return
	}
	return *v, true
}

// ResetProductID resets all changes to the "product_id" field.
func (m *ProductTagMutation) ResetProductID() {
	m.products = nil
}

// SetTagID sets the "tag_id" field.
func (m *ProductTagMutation) SetTagID(s string) {
	m.tags = &s
}

// TagID returns the value of the "tag_id" field in the mutation.
func (m *ProductTagMutation) TagID() (r string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// ResetTagID resets all changes to the "tag_id" field.
func (m *ProductTagMutation) ResetTagID() {
	m.tags = nil
}

// SetProductsID sets the "products" edge to the ProductInfo entity by id.
func (m *ProductTagMutation) SetProductsID(id string) {
	m.products = &id
}

// ClearProducts clears the "products" edge to the ProductInfo entity.
func (m *ProductTagMutation) ClearProducts() {
	m.clearedproducts = true
	m.clearedFields[producttag.FieldProductID] = struct{}{}
}

// ProductsCleared reports if the "products" edge to the ProductInfo entity was cleared.
func (m *ProductTagMutation) ProductsCleared() bool {
	return m.clearedproducts
}

// ProductsID returns the "products" edge ID in the mutation.
func (m *ProductTagMutation) ProductsID() (id string, exists bool) {
	if m.products != nil {
		return *m.products, true
	}
	return
}

// ProductsIDs returns the "products" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductsID instead. It exists only for internal usage by the builders.
func (m *ProductTagMutation) ProductsIDs() (ids []string) {
	if id := m.products; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProducts resets all changes to the "products" edge.
func (m *ProductTagMutation) ResetProducts() {
	m.products = nil
	m.clearedproducts = false
}

// SetTagsID sets the "tags" edge to the Tag entity by id.
func (m *ProductTagMutation) SetTagsID(id string) {
	m.tags = &id
}

// ClearTags clears the "tags" edge to the Tag entity.
func (m *ProductTagMutation) ClearTags() {
	m.clearedtags = true
	m.clearedFields[producttag.FieldTagID] = struct{}{}
}

// TagsCleared reports if the "tags" edge to the Tag entity was cleared.
func (m *ProductTagMutation) TagsCleared() bool {
	return m.clearedtags
}

// TagsID returns the "tags" edge ID in the mutation.
func (m *ProductTagMutation) TagsID() (id string, exists bool) {
	if m.tags != nil {
		return *m.tags, true
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TagsID instead. It exists only for internal usage by the builders.
func (m *ProductTagMutation) TagsIDs() (ids []string) {
	if id := m.tags; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *ProductTagMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
}

// Where appends a list predicates to the ProductTagMutation builder.
func (m *ProductTagMutation) Where(ps ...predicate.ProductTag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductTagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductTagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProductTag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductTagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductTagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProductTag).
func (m *ProductTagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductTagMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.products != nil {
		fields = append(fields, producttag.FieldProductID)
	}
	if m.tags != nil {
		fields = append(fields, producttag.FieldTagID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductTagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case producttag.FieldProductID:
		return m.ProductID()
	case producttag.FieldTagID:
		return m.TagID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductTagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, errors.New("edge schema ProductTag does not support getting old values")
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductTagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case producttag.FieldProductID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case producttag.FieldTagID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTagID(v)
		return nil
	}
	return fmt.Errorf("unknown ProductTag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductTagMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductTagMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductTagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProductTag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductTagMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductTagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductTagMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProductTag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductTagMutation) ResetField(name string) error {
	switch name {
	case producttag.FieldProductID:
		m.ResetProductID()
		return nil
	case producttag.FieldTagID:
		m.ResetTagID()
		return nil
	}
	return fmt.Errorf("unknown ProductTag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductTagMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.products != nil {
		edges = append(edges, producttag.EdgeProducts)
	}
	if m.tags != nil {
		edges = append(edges, producttag.EdgeTags)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductTagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case producttag.EdgeProducts:
		if id := m.products; id != nil {
			return []ent.Value{*id}
		}
	case producttag.EdgeTags:
		if id := m.tags; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductTagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductTagMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductTagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproducts {
		edges = append(edges, producttag.EdgeProducts)
	}
	if m.clearedtags {
		edges = append(edges, producttag.EdgeTags)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductTagMutation) EdgeCleared(name string) bool {
	switch name {
	case producttag.EdgeProducts:
		return m.clearedproducts
	case producttag.EdgeTags:
		return m.clearedtags
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductTagMutation) ClearEdge(name string) error {
	switch name {
	case producttag.EdgeProducts:
		m.ClearProducts()
		return nil
	case producttag.EdgeTags:
		m.ClearTags()
		return nil
	}
	return fmt.Errorf("unknown ProductTag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductTagMutation) ResetEdge(name string) error {
	switch name {
	case producttag.EdgeProducts:
		m.ResetProducts()
		return nil
	case producttag.EdgeTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown ProductTag edge %s", name)
}

// ShipmentMutation represents an operation that mutates the Shipment nodes in the graph.
type ShipmentMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	created_at               *time.Time
	updated_at               *time.Time
	shipment_tracking_number *string
	shipment_date            *time.Time
	note                     *string
	clearedFields            map[string]struct{}
	_order                   *uuid.UUID
	cleared_order            bool
	invoice                  *uuid.UUID
	clearedinvoice           bool
	done                     bool
	oldValue                 func(context.Context) (*Shipment, error)
	predicates               []predicate.Shipment
}

var _ ent.Mutation = (*ShipmentMutation)(nil)

// shipmentOption allows management of the mutation configuration using functional options.
type shipmentOption func(*ShipmentMutation)

// newShipmentMutation creates new mutation for the Shipment entity.
func newShipmentMutation(c config, op Op, opts ...shipmentOption) *ShipmentMutation {
	m := &ShipmentMutation{
		config:        c,
		op:            op,
		typ:           TypeShipment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withShipmentID sets the ID field of the mutation.
func withShipmentID(id uuid.UUID) shipmentOption {
	return func(m *ShipmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Shipment
		)
		m.oldValue = func(ctx context.Context) (*Shipment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Shipment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withShipment sets the old Shipment of the mutation.
func withShipment(node *Shipment) shipmentOption {
	return func(m *ShipmentMutation) {
		m.oldValue = func(context.Context) (*Shipment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ShipmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ShipmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Shipment entities.
func (m *ShipmentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ShipmentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ShipmentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Shipment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ShipmentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ShipmentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Shipment entity.
// If the Shipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ShipmentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ShipmentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ShipmentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Shipment entity.
// If the Shipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ShipmentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetOrderID sets the "order_id" field.
func (m *ShipmentMutation) SetOrderID(u uuid.UUID) {
	m._order = &u
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *ShipmentMutation) OrderID() (r uuid.UUID, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the Shipment entity.
// If the Shipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMutation) OldOrderID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *ShipmentMutation) ResetOrderID() {
	m._order = nil
}

// SetInvoiceID sets the "invoice_id" field.
func (m *ShipmentMutation) SetInvoiceID(u uuid.UUID) {
	m.invoice = &u
}

// InvoiceID returns the value of the "invoice_id" field in the mutation.
func (m *ShipmentMutation) InvoiceID() (r uuid.UUID, exists bool) {
	v := m.invoice
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceID returns the old "invoice_id" field's value of the Shipment entity.
// If the Shipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMutation) OldInvoiceID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceID: %w", err)
	}
	return oldValue.InvoiceID, nil
}

// ResetInvoiceID resets all changes to the "invoice_id" field.
func (m *ShipmentMutation) ResetInvoiceID() {
	m.invoice = nil
}

// SetShipmentTrackingNumber sets the "shipment_tracking_number" field.
func (m *ShipmentMutation) SetShipmentTrackingNumber(s string) {
	m.shipment_tracking_number = &s
}

// ShipmentTrackingNumber returns the value of the "shipment_tracking_number" field in the mutation.
func (m *ShipmentMutation) ShipmentTrackingNumber() (r string, exists bool) {
	v := m.shipment_tracking_number
	if v == nil {
		return
	}
	return *v, true
}

// OldShipmentTrackingNumber returns the old "shipment_tracking_number" field's value of the Shipment entity.
// If the Shipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMutation) OldShipmentTrackingNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShipmentTrackingNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShipmentTrackingNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShipmentTrackingNumber: %w", err)
	}
	return oldValue.ShipmentTrackingNumber, nil
}

// ResetShipmentTrackingNumber resets all changes to the "shipment_tracking_number" field.
func (m *ShipmentMutation) ResetShipmentTrackingNumber() {
	m.shipment_tracking_number = nil
}

// SetShipmentDate sets the "shipment_date" field.
func (m *ShipmentMutation) SetShipmentDate(t time.Time) {
	m.shipment_date = &t
}

// ShipmentDate returns the value of the "shipment_date" field in the mutation.
func (m *ShipmentMutation) ShipmentDate() (r time.Time, exists bool) {
	v := m.shipment_date
	if v == nil {
		return
	}
	return *v, true
}

// OldShipmentDate returns the old "shipment_date" field's value of the Shipment entity.
// If the Shipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMutation) OldShipmentDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShipmentDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShipmentDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShipmentDate: %w", err)
	}
	return oldValue.ShipmentDate, nil
}

// ResetShipmentDate resets all changes to the "shipment_date" field.
func (m *ShipmentMutation) ResetShipmentDate() {
	m.shipment_date = nil
}

// SetNote sets the "note" field.
func (m *ShipmentMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the value of the "note" field in the mutation.
func (m *ShipmentMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "note" field's value of the Shipment entity.
// If the Shipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ClearNote clears the value of the "note" field.
func (m *ShipmentMutation) ClearNote() {
	m.note = nil
	m.clearedFields[shipment.FieldNote] = struct{}{}
}

// NoteCleared returns if the "note" field was cleared in this mutation.
func (m *ShipmentMutation) NoteCleared() bool {
	_, ok := m.clearedFields[shipment.FieldNote]
	return ok
}

// ResetNote resets all changes to the "note" field.
func (m *ShipmentMutation) ResetNote() {
	m.note = nil
	delete(m.clearedFields, shipment.FieldNote)
}

// ClearOrder clears the "order" edge to the Order entity.
func (m *ShipmentMutation) ClearOrder() {
	m.cleared_order = true
	m.clearedFields[shipment.FieldOrderID] = struct{}{}
}

// OrderCleared reports if the "order" edge to the Order entity was cleared.
func (m *ShipmentMutation) OrderCleared() bool {
	return m.cleared_order
}

// OrderIDs returns the "order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderID instead. It exists only for internal usage by the builders.
func (m *ShipmentMutation) OrderIDs() (ids []uuid.UUID) {
	if id := m._order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrder resets all changes to the "order" edge.
func (m *ShipmentMutation) ResetOrder() {
	m._order = nil
	m.cleared_order = false
}

// ClearInvoice clears the "invoice" edge to the Invoice entity.
func (m *ShipmentMutation) ClearInvoice() {
	m.clearedinvoice = true
	m.clearedFields[shipment.FieldInvoiceID] = struct{}{}
}

// InvoiceCleared reports if the "invoice" edge to the Invoice entity was cleared.
func (m *ShipmentMutation) InvoiceCleared() bool {
	return m.clearedinvoice
}

// InvoiceIDs returns the "invoice" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InvoiceID instead. It exists only for internal usage by the builders.
func (m *ShipmentMutation) InvoiceIDs() (ids []uuid.UUID) {
	if id := m.invoice; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInvoice resets all changes to the "invoice" edge.
func (m *ShipmentMutation) ResetInvoice() {
	m.invoice = nil
	m.clearedinvoice = false
}

// Where appends a list predicates to the ShipmentMutation builder.
func (m *ShipmentMutation) Where(ps ...predicate.Shipment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ShipmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ShipmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Shipment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ShipmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ShipmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Shipment).
func (m *ShipmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ShipmentMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, shipment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, shipment.FieldUpdatedAt)
	}
	if m._order != nil {
		fields = append(fields, shipment.FieldOrderID)
	}
	if m.invoice != nil {
		fields = append(fields, shipment.FieldInvoiceID)
	}
	if m.shipment_tracking_number != nil {
		fields = append(fields, shipment.FieldShipmentTrackingNumber)
	}
	if m.shipment_date != nil {
		fields = append(fields, shipment.FieldShipmentDate)
	}
	if m.note != nil {
		fields = append(fields, shipment.FieldNote)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ShipmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case shipment.FieldCreatedAt:
		return m.CreatedAt()
	case shipment.FieldUpdatedAt:
		return m.UpdatedAt()
	case shipment.FieldOrderID:
		return m.OrderID()
	case shipment.FieldInvoiceID:
		return m.InvoiceID()
	case shipment.FieldShipmentTrackingNumber:
		return m.ShipmentTrackingNumber()
	case shipment.FieldShipmentDate:
		return m.ShipmentDate()
	case shipment.FieldNote:
		return m.Note()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ShipmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case shipment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case shipment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case shipment.FieldOrderID:
		return m.OldOrderID(ctx)
	case shipment.FieldInvoiceID:
		return m.OldInvoiceID(ctx)
	case shipment.FieldShipmentTrackingNumber:
		return m.OldShipmentTrackingNumber(ctx)
	case shipment.FieldShipmentDate:
		return m.OldShipmentDate(ctx)
	case shipment.FieldNote:
		return m.OldNote(ctx)
	}
	return nil, fmt.Errorf("unknown Shipment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case shipment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case shipment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case shipment.FieldOrderID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case shipment.FieldInvoiceID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceID(v)
		return nil
	case shipment.FieldShipmentTrackingNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShipmentTrackingNumber(v)
		return nil
	case shipment.FieldShipmentDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShipmentDate(v)
		return nil
	case shipment.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	}
	return fmt.Errorf("unknown Shipment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ShipmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ShipmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Shipment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ShipmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(shipment.FieldNote) {
		fields = append(fields, shipment.FieldNote)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ShipmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ShipmentMutation) ClearField(name string) error {
	switch name {
	case shipment.FieldNote:
		m.ClearNote()
		return nil
	}
	return fmt.Errorf("unknown Shipment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ShipmentMutation) ResetField(name string) error {
	switch name {
	case shipment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case shipment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case shipment.FieldOrderID:
		m.ResetOrderID()
		return nil
	case shipment.FieldInvoiceID:
		m.ResetInvoiceID()
		return nil
	case shipment.FieldShipmentTrackingNumber:
		m.ResetShipmentTrackingNumber()
		return nil
	case shipment.FieldShipmentDate:
		m.ResetShipmentDate()
		return nil
	case shipment.FieldNote:
		m.ResetNote()
		return nil
	}
	return fmt.Errorf("unknown Shipment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ShipmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._order != nil {
		edges = append(edges, shipment.EdgeOrder)
	}
	if m.invoice != nil {
		edges = append(edges, shipment.EdgeInvoice)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ShipmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case shipment.EdgeOrder:
		if id := m._order; id != nil {
			return []ent.Value{*id}
		}
	case shipment.EdgeInvoice:
		if id := m.invoice; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ShipmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ShipmentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ShipmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_order {
		edges = append(edges, shipment.EdgeOrder)
	}
	if m.clearedinvoice {
		edges = append(edges, shipment.EdgeInvoice)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ShipmentMutation) EdgeCleared(name string) bool {
	switch name {
	case shipment.EdgeOrder:
		return m.cleared_order
	case shipment.EdgeInvoice:
		return m.clearedinvoice
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ShipmentMutation) ClearEdge(name string) error {
	switch name {
	case shipment.EdgeOrder:
		m.ClearOrder()
		return nil
	case shipment.EdgeInvoice:
		m.ClearInvoice()
		return nil
	}
	return fmt.Errorf("unknown Shipment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ShipmentMutation) ResetEdge(name string) error {
	switch name {
	case shipment.EdgeOrder:
		m.ResetOrder()
		return nil
	case shipment.EdgeInvoice:
		m.ResetInvoice()
		return nil
	}
	return fmt.Errorf("unknown Shipment edge %s", name)
}

// ShipmentItemMutation represents an operation that mutates the ShipmentItem nodes in the graph.
type ShipmentItemMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	created_at        *time.Time
	updated_at        *time.Time
	qty               *decimal.Decimal
	addqty            *decimal.Decimal
	total             *decimal.Decimal
	addtotal          *decimal.Decimal
	clearedFields     map[string]struct{}
	shipment          *uuid.UUID
	clearedshipment   bool
	order_item        *uuid.UUID
	clearedorder_item bool
	done              bool
	oldValue          func(context.Context) (*ShipmentItem, error)
	predicates        []predicate.ShipmentItem
}

var _ ent.Mutation = (*ShipmentItemMutation)(nil)

// shipmentitemOption allows management of the mutation configuration using functional options.
type shipmentitemOption func(*ShipmentItemMutation)

// newShipmentItemMutation creates new mutation for the ShipmentItem entity.
func newShipmentItemMutation(c config, op Op, opts ...shipmentitemOption) *ShipmentItemMutation {
	m := &ShipmentItemMutation{
		config:        c,
		op:            op,
		typ:           TypeShipmentItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withShipmentItemID sets the ID field of the mutation.
func withShipmentItemID(id uuid.UUID) shipmentitemOption {
	return func(m *ShipmentItemMutation) {
		var (
			err   error
			once  sync.Once
			value *ShipmentItem
		)
		m.oldValue = func(ctx context.Context) (*ShipmentItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ShipmentItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withShipmentItem sets the old ShipmentItem of the mutation.
func withShipmentItem(node *ShipmentItem) shipmentitemOption {
	return func(m *ShipmentItemMutation) {
		m.oldValue = func(context.Context) (*ShipmentItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ShipmentItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ShipmentItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ShipmentItem entities.
func (m *ShipmentItemMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ShipmentItemMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ShipmentItemMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ShipmentItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ShipmentItemMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ShipmentItemMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ShipmentItem entity.
// If the ShipmentItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentItemMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ShipmentItemMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ShipmentItemMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ShipmentItemMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ShipmentItem entity.
// If the ShipmentItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentItemMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ShipmentItemMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetShipmentID sets the "shipment_id" field.
func (m *ShipmentItemMutation) SetShipmentID(u uuid.UUID) {
	m.shipment = &u
}

// ShipmentID returns the value of the "shipment_id" field in the mutation.
func (m *ShipmentItemMutation) ShipmentID() (r uuid.UUID, exists bool) {
	v := m.shipment
	if v == nil {
		return
	}
	return *v, true
}

// OldShipmentID returns the old "shipment_id" field's value of the ShipmentItem entity.
// If the ShipmentItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentItemMutation) OldShipmentID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShipmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShipmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShipmentID: %w", err)
	}
	return oldValue.ShipmentID, nil
}

// ResetShipmentID resets all changes to the "shipment_id" field.
func (m *ShipmentItemMutation) ResetShipmentID() {
	m.shipment = nil
}

// SetOrderItemID sets the "order_item_id" field.
func (m *ShipmentItemMutation) SetOrderItemID(u uuid.UUID) {
	m.order_item = &u
}

// OrderItemID returns the value of the "order_item_id" field in the mutation.
func (m *ShipmentItemMutation) OrderItemID() (r uuid.UUID, exists bool) {
	v := m.order_item
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderItemID returns the old "order_item_id" field's value of the ShipmentItem entity.
// If the ShipmentItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentItemMutation) OldOrderItemID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderItemID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderItemID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderItemID: %w", err)
	}
	return oldValue.OrderItemID, nil
}

// ResetOrderItemID resets all changes to the "order_item_id" field.
func (m *ShipmentItemMutation) ResetOrderItemID() {
	m.order_item = nil
}

// SetQty sets the "qty" field.
func (m *ShipmentItemMutation) SetQty(d decimal.Decimal) {
	m.qty = &d
	m.addqty = nil
}

// Qty returns the value of the "qty" field in the mutation.
func (m *ShipmentItemMutation) Qty() (r decimal.Decimal, exists bool) {
	v := m.qty
	if v == nil {
		return
	}
	return *v, true
}

// OldQty returns the old "qty" field's value of the ShipmentItem entity.
// If the ShipmentItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentItemMutation) OldQty(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQty: %w", err)
	}
	return oldValue.Qty, nil
}

// AddQty adds d to the "qty" field.
func (m *ShipmentItemMutation) AddQty(d decimal.Decimal) {
	if m.addqty != nil {
		*m.addqty = m.addqty.Add(d)
	} else {
		m.addqty = &d
	}
}

// AddedQty returns the value that was added to the "qty" field in this mutation.
func (m *ShipmentItemMutation) AddedQty() (r decimal.Decimal, exists bool) {
	v := m.addqty
	if v == nil {
		return
	}
	return *v, true
}

// ResetQty resets all changes to the "qty" field.
func (m *ShipmentItemMutation) ResetQty() {
	m.qty = nil
	m.addqty = nil
}

// SetTotal sets the "total" field.
func (m *ShipmentItemMutation) SetTotal(d decimal.Decimal) {
	m.total = &d
	m.addtotal = nil
}

// Total returns the value of the "total" field in the mutation.
func (m *ShipmentItemMutation) Total() (r decimal.Decimal, exists bool) {
	v := m.total
	if v == nil {
		return
	}
	return *v, true
}

// OldTotal returns the old "total" field's value of the ShipmentItem entity.
// If the ShipmentItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentItemMutation) OldTotal(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotal: %w", err)
	}
	return oldValue.Total, nil
}

// AddTotal adds d to the "total" field.
func (m *ShipmentItemMutation) AddTotal(d decimal.Decimal) {
	if m.addtotal != nil {
		*m.addtotal = m.addtotal.Add(d)
	} else {
		m.addtotal = &d
	}
}

// AddedTotal returns the value that was added to the "total" field in this mutation.
func (m *ShipmentItemMutation) AddedTotal() (r decimal.Decimal, exists bool) {
	v := m.addtotal
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotal resets all changes to the "total" field.
func (m *ShipmentItemMutation) ResetTotal() {
	m.total = nil
	m.addtotal = nil
}

// ClearShipment clears the "shipment" edge to the Shipment entity.
func (m *ShipmentItemMutation) ClearShipment() {
	m.clearedshipment = true
	m.clearedFields[shipmentitem.FieldShipmentID] = struct{}{}
}

// ShipmentCleared reports if the "shipment" edge to the Shipment entity was cleared.
func (m *ShipmentItemMutation) ShipmentCleared() bool {
	return m.clearedshipment
}

// ShipmentIDs returns the "shipment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ShipmentID instead. It exists only for internal usage by the builders.
func (m *ShipmentItemMutation) ShipmentIDs() (ids []uuid.UUID) {
	if id := m.shipment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetShipment resets all changes to the "shipment" edge.
func (m *ShipmentItemMutation) ResetShipment() {
	m.shipment = nil
	m.clearedshipment = false
}

// ClearOrderItem clears the "order_item" edge to the OrderItem entity.
func (m *ShipmentItemMutation) ClearOrderItem() {
	m.clearedorder_item = true
	m.clearedFields[shipmentitem.FieldOrderItemID] = struct{}{}
}

// OrderItemCleared reports if the "order_item" edge to the OrderItem entity was cleared.
func (m *ShipmentItemMutation) OrderItemCleared() bool {
	return m.clearedorder_item
}

// OrderItemIDs returns the "order_item" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderItemID instead. It exists only for internal usage by the builders.
func (m *ShipmentItemMutation) OrderItemIDs() (ids []uuid.UUID) {
	if id := m.order_item; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrderItem resets all changes to the "order_item" edge.
func (m *ShipmentItemMutation) ResetOrderItem() {
	m.order_item = nil
	m.clearedorder_item = false
}

// Where appends a list predicates to the ShipmentItemMutation builder.
func (m *ShipmentItemMutation) Where(ps ...predicate.ShipmentItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ShipmentItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ShipmentItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ShipmentItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ShipmentItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ShipmentItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ShipmentItem).
func (m *ShipmentItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ShipmentItemMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, shipmentitem.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, shipmentitem.FieldUpdatedAt)
	}
	if m.shipment != nil {
		fields = append(fields, shipmentitem.FieldShipmentID)
	}
	if m.order_item != nil {
		fields = append(fields, shipmentitem.FieldOrderItemID)
	}
	if m.qty != nil {
		fields = append(fields, shipmentitem.FieldQty)
	}
	if m.total != nil {
		fields = append(fields, shipmentitem.FieldTotal)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ShipmentItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case shipmentitem.FieldCreatedAt:
		return m.CreatedAt()
	case shipmentitem.FieldUpdatedAt:
		return m.UpdatedAt()
	case shipmentitem.FieldShipmentID:
		return m.ShipmentID()
	case shipmentitem.FieldOrderItemID:
		return m.OrderItemID()
	case shipmentitem.FieldQty:
		return m.Qty()
	case shipmentitem.FieldTotal:
		return m.Total()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ShipmentItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case shipmentitem.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case shipmentitem.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case shipmentitem.FieldShipmentID:
		return m.OldShipmentID(ctx)
	case shipmentitem.FieldOrderItemID:
		return m.OldOrderItemID(ctx)
	case shipmentitem.FieldQty:
		return m.OldQty(ctx)
	case shipmentitem.FieldTotal:
		return m.OldTotal(ctx)
	}
	return nil, fmt.Errorf("unknown ShipmentItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case shipmentitem.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case shipmentitem.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case shipmentitem.FieldShipmentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShipmentID(v)
		return nil
	case shipmentitem.FieldOrderItemID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderItemID(v)
		return nil
	case shipmentitem.FieldQty:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQty(v)
		return nil
	case shipmentitem.FieldTotal:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotal(v)
		return nil
	}
	return fmt.Errorf("unknown ShipmentItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ShipmentItemMutation) AddedFields() []string {
	var fields []string
	if m.addqty != nil {
		fields = append(fields, shipmentitem.FieldQty)
	}
	if m.addtotal != nil {
		fields = append(fields, shipmentitem.FieldTotal)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ShipmentItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case shipmentitem.FieldQty:
		return m.AddedQty()
	case shipmentitem.FieldTotal:
		return m.AddedTotal()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case shipmentitem.FieldQty:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQty(v)
		return nil
	case shipmentitem.FieldTotal:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotal(v)
		return nil
	}
	return fmt.Errorf("unknown ShipmentItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ShipmentItemMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ShipmentItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ShipmentItemMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ShipmentItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ShipmentItemMutation) ResetField(name string) error {
	switch name {
	case shipmentitem.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case shipmentitem.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case shipmentitem.FieldShipmentID:
		m.ResetShipmentID()
		return nil
	case shipmentitem.FieldOrderItemID:
		m.ResetOrderItemID()
		return nil
	case shipmentitem.FieldQty:
		m.ResetQty()
		return nil
	case shipmentitem.FieldTotal:
		m.ResetTotal()
		return nil
	}
	return fmt.Errorf("unknown ShipmentItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ShipmentItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.shipment != nil {
		edges = append(edges, shipmentitem.EdgeShipment)
	}
	if m.order_item != nil {
		edges = append(edges, shipmentitem.EdgeOrderItem)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ShipmentItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case shipmentitem.EdgeShipment:
		if id := m.shipment; id != nil {
			return []ent.Value{*id}
		}
	case shipmentitem.EdgeOrderItem:
		if id := m.order_item; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ShipmentItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ShipmentItemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ShipmentItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedshipment {
		edges = append(edges, shipmentitem.EdgeShipment)
	}
	if m.clearedorder_item {
		edges = append(edges, shipmentitem.EdgeOrderItem)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ShipmentItemMutation) EdgeCleared(name string) bool {
	switch name {
	case shipmentitem.EdgeShipment:
		return m.clearedshipment
	case shipmentitem.EdgeOrderItem:
		return m.clearedorder_item
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ShipmentItemMutation) ClearEdge(name string) error {
	switch name {
	case shipmentitem.EdgeShipment:
		m.ClearShipment()
		return nil
	case shipmentitem.EdgeOrderItem:
		m.ClearOrderItem()
		return nil
	}
	return fmt.Errorf("unknown ShipmentItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ShipmentItemMutation) ResetEdge(name string) error {
	switch name {
	case shipmentitem.EdgeShipment:
		m.ResetShipment()
		return nil
	case shipmentitem.EdgeOrderItem:
		m.ResetOrderItem()
		return nil
	}
	return fmt.Errorf("unknown ShipmentItem edge %s", name)
}

// TagMutation represents an operation that mutates the Tag nodes in the graph.
type TagMutation struct {
	config
	op              Op
	typ             string
	id              *string
	created_at      *time.Time
	updated_at      *time.Time
	title           *string
	clearedFields   map[string]struct{}
	products        map[string]struct{}
	removedproducts map[string]struct{}
	clearedproducts bool
	done            bool
	oldValue        func(context.Context) (*Tag, error)
	predicates      []predicate.Tag
}

var _ ent.Mutation = (*TagMutation)(nil)

// tagOption allows management of the mutation configuration using functional options.
type tagOption func(*TagMutation)

// newTagMutation creates new mutation for the Tag entity.
func newTagMutation(c config, op Op, opts ...tagOption) *TagMutation {
	m := &TagMutation{
		config:        c,
		op:            op,
		typ:           TypeTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTagID sets the ID field of the mutation.
func withTagID(id string) tagOption {
	return func(m *TagMutation) {
		var (
			err   error
			once  sync.Once
			value *Tag
		)
		m.oldValue = func(ctx context.Context) (*Tag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTag sets the old Tag of the mutation.
func withTag(node *Tag) tagOption {
	return func(m *TagMutation) {
		m.oldValue = func(context.Context) (*Tag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Tag entities.
func (m *TagMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TagMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TagMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TagMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TagMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TagMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TagMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TagMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TagMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTitle sets the "title" field.
func (m *TagMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *TagMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *TagMutation) ResetTitle() {
	m.title = nil
}

// AddProductIDs adds the "products" edge to the ProductInfo entity by ids.
func (m *TagMutation) AddProductIDs(ids ...string) {
	if m.products == nil {
		m.products = make(map[string]struct{})
	}
	for i := range ids {
		m.products[ids[i]] = struct{}{}
	}
}

// ClearProducts clears the "products" edge to the ProductInfo entity.
func (m *TagMutation) ClearProducts() {
	m.clearedproducts = true
}

// ProductsCleared reports if the "products" edge to the ProductInfo entity was cleared.
func (m *TagMutation) ProductsCleared() bool {
	return m.clearedproducts
}

// RemoveProductIDs removes the "products" edge to the ProductInfo entity by IDs.
func (m *TagMutation) RemoveProductIDs(ids ...string) {
	if m.removedproducts == nil {
		m.removedproducts = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.products, ids[i])
		m.removedproducts[ids[i]] = struct{}{}
	}
}

// RemovedProducts returns the removed IDs of the "products" edge to the ProductInfo entity.
func (m *TagMutation) RemovedProductsIDs() (ids []string) {
	for id := range m.removedproducts {
		ids = append(ids, id)
	}
	return
}

// ProductsIDs returns the "products" edge IDs in the mutation.
func (m *TagMutation) ProductsIDs() (ids []string) {
	for id := range m.products {
		ids = append(ids, id)
	}
	return
}

// ResetProducts resets all changes to the "products" edge.
func (m *TagMutation) ResetProducts() {
	m.products = nil
	m.clearedproducts = false
	m.removedproducts = nil
}

// Where appends a list predicates to the TagMutation builder.
func (m *TagMutation) Where(ps ...predicate.Tag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tag).
func (m *TagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TagMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, tag.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tag.FieldUpdatedAt)
	}
	if m.title != nil {
		fields = append(fields, tag.FieldTitle)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tag.FieldCreatedAt:
		return m.CreatedAt()
	case tag.FieldUpdatedAt:
		return m.UpdatedAt()
	case tag.FieldTitle:
		return m.Title()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tag.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tag.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tag.FieldTitle:
		return m.OldTitle(ctx)
	}
	return nil, fmt.Errorf("unknown Tag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tag.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tag.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tag.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TagMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TagMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TagMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TagMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Tag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TagMutation) ResetField(name string) error {
	switch name {
	case tag.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tag.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tag.FieldTitle:
		m.ResetTitle()
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TagMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.products != nil {
		edges = append(edges, tag.EdgeProducts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.products))
		for id := range m.products {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedproducts != nil {
		edges = append(edges, tag.EdgeProducts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.removedproducts))
		for id := range m.removedproducts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedproducts {
		edges = append(edges, tag.EdgeProducts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TagMutation) EdgeCleared(name string) bool {
	switch name {
	case tag.EdgeProducts:
		return m.clearedproducts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TagMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TagMutation) ResetEdge(name string) error {
	switch name {
	case tag.EdgeProducts:
		m.ResetProducts()
		return nil
	}
	return fmt.Errorf("unknown Tag edge %s", name)
}

// WarehouseAssignmentMutation represents an operation that mutates the WarehouseAssignment nodes in the graph.
type WarehouseAssignmentMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	created_at       *time.Time
	updated_at       *time.Time
	status           *warehouseassignment.Status
	note             *string
	clearedFields    map[string]struct{}
	_order           *uuid.UUID
	cleared_order    bool
	work_unit        *uuid.UUID
	clearedwork_unit bool
	staff            *uuid.UUID
	clearedstaff     bool
	done             bool
	oldValue         func(context.Context) (*WarehouseAssignment, error)
	predicates       []predicate.WarehouseAssignment
}

var _ ent.Mutation = (*WarehouseAssignmentMutation)(nil)

// warehouseassignmentOption allows management of the mutation configuration using functional options.
type warehouseassignmentOption func(*WarehouseAssignmentMutation)

// newWarehouseAssignmentMutation creates new mutation for the WarehouseAssignment entity.
func newWarehouseAssignmentMutation(c config, op Op, opts ...warehouseassignmentOption) *WarehouseAssignmentMutation {
	m := &WarehouseAssignmentMutation{
		config:        c,
		op:            op,
		typ:           TypeWarehouseAssignment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWarehouseAssignmentID sets the ID field of the mutation.
func withWarehouseAssignmentID(id uuid.UUID) warehouseassignmentOption {
	return func(m *WarehouseAssignmentMutation) {
		var (
			err   error
			once  sync.Once
			value *WarehouseAssignment
		)
		m.oldValue = func(ctx context.Context) (*WarehouseAssignment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WarehouseAssignment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWarehouseAssignment sets the old WarehouseAssignment of the mutation.
func withWarehouseAssignment(node *WarehouseAssignment) warehouseassignmentOption {
	return func(m *WarehouseAssignmentMutation) {
		m.oldValue = func(context.Context) (*WarehouseAssignment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WarehouseAssignmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WarehouseAssignmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WarehouseAssignment entities.
func (m *WarehouseAssignmentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WarehouseAssignmentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WarehouseAssignmentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WarehouseAssignment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *WarehouseAssignmentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WarehouseAssignmentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the WarehouseAssignment entity.
// If the WarehouseAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarehouseAssignmentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WarehouseAssignmentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WarehouseAssignmentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WarehouseAssignmentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the WarehouseAssignment entity.
// If the WarehouseAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarehouseAssignmentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WarehouseAssignmentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetOrderID sets the "order_id" field.
func (m *WarehouseAssignmentMutation) SetOrderID(u uuid.UUID) {
	m._order = &u
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *WarehouseAssignmentMutation) OrderID() (r uuid.UUID, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the WarehouseAssignment entity.
// If the WarehouseAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarehouseAssignmentMutation) OldOrderID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *WarehouseAssignmentMutation) ResetOrderID() {
	m._order = nil
}

// SetWorkUnitID sets the "work_unit_id" field.
func (m *WarehouseAssignmentMutation) SetWorkUnitID(u uuid.UUID) {
	m.work_unit = &u
}

// WorkUnitID returns the value of the "work_unit_id" field in the mutation.
func (m *WarehouseAssignmentMutation) WorkUnitID() (r uuid.UUID, exists bool) {
	v := m.work_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkUnitID returns the old "work_unit_id" field's value of the WarehouseAssignment entity.
// If the WarehouseAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarehouseAssignmentMutation) OldWorkUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkUnitID: %w", err)
	}
	return oldValue.WorkUnitID, nil
}

// ResetWorkUnitID resets all changes to the "work_unit_id" field.
func (m *WarehouseAssignmentMutation) ResetWorkUnitID() {
	m.work_unit = nil
}

// SetStaffID sets the "staff_id" field.
func (m *WarehouseAssignmentMutation) SetStaffID(u uuid.UUID) {
	m.staff = &u
}

// StaffID returns the value of the "staff_id" field in the mutation.
func (m *WarehouseAssignmentMutation) StaffID() (r uuid.UUID, exists bool) {
	v := m.staff
	if v == nil {
		return
	}
	return *v, true
}

// OldStaffID returns the old "staff_id" field's value of the WarehouseAssignment entity.
// If the WarehouseAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarehouseAssignmentMutation) OldStaffID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStaffID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStaffID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStaffID: %w", err)
	}
	return oldValue.StaffID, nil
}

// ClearStaffID clears the value of the "staff_id" field.
func (m *WarehouseAssignmentMutation) ClearStaffID() {
	m.staff = nil
	m.clearedFields[warehouseassignment.FieldStaffID] = struct{}{}
}

// StaffIDCleared returns if the "staff_id" field was cleared in this mutation.
func (m *WarehouseAssignmentMutation) StaffIDCleared() bool {
	_, ok := m.clearedFields[warehouseassignment.FieldStaffID]
	return ok
}

// ResetStaffID resets all changes to the "staff_id" field.
func (m *WarehouseAssignmentMutation) ResetStaffID() {
	m.staff = nil
	delete(m.clearedFields, warehouseassignment.FieldStaffID)
}

// SetStatus sets the "status" field.
func (m *WarehouseAssignmentMutation) SetStatus(w warehouseassignment.Status) {
	m.status = &w
}

// Status returns the value of the "status" field in the mutation.
func (m *WarehouseAssignmentMutation) Status() (r warehouseassignment.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the WarehouseAssignment entity.
// If the WarehouseAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarehouseAssignmentMutation) OldStatus(ctx context.Context) (v warehouseassignment.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *WarehouseAssignmentMutation) ResetStatus() {
	m.status = nil
}

// SetNote sets the "note" field.
func (m *WarehouseAssignmentMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the value of the "note" field in the mutation.
func (m *WarehouseAssignmentMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "note" field's value of the WarehouseAssignment entity.
// If the WarehouseAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarehouseAssignmentMutation) OldNote(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ClearNote clears the value of the "note" field.
func (m *WarehouseAssignmentMutation) ClearNote() {
	m.note = nil
	m.clearedFields[warehouseassignment.FieldNote] = struct{}{}
}

// NoteCleared returns if the "note" field was cleared in this mutation.
func (m *WarehouseAssignmentMutation) NoteCleared() bool {
	_, ok := m.clearedFields[warehouseassignment.FieldNote]
	return ok
}

// ResetNote resets all changes to the "note" field.
func (m *WarehouseAssignmentMutation) ResetNote() {
	m.note = nil
	delete(m.clearedFields, warehouseassignment.FieldNote)
}

// ClearOrder clears the "order" edge to the Order entity.
func (m *WarehouseAssignmentMutation) ClearOrder() {
	m.cleared_order = true
	m.clearedFields[warehouseassignment.FieldOrderID] = struct{}{}
}

// OrderCleared reports if the "order" edge to the Order entity was cleared.
func (m *WarehouseAssignmentMutation) OrderCleared() bool {
	return m.cleared_order
}

// OrderIDs returns the "order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderID instead. It exists only for internal usage by the builders.
func (m *WarehouseAssignmentMutation) OrderIDs() (ids []uuid.UUID) {
	if id := m._order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrder resets all changes to the "order" edge.
func (m *WarehouseAssignmentMutation) ResetOrder() {
	m._order = nil
	m.cleared_order = false
}

// ClearWorkUnit clears the "work_unit" edge to the WorkUnitInfo entity.
func (m *WarehouseAssignmentMutation) ClearWorkUnit() {
	m.clearedwork_unit = true
	m.clearedFields[warehouseassignment.FieldWorkUnitID] = struct{}{}
}

// WorkUnitCleared reports if the "work_unit" edge to the WorkUnitInfo entity was cleared.
func (m *WarehouseAssignmentMutation) WorkUnitCleared() bool {
	return m.clearedwork_unit
}

// WorkUnitIDs returns the "work_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkUnitID instead. It exists only for internal usage by the builders.
func (m *WarehouseAssignmentMutation) WorkUnitIDs() (ids []uuid.UUID) {
	if id := m.work_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkUnit resets all changes to the "work_unit" edge.
func (m *WarehouseAssignmentMutation) ResetWorkUnit() {
	m.work_unit = nil
	m.clearedwork_unit = false
}

// ClearStaff clears the "staff" edge to the Person entity.
func (m *WarehouseAssignmentMutation) ClearStaff() {
	m.clearedstaff = true
	m.clearedFields[warehouseassignment.FieldStaffID] = struct{}{}
}

// StaffCleared reports if the "staff" edge to the Person entity was cleared.
func (m *WarehouseAssignmentMutation) StaffCleared() bool {
	return m.StaffIDCleared() || m.clearedstaff
}

// StaffIDs returns the "staff" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StaffID instead. It exists only for internal usage by the builders.
func (m *WarehouseAssignmentMutation) StaffIDs() (ids []uuid.UUID) {
	if id := m.staff; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStaff resets all changes to the "staff" edge.
func (m *WarehouseAssignmentMutation) ResetStaff() {
	m.staff = nil
	m.clearedstaff = false
}

// Where appends a list predicates to the WarehouseAssignmentMutation builder.
func (m *WarehouseAssignmentMutation) Where(ps ...predicate.WarehouseAssignment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WarehouseAssignmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WarehouseAssignmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WarehouseAssignment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WarehouseAssignmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WarehouseAssignmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WarehouseAssignment).
func (m *WarehouseAssignmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WarehouseAssignmentMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, warehouseassignment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, warehouseassignment.FieldUpdatedAt)
	}
	if m._order != nil {
		fields = append(fields, warehouseassignment.FieldOrderID)
	}
	if m.work_unit != nil {
		fields = append(fields, warehouseassignment.FieldWorkUnitID)
	}
	if m.staff != nil {
		fields = append(fields, warehouseassignment.FieldStaffID)
	}
	if m.status != nil {
		fields = append(fields, warehouseassignment.FieldStatus)
	}
	if m.note != nil {
		fields = append(fields, warehouseassignment.FieldNote)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WarehouseAssignmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case warehouseassignment.FieldCreatedAt:
		return m.CreatedAt()
	case warehouseassignment.FieldUpdatedAt:
		return m.UpdatedAt()
	case warehouseassignment.FieldOrderID:
		return m.OrderID()
	case warehouseassignment.FieldWorkUnitID:
		return m.WorkUnitID()
	case warehouseassignment.FieldStaffID:
		return m.StaffID()
	case warehouseassignment.FieldStatus:
		return m.Status()
	case warehouseassignment.FieldNote:
		return m.Note()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WarehouseAssignmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case warehouseassignment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case warehouseassignment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case warehouseassignment.FieldOrderID:
		return m.OldOrderID(ctx)
	case warehouseassignment.FieldWorkUnitID:
		return m.OldWorkUnitID(ctx)
	case warehouseassignment.FieldStaffID:
		return m.OldStaffID(ctx)
	case warehouseassignment.FieldStatus:
		return m.OldStatus(ctx)
	case warehouseassignment.FieldNote:
		return m.OldNote(ctx)
	}
	return nil, fmt.Errorf("unknown WarehouseAssignment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WarehouseAssignmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case warehouseassignment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case warehouseassignment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case warehouseassignment.FieldOrderID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case warehouseassignment.FieldWorkUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkUnitID(v)
		return nil
	case warehouseassignment.FieldStaffID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStaffID(v)
		return nil
	case warehouseassignment.FieldStatus:
		v, ok := value.(warehouseassignment.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case warehouseassignment.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	}
	return fmt.Errorf("unknown WarehouseAssignment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WarehouseAssignmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WarehouseAssignmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WarehouseAssignmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WarehouseAssignment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WarehouseAssignmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(warehouseassignment.FieldStaffID) {
		fields = append(fields, warehouseassignment.FieldStaffID)
	}
	if m.FieldCleared(warehouseassignment.FieldNote) {
		fields = append(fields, warehouseassignment.FieldNote)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WarehouseAssignmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WarehouseAssignmentMutation) ClearField(name string) error {
	switch name {
	case warehouseassignment.FieldStaffID:
		m.ClearStaffID()
		return nil
	case warehouseassignment.FieldNote:
		m.ClearNote()
		return nil
	}
	return fmt.Errorf("unknown WarehouseAssignment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WarehouseAssignmentMutation) ResetField(name string) error {
	switch name {
	case warehouseassignment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case warehouseassignment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case warehouseassignment.FieldOrderID:
		m.ResetOrderID()
		return nil
	case warehouseassignment.FieldWorkUnitID:
		m.ResetWorkUnitID()
		return nil
	case warehouseassignment.FieldStaffID:
		m.ResetStaffID()
		return nil
	case warehouseassignment.FieldStatus:
		m.ResetStatus()
		return nil
	case warehouseassignment.FieldNote:
		m.ResetNote()
		return nil
	}
	return fmt.Errorf("unknown WarehouseAssignment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WarehouseAssignmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m._order != nil {
		edges = append(edges, warehouseassignment.EdgeOrder)
	}
	if m.work_unit != nil {
		edges = append(edges, warehouseassignment.EdgeWorkUnit)
	}
	if m.staff != nil {
		edges = append(edges, warehouseassignment.EdgeStaff)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WarehouseAssignmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case warehouseassignment.EdgeOrder:
		if id := m._order; id != nil {
			return []ent.Value{*id}
		}
	case warehouseassignment.EdgeWorkUnit:
		if id := m.work_unit; id != nil {
			return []ent.Value{*id}
		}
	case warehouseassignment.EdgeStaff:
		if id := m.staff; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WarehouseAssignmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WarehouseAssignmentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WarehouseAssignmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleared_order {
		edges = append(edges, warehouseassignment.EdgeOrder)
	}
	if m.clearedwork_unit {
		edges = append(edges, warehouseassignment.EdgeWorkUnit)
	}
	if m.clearedstaff {
		edges = append(edges, warehouseassignment.EdgeStaff)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WarehouseAssignmentMutation) EdgeCleared(name string) bool {
	switch name {
	case warehouseassignment.EdgeOrder:
		return m.cleared_order
	case warehouseassignment.EdgeWorkUnit:
		return m.clearedwork_unit
	case warehouseassignment.EdgeStaff:
		return m.clearedstaff
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WarehouseAssignmentMutation) ClearEdge(name string) error {
	switch name {
	case warehouseassignment.EdgeOrder:
		m.ClearOrder()
		return nil
	case warehouseassignment.EdgeWorkUnit:
		m.ClearWorkUnit()
		return nil
	case warehouseassignment.EdgeStaff:
		m.ClearStaff()
		return nil
	}
	return fmt.Errorf("unknown WarehouseAssignment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WarehouseAssignmentMutation) ResetEdge(name string) error {
	switch name {
	case warehouseassignment.EdgeOrder:
		m.ResetOrder()
		return nil
	case warehouseassignment.EdgeWorkUnit:
		m.ResetWorkUnit()
		return nil
	case warehouseassignment.EdgeStaff:
		m.ResetStaff()
		return nil
	}
	return fmt.Errorf("unknown WarehouseAssignment edge %s", name)
}

// WorkUnitInfoMutation represents an operation that mutates the WorkUnitInfo nodes in the graph.
type WorkUnitInfoMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	name           *string
	_type          *workunitinfo.Type
	clearedFields  map[string]struct{}
	address        *string
	clearedaddress bool
	done           bool
	oldValue       func(context.Context) (*WorkUnitInfo, error)
	predicates     []predicate.WorkUnitInfo
}

var _ ent.Mutation = (*WorkUnitInfoMutation)(nil)

// workunitinfoOption allows management of the mutation configuration using functional options.
type workunitinfoOption func(*WorkUnitInfoMutation)

// newWorkUnitInfoMutation creates new mutation for the WorkUnitInfo entity.
func newWorkUnitInfoMutation(c config, op Op, opts ...workunitinfoOption) *WorkUnitInfoMutation {
	m := &WorkUnitInfoMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkUnitInfo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkUnitInfoID sets the ID field of the mutation.
func withWorkUnitInfoID(id uuid.UUID) workunitinfoOption {
	return func(m *WorkUnitInfoMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkUnitInfo
		)
		m.oldValue = func(ctx context.Context) (*WorkUnitInfo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkUnitInfo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkUnitInfo sets the old WorkUnitInfo of the mutation.
func withWorkUnitInfo(node *WorkUnitInfo) workunitinfoOption {
	return func(m *WorkUnitInfoMutation) {
		m.oldValue = func(context.Context) (*WorkUnitInfo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkUnitInfoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkUnitInfoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WorkUnitInfo entities.
func (m *WorkUnitInfoMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkUnitInfoMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkUnitInfoMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WorkUnitInfo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *WorkUnitInfoMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *WorkUnitInfoMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the WorkUnitInfo entity.
// If the WorkUnitInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkUnitInfoMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *WorkUnitInfoMutation) ResetName() {
	m.name = nil
}

// SetAddressID sets the "address_id" field.
func (m *WorkUnitInfoMutation) SetAddressID(s string) {
	m.address = &s
}

// AddressID returns the value of the "address_id" field in the mutation.
func (m *WorkUnitInfoMutation) AddressID() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddressID returns the old "address_id" field's value of the WorkUnitInfo entity.
// If the WorkUnitInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkUnitInfoMutation) OldAddressID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddressID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddressID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddressID: %w", err)
	}
	return oldValue.AddressID, nil
}

// ClearAddressID clears the value of the "address_id" field.
func (m *WorkUnitInfoMutation) ClearAddressID() {
	m.address = nil
	m.clearedFields[workunitinfo.FieldAddressID] = struct{}{}
}

// AddressIDCleared returns if the "address_id" field was cleared in this mutation.
func (m *WorkUnitInfoMutation) AddressIDCleared() bool {
	_, ok := m.clearedFields[workunitinfo.FieldAddressID]
	return ok
}

// ResetAddressID resets all changes to the "address_id" field.
func (m *WorkUnitInfoMutation) ResetAddressID() {
	m.address = nil
	delete(m.clearedFields, workunitinfo.FieldAddressID)
}

// SetType sets the "type" field.
func (m *WorkUnitInfoMutation) SetType(w workunitinfo.Type) {
	m._type = &w
}

// GetType returns the value of the "type" field in the mutation.
func (m *WorkUnitInfoMutation) GetType() (r workunitinfo.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the WorkUnitInfo entity.
// If the WorkUnitInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkUnitInfoMutation) OldType(ctx context.Context) (v workunitinfo.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *WorkUnitInfoMutation) ResetType() {
	m._type = nil
}

// ClearAddress clears the "address" edge to the Address entity.
func (m *WorkUnitInfoMutation) ClearAddress() {
	m.clearedaddress = true
	m.clearedFields[workunitinfo.FieldAddressID] = struct{}{}
}

// AddressCleared reports if the "address" edge to the Address entity was cleared.
func (m *WorkUnitInfoMutation) AddressCleared() bool {
	return m.AddressIDCleared() || m.clearedaddress
}

// AddressIDs returns the "address" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AddressID instead. It exists only for internal usage by the builders.
func (m *WorkUnitInfoMutation) AddressIDs() (ids []string) {
	if id := m.address; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAddress resets all changes to the "address" edge.
func (m *WorkUnitInfoMutation) ResetAddress() {
	m.address = nil
	m.clearedaddress = false
}

// Where appends a list predicates to the WorkUnitInfoMutation builder.
func (m *WorkUnitInfoMutation) Where(ps ...predicate.WorkUnitInfo) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkUnitInfoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkUnitInfoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WorkUnitInfo, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkUnitInfoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkUnitInfoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WorkUnitInfo).
func (m *WorkUnitInfoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkUnitInfoMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, workunitinfo.FieldName)
	}
	if m.address != nil {
		fields = append(fields, workunitinfo.FieldAddressID)
	}
	if m._type != nil {
		fields = append(fields, workunitinfo.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkUnitInfoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workunitinfo.FieldName:
		return m.Name()
	case workunitinfo.FieldAddressID:
		return m.AddressID()
	case workunitinfo.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkUnitInfoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workunitinfo.FieldName:
		return m.OldName(ctx)
	case workunitinfo.FieldAddressID:
		return m.OldAddressID(ctx)
	case workunitinfo.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown WorkUnitInfo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkUnitInfoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workunitinfo.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case workunitinfo.FieldAddressID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddressID(v)
		return nil
	case workunitinfo.FieldType:
		v, ok := value.(workunitinfo.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown WorkUnitInfo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkUnitInfoMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkUnitInfoMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkUnitInfoMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WorkUnitInfo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkUnitInfoMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workunitinfo.FieldAddressID) {
		fields = append(fields, workunitinfo.FieldAddressID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkUnitInfoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkUnitInfoMutation) ClearField(name string) error {
	switch name {
	case workunitinfo.FieldAddressID:
		m.ClearAddressID()
		return nil
	}
	return fmt.Errorf("unknown WorkUnitInfo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkUnitInfoMutation) ResetField(name string) error {
	switch name {
	case workunitinfo.FieldName:
		m.ResetName()
		return nil
	case workunitinfo.FieldAddressID:
		m.ResetAddressID()
		return nil
	case workunitinfo.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown WorkUnitInfo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkUnitInfoMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.address != nil {
		edges = append(edges, workunitinfo.EdgeAddress)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkUnitInfoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workunitinfo.EdgeAddress:
		if id := m.address; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkUnitInfoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkUnitInfoMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkUnitInfoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedaddress {
		edges = append(edges, workunitinfo.EdgeAddress)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkUnitInfoMutation) EdgeCleared(name string) bool {
	switch name {
	case workunitinfo.EdgeAddress:
		return m.clearedaddress
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkUnitInfoMutation) ClearEdge(name string) error {
	switch name {
	case workunitinfo.EdgeAddress:
		m.ClearAddress()
		return nil
	}
	return fmt.Errorf("unknown WorkUnitInfo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkUnitInfoMutation) ResetEdge(name string) error {
	switch name {
	case workunitinfo.EdgeAddress:
		m.ResetAddress()
		return nil
	}
	return fmt.Errorf("unknown WorkUnitInfo edge %s", name)
}
