// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/google/uuid"
	"github.com/thaiha1607/foursquare_server/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/thaiha1607/foursquare_server/ent/conversation"
	"github.com/thaiha1607/foursquare_server/ent/financialtransaction"
	"github.com/thaiha1607/foursquare_server/ent/invoice"
	"github.com/thaiha1607/foursquare_server/ent/invoicelineitem"
	"github.com/thaiha1607/foursquare_server/ent/message"
	"github.com/thaiha1607/foursquare_server/ent/order"
	"github.com/thaiha1607/foursquare_server/ent/orderlineitem"
	"github.com/thaiha1607/foursquare_server/ent/orderstatuscode"
	"github.com/thaiha1607/foursquare_server/ent/person"
	"github.com/thaiha1607/foursquare_server/ent/product"
	"github.com/thaiha1607/foursquare_server/ent/productimage"
	"github.com/thaiha1607/foursquare_server/ent/producttag"
	"github.com/thaiha1607/foursquare_server/ent/tag"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Conversation is the client for interacting with the Conversation builders.
	Conversation *ConversationClient
	// FinancialTransaction is the client for interacting with the FinancialTransaction builders.
	FinancialTransaction *FinancialTransactionClient
	// Invoice is the client for interacting with the Invoice builders.
	Invoice *InvoiceClient
	// InvoiceLineItem is the client for interacting with the InvoiceLineItem builders.
	InvoiceLineItem *InvoiceLineItemClient
	// Message is the client for interacting with the Message builders.
	Message *MessageClient
	// Order is the client for interacting with the Order builders.
	Order *OrderClient
	// OrderLineItem is the client for interacting with the OrderLineItem builders.
	OrderLineItem *OrderLineItemClient
	// OrderStatusCode is the client for interacting with the OrderStatusCode builders.
	OrderStatusCode *OrderStatusCodeClient
	// Person is the client for interacting with the Person builders.
	Person *PersonClient
	// Product is the client for interacting with the Product builders.
	Product *ProductClient
	// ProductImage is the client for interacting with the ProductImage builders.
	ProductImage *ProductImageClient
	// ProductTag is the client for interacting with the ProductTag builders.
	ProductTag *ProductTagClient
	// Tag is the client for interacting with the Tag builders.
	Tag *TagClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Conversation = NewConversationClient(c.config)
	c.FinancialTransaction = NewFinancialTransactionClient(c.config)
	c.Invoice = NewInvoiceClient(c.config)
	c.InvoiceLineItem = NewInvoiceLineItemClient(c.config)
	c.Message = NewMessageClient(c.config)
	c.Order = NewOrderClient(c.config)
	c.OrderLineItem = NewOrderLineItemClient(c.config)
	c.OrderStatusCode = NewOrderStatusCodeClient(c.config)
	c.Person = NewPersonClient(c.config)
	c.Product = NewProductClient(c.config)
	c.ProductImage = NewProductImageClient(c.config)
	c.ProductTag = NewProductTagClient(c.config)
	c.Tag = NewTagClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                  ctx,
		config:               cfg,
		Conversation:         NewConversationClient(cfg),
		FinancialTransaction: NewFinancialTransactionClient(cfg),
		Invoice:              NewInvoiceClient(cfg),
		InvoiceLineItem:      NewInvoiceLineItemClient(cfg),
		Message:              NewMessageClient(cfg),
		Order:                NewOrderClient(cfg),
		OrderLineItem:        NewOrderLineItemClient(cfg),
		OrderStatusCode:      NewOrderStatusCodeClient(cfg),
		Person:               NewPersonClient(cfg),
		Product:              NewProductClient(cfg),
		ProductImage:         NewProductImageClient(cfg),
		ProductTag:           NewProductTagClient(cfg),
		Tag:                  NewTagClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                  ctx,
		config:               cfg,
		Conversation:         NewConversationClient(cfg),
		FinancialTransaction: NewFinancialTransactionClient(cfg),
		Invoice:              NewInvoiceClient(cfg),
		InvoiceLineItem:      NewInvoiceLineItemClient(cfg),
		Message:              NewMessageClient(cfg),
		Order:                NewOrderClient(cfg),
		OrderLineItem:        NewOrderLineItemClient(cfg),
		OrderStatusCode:      NewOrderStatusCodeClient(cfg),
		Person:               NewPersonClient(cfg),
		Product:              NewProductClient(cfg),
		ProductImage:         NewProductImageClient(cfg),
		ProductTag:           NewProductTagClient(cfg),
		Tag:                  NewTagClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Conversation.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Conversation, c.FinancialTransaction, c.Invoice, c.InvoiceLineItem, c.Message,
		c.Order, c.OrderLineItem, c.OrderStatusCode, c.Person, c.Product,
		c.ProductImage, c.ProductTag, c.Tag,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Conversation, c.FinancialTransaction, c.Invoice, c.InvoiceLineItem, c.Message,
		c.Order, c.OrderLineItem, c.OrderStatusCode, c.Person, c.Product,
		c.ProductImage, c.ProductTag, c.Tag,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *ConversationMutation:
		return c.Conversation.mutate(ctx, m)
	case *FinancialTransactionMutation:
		return c.FinancialTransaction.mutate(ctx, m)
	case *InvoiceMutation:
		return c.Invoice.mutate(ctx, m)
	case *InvoiceLineItemMutation:
		return c.InvoiceLineItem.mutate(ctx, m)
	case *MessageMutation:
		return c.Message.mutate(ctx, m)
	case *OrderMutation:
		return c.Order.mutate(ctx, m)
	case *OrderLineItemMutation:
		return c.OrderLineItem.mutate(ctx, m)
	case *OrderStatusCodeMutation:
		return c.OrderStatusCode.mutate(ctx, m)
	case *PersonMutation:
		return c.Person.mutate(ctx, m)
	case *ProductMutation:
		return c.Product.mutate(ctx, m)
	case *ProductImageMutation:
		return c.ProductImage.mutate(ctx, m)
	case *ProductTagMutation:
		return c.ProductTag.mutate(ctx, m)
	case *TagMutation:
		return c.Tag.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// ConversationClient is a client for the Conversation schema.
type ConversationClient struct {
	config
}

// NewConversationClient returns a client for the Conversation from the given config.
func NewConversationClient(c config) *ConversationClient {
	return &ConversationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `conversation.Hooks(f(g(h())))`.
func (c *ConversationClient) Use(hooks ...Hook) {
	c.hooks.Conversation = append(c.hooks.Conversation, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `conversation.Intercept(f(g(h())))`.
func (c *ConversationClient) Intercept(interceptors ...Interceptor) {
	c.inters.Conversation = append(c.inters.Conversation, interceptors...)
}

// Create returns a builder for creating a Conversation entity.
func (c *ConversationClient) Create() *ConversationCreate {
	mutation := newConversationMutation(c.config, OpCreate)
	return &ConversationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Conversation entities.
func (c *ConversationClient) CreateBulk(builders ...*ConversationCreate) *ConversationCreateBulk {
	return &ConversationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ConversationClient) MapCreateBulk(slice any, setFunc func(*ConversationCreate, int)) *ConversationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ConversationCreateBulk{err: fmt.Errorf("calling to ConversationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ConversationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ConversationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Conversation.
func (c *ConversationClient) Update() *ConversationUpdate {
	mutation := newConversationMutation(c.config, OpUpdate)
	return &ConversationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ConversationClient) UpdateOne(co *Conversation) *ConversationUpdateOne {
	mutation := newConversationMutation(c.config, OpUpdateOne, withConversation(co))
	return &ConversationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ConversationClient) UpdateOneID(id uuid.UUID) *ConversationUpdateOne {
	mutation := newConversationMutation(c.config, OpUpdateOne, withConversationID(id))
	return &ConversationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Conversation.
func (c *ConversationClient) Delete() *ConversationDelete {
	mutation := newConversationMutation(c.config, OpDelete)
	return &ConversationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ConversationClient) DeleteOne(co *Conversation) *ConversationDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ConversationClient) DeleteOneID(id uuid.UUID) *ConversationDeleteOne {
	builder := c.Delete().Where(conversation.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ConversationDeleteOne{builder}
}

// Query returns a query builder for Conversation.
func (c *ConversationClient) Query() *ConversationQuery {
	return &ConversationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeConversation},
		inters: c.Interceptors(),
	}
}

// Get returns a Conversation entity by its id.
func (c *ConversationClient) Get(ctx context.Context, id uuid.UUID) (*Conversation, error) {
	return c.Query().Where(conversation.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ConversationClient) GetX(ctx context.Context, id uuid.UUID) *Conversation {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPersonOne queries the person_one edge of a Conversation.
func (c *ConversationClient) QueryPersonOne(co *Conversation) *PersonQuery {
	query := (&PersonClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(conversation.Table, conversation.FieldID, id),
			sqlgraph.To(person.Table, person.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, conversation.PersonOneTable, conversation.PersonOneColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPersonTwo queries the person_two edge of a Conversation.
func (c *ConversationClient) QueryPersonTwo(co *Conversation) *PersonQuery {
	query := (&PersonClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(conversation.Table, conversation.FieldID, id),
			sqlgraph.To(person.Table, person.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, conversation.PersonTwoTable, conversation.PersonTwoColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ConversationClient) Hooks() []Hook {
	return c.hooks.Conversation
}

// Interceptors returns the client interceptors.
func (c *ConversationClient) Interceptors() []Interceptor {
	return c.inters.Conversation
}

func (c *ConversationClient) mutate(ctx context.Context, m *ConversationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ConversationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ConversationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ConversationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ConversationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Conversation mutation op: %q", m.Op())
	}
}

// FinancialTransactionClient is a client for the FinancialTransaction schema.
type FinancialTransactionClient struct {
	config
}

// NewFinancialTransactionClient returns a client for the FinancialTransaction from the given config.
func NewFinancialTransactionClient(c config) *FinancialTransactionClient {
	return &FinancialTransactionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `financialtransaction.Hooks(f(g(h())))`.
func (c *FinancialTransactionClient) Use(hooks ...Hook) {
	c.hooks.FinancialTransaction = append(c.hooks.FinancialTransaction, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `financialtransaction.Intercept(f(g(h())))`.
func (c *FinancialTransactionClient) Intercept(interceptors ...Interceptor) {
	c.inters.FinancialTransaction = append(c.inters.FinancialTransaction, interceptors...)
}

// Create returns a builder for creating a FinancialTransaction entity.
func (c *FinancialTransactionClient) Create() *FinancialTransactionCreate {
	mutation := newFinancialTransactionMutation(c.config, OpCreate)
	return &FinancialTransactionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of FinancialTransaction entities.
func (c *FinancialTransactionClient) CreateBulk(builders ...*FinancialTransactionCreate) *FinancialTransactionCreateBulk {
	return &FinancialTransactionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FinancialTransactionClient) MapCreateBulk(slice any, setFunc func(*FinancialTransactionCreate, int)) *FinancialTransactionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FinancialTransactionCreateBulk{err: fmt.Errorf("calling to FinancialTransactionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FinancialTransactionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FinancialTransactionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for FinancialTransaction.
func (c *FinancialTransactionClient) Update() *FinancialTransactionUpdate {
	mutation := newFinancialTransactionMutation(c.config, OpUpdate)
	return &FinancialTransactionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FinancialTransactionClient) UpdateOne(ft *FinancialTransaction) *FinancialTransactionUpdateOne {
	mutation := newFinancialTransactionMutation(c.config, OpUpdateOne, withFinancialTransaction(ft))
	return &FinancialTransactionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FinancialTransactionClient) UpdateOneID(id uuid.UUID) *FinancialTransactionUpdateOne {
	mutation := newFinancialTransactionMutation(c.config, OpUpdateOne, withFinancialTransactionID(id))
	return &FinancialTransactionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for FinancialTransaction.
func (c *FinancialTransactionClient) Delete() *FinancialTransactionDelete {
	mutation := newFinancialTransactionMutation(c.config, OpDelete)
	return &FinancialTransactionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FinancialTransactionClient) DeleteOne(ft *FinancialTransaction) *FinancialTransactionDeleteOne {
	return c.DeleteOneID(ft.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FinancialTransactionClient) DeleteOneID(id uuid.UUID) *FinancialTransactionDeleteOne {
	builder := c.Delete().Where(financialtransaction.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FinancialTransactionDeleteOne{builder}
}

// Query returns a query builder for FinancialTransaction.
func (c *FinancialTransactionClient) Query() *FinancialTransactionQuery {
	return &FinancialTransactionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFinancialTransaction},
		inters: c.Interceptors(),
	}
}

// Get returns a FinancialTransaction entity by its id.
func (c *FinancialTransactionClient) Get(ctx context.Context, id uuid.UUID) (*FinancialTransaction, error) {
	return c.Query().Where(financialtransaction.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FinancialTransactionClient) GetX(ctx context.Context, id uuid.UUID) *FinancialTransaction {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryInvoice queries the invoice edge of a FinancialTransaction.
func (c *FinancialTransactionClient) QueryInvoice(ft *FinancialTransaction) *InvoiceQuery {
	query := (&InvoiceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ft.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(financialtransaction.Table, financialtransaction.FieldID, id),
			sqlgraph.To(invoice.Table, invoice.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, financialtransaction.InvoiceTable, financialtransaction.InvoiceColumn),
		)
		fromV = sqlgraph.Neighbors(ft.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FinancialTransactionClient) Hooks() []Hook {
	return c.hooks.FinancialTransaction
}

// Interceptors returns the client interceptors.
func (c *FinancialTransactionClient) Interceptors() []Interceptor {
	return c.inters.FinancialTransaction
}

func (c *FinancialTransactionClient) mutate(ctx context.Context, m *FinancialTransactionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FinancialTransactionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FinancialTransactionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FinancialTransactionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FinancialTransactionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown FinancialTransaction mutation op: %q", m.Op())
	}
}

// InvoiceClient is a client for the Invoice schema.
type InvoiceClient struct {
	config
}

// NewInvoiceClient returns a client for the Invoice from the given config.
func NewInvoiceClient(c config) *InvoiceClient {
	return &InvoiceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `invoice.Hooks(f(g(h())))`.
func (c *InvoiceClient) Use(hooks ...Hook) {
	c.hooks.Invoice = append(c.hooks.Invoice, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `invoice.Intercept(f(g(h())))`.
func (c *InvoiceClient) Intercept(interceptors ...Interceptor) {
	c.inters.Invoice = append(c.inters.Invoice, interceptors...)
}

// Create returns a builder for creating a Invoice entity.
func (c *InvoiceClient) Create() *InvoiceCreate {
	mutation := newInvoiceMutation(c.config, OpCreate)
	return &InvoiceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Invoice entities.
func (c *InvoiceClient) CreateBulk(builders ...*InvoiceCreate) *InvoiceCreateBulk {
	return &InvoiceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *InvoiceClient) MapCreateBulk(slice any, setFunc func(*InvoiceCreate, int)) *InvoiceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &InvoiceCreateBulk{err: fmt.Errorf("calling to InvoiceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*InvoiceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &InvoiceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Invoice.
func (c *InvoiceClient) Update() *InvoiceUpdate {
	mutation := newInvoiceMutation(c.config, OpUpdate)
	return &InvoiceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *InvoiceClient) UpdateOne(i *Invoice) *InvoiceUpdateOne {
	mutation := newInvoiceMutation(c.config, OpUpdateOne, withInvoice(i))
	return &InvoiceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *InvoiceClient) UpdateOneID(id uuid.UUID) *InvoiceUpdateOne {
	mutation := newInvoiceMutation(c.config, OpUpdateOne, withInvoiceID(id))
	return &InvoiceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Invoice.
func (c *InvoiceClient) Delete() *InvoiceDelete {
	mutation := newInvoiceMutation(c.config, OpDelete)
	return &InvoiceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *InvoiceClient) DeleteOne(i *Invoice) *InvoiceDeleteOne {
	return c.DeleteOneID(i.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *InvoiceClient) DeleteOneID(id uuid.UUID) *InvoiceDeleteOne {
	builder := c.Delete().Where(invoice.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &InvoiceDeleteOne{builder}
}

// Query returns a query builder for Invoice.
func (c *InvoiceClient) Query() *InvoiceQuery {
	return &InvoiceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeInvoice},
		inters: c.Interceptors(),
	}
}

// Get returns a Invoice entity by its id.
func (c *InvoiceClient) Get(ctx context.Context, id uuid.UUID) (*Invoice, error) {
	return c.Query().Where(invoice.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *InvoiceClient) GetX(ctx context.Context, id uuid.UUID) *Invoice {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOrder queries the order edge of a Invoice.
func (c *InvoiceClient) QueryOrder(i *Invoice) *OrderQuery {
	query := (&OrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(invoice.Table, invoice.FieldID, id),
			sqlgraph.To(order.Table, order.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, invoice.OrderTable, invoice.OrderColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *InvoiceClient) Hooks() []Hook {
	return c.hooks.Invoice
}

// Interceptors returns the client interceptors.
func (c *InvoiceClient) Interceptors() []Interceptor {
	return c.inters.Invoice
}

func (c *InvoiceClient) mutate(ctx context.Context, m *InvoiceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&InvoiceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&InvoiceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&InvoiceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&InvoiceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Invoice mutation op: %q", m.Op())
	}
}

// InvoiceLineItemClient is a client for the InvoiceLineItem schema.
type InvoiceLineItemClient struct {
	config
}

// NewInvoiceLineItemClient returns a client for the InvoiceLineItem from the given config.
func NewInvoiceLineItemClient(c config) *InvoiceLineItemClient {
	return &InvoiceLineItemClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `invoicelineitem.Hooks(f(g(h())))`.
func (c *InvoiceLineItemClient) Use(hooks ...Hook) {
	c.hooks.InvoiceLineItem = append(c.hooks.InvoiceLineItem, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `invoicelineitem.Intercept(f(g(h())))`.
func (c *InvoiceLineItemClient) Intercept(interceptors ...Interceptor) {
	c.inters.InvoiceLineItem = append(c.inters.InvoiceLineItem, interceptors...)
}

// Create returns a builder for creating a InvoiceLineItem entity.
func (c *InvoiceLineItemClient) Create() *InvoiceLineItemCreate {
	mutation := newInvoiceLineItemMutation(c.config, OpCreate)
	return &InvoiceLineItemCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of InvoiceLineItem entities.
func (c *InvoiceLineItemClient) CreateBulk(builders ...*InvoiceLineItemCreate) *InvoiceLineItemCreateBulk {
	return &InvoiceLineItemCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *InvoiceLineItemClient) MapCreateBulk(slice any, setFunc func(*InvoiceLineItemCreate, int)) *InvoiceLineItemCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &InvoiceLineItemCreateBulk{err: fmt.Errorf("calling to InvoiceLineItemClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*InvoiceLineItemCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &InvoiceLineItemCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for InvoiceLineItem.
func (c *InvoiceLineItemClient) Update() *InvoiceLineItemUpdate {
	mutation := newInvoiceLineItemMutation(c.config, OpUpdate)
	return &InvoiceLineItemUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *InvoiceLineItemClient) UpdateOne(ili *InvoiceLineItem) *InvoiceLineItemUpdateOne {
	mutation := newInvoiceLineItemMutation(c.config, OpUpdateOne, withInvoiceLineItem(ili))
	return &InvoiceLineItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *InvoiceLineItemClient) UpdateOneID(id uuid.UUID) *InvoiceLineItemUpdateOne {
	mutation := newInvoiceLineItemMutation(c.config, OpUpdateOne, withInvoiceLineItemID(id))
	return &InvoiceLineItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for InvoiceLineItem.
func (c *InvoiceLineItemClient) Delete() *InvoiceLineItemDelete {
	mutation := newInvoiceLineItemMutation(c.config, OpDelete)
	return &InvoiceLineItemDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *InvoiceLineItemClient) DeleteOne(ili *InvoiceLineItem) *InvoiceLineItemDeleteOne {
	return c.DeleteOneID(ili.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *InvoiceLineItemClient) DeleteOneID(id uuid.UUID) *InvoiceLineItemDeleteOne {
	builder := c.Delete().Where(invoicelineitem.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &InvoiceLineItemDeleteOne{builder}
}

// Query returns a query builder for InvoiceLineItem.
func (c *InvoiceLineItemClient) Query() *InvoiceLineItemQuery {
	return &InvoiceLineItemQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeInvoiceLineItem},
		inters: c.Interceptors(),
	}
}

// Get returns a InvoiceLineItem entity by its id.
func (c *InvoiceLineItemClient) Get(ctx context.Context, id uuid.UUID) (*InvoiceLineItem, error) {
	return c.Query().Where(invoicelineitem.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *InvoiceLineItemClient) GetX(ctx context.Context, id uuid.UUID) *InvoiceLineItem {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryInvoice queries the invoice edge of a InvoiceLineItem.
func (c *InvoiceLineItemClient) QueryInvoice(ili *InvoiceLineItem) *InvoiceQuery {
	query := (&InvoiceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ili.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(invoicelineitem.Table, invoicelineitem.FieldID, id),
			sqlgraph.To(invoice.Table, invoice.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, invoicelineitem.InvoiceTable, invoicelineitem.InvoiceColumn),
		)
		fromV = sqlgraph.Neighbors(ili.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrderLineItem queries the order_line_item edge of a InvoiceLineItem.
func (c *InvoiceLineItemClient) QueryOrderLineItem(ili *InvoiceLineItem) *OrderLineItemQuery {
	query := (&OrderLineItemClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ili.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(invoicelineitem.Table, invoicelineitem.FieldID, id),
			sqlgraph.To(orderlineitem.Table, orderlineitem.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, invoicelineitem.OrderLineItemTable, invoicelineitem.OrderLineItemColumn),
		)
		fromV = sqlgraph.Neighbors(ili.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *InvoiceLineItemClient) Hooks() []Hook {
	return c.hooks.InvoiceLineItem
}

// Interceptors returns the client interceptors.
func (c *InvoiceLineItemClient) Interceptors() []Interceptor {
	return c.inters.InvoiceLineItem
}

func (c *InvoiceLineItemClient) mutate(ctx context.Context, m *InvoiceLineItemMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&InvoiceLineItemCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&InvoiceLineItemUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&InvoiceLineItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&InvoiceLineItemDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown InvoiceLineItem mutation op: %q", m.Op())
	}
}

// MessageClient is a client for the Message schema.
type MessageClient struct {
	config
}

// NewMessageClient returns a client for the Message from the given config.
func NewMessageClient(c config) *MessageClient {
	return &MessageClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `message.Hooks(f(g(h())))`.
func (c *MessageClient) Use(hooks ...Hook) {
	c.hooks.Message = append(c.hooks.Message, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `message.Intercept(f(g(h())))`.
func (c *MessageClient) Intercept(interceptors ...Interceptor) {
	c.inters.Message = append(c.inters.Message, interceptors...)
}

// Create returns a builder for creating a Message entity.
func (c *MessageClient) Create() *MessageCreate {
	mutation := newMessageMutation(c.config, OpCreate)
	return &MessageCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Message entities.
func (c *MessageClient) CreateBulk(builders ...*MessageCreate) *MessageCreateBulk {
	return &MessageCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MessageClient) MapCreateBulk(slice any, setFunc func(*MessageCreate, int)) *MessageCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MessageCreateBulk{err: fmt.Errorf("calling to MessageClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MessageCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MessageCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Message.
func (c *MessageClient) Update() *MessageUpdate {
	mutation := newMessageMutation(c.config, OpUpdate)
	return &MessageUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MessageClient) UpdateOne(m *Message) *MessageUpdateOne {
	mutation := newMessageMutation(c.config, OpUpdateOne, withMessage(m))
	return &MessageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MessageClient) UpdateOneID(id uuid.UUID) *MessageUpdateOne {
	mutation := newMessageMutation(c.config, OpUpdateOne, withMessageID(id))
	return &MessageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Message.
func (c *MessageClient) Delete() *MessageDelete {
	mutation := newMessageMutation(c.config, OpDelete)
	return &MessageDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MessageClient) DeleteOne(m *Message) *MessageDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MessageClient) DeleteOneID(id uuid.UUID) *MessageDeleteOne {
	builder := c.Delete().Where(message.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MessageDeleteOne{builder}
}

// Query returns a query builder for Message.
func (c *MessageClient) Query() *MessageQuery {
	return &MessageQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMessage},
		inters: c.Interceptors(),
	}
}

// Get returns a Message entity by its id.
func (c *MessageClient) Get(ctx context.Context, id uuid.UUID) (*Message, error) {
	return c.Query().Where(message.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MessageClient) GetX(ctx context.Context, id uuid.UUID) *Message {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryConversation queries the conversation edge of a Message.
func (c *MessageClient) QueryConversation(m *Message) *ConversationQuery {
	query := (&ConversationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(message.Table, message.FieldID, id),
			sqlgraph.To(conversation.Table, conversation.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, message.ConversationTable, message.ConversationColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySender queries the sender edge of a Message.
func (c *MessageClient) QuerySender(m *Message) *PersonQuery {
	query := (&PersonClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(message.Table, message.FieldID, id),
			sqlgraph.To(person.Table, person.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, message.SenderTable, message.SenderColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MessageClient) Hooks() []Hook {
	return c.hooks.Message
}

// Interceptors returns the client interceptors.
func (c *MessageClient) Interceptors() []Interceptor {
	return c.inters.Message
}

func (c *MessageClient) mutate(ctx context.Context, m *MessageMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MessageCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MessageUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MessageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MessageDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Message mutation op: %q", m.Op())
	}
}

// OrderClient is a client for the Order schema.
type OrderClient struct {
	config
}

// NewOrderClient returns a client for the Order from the given config.
func NewOrderClient(c config) *OrderClient {
	return &OrderClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `order.Hooks(f(g(h())))`.
func (c *OrderClient) Use(hooks ...Hook) {
	c.hooks.Order = append(c.hooks.Order, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `order.Intercept(f(g(h())))`.
func (c *OrderClient) Intercept(interceptors ...Interceptor) {
	c.inters.Order = append(c.inters.Order, interceptors...)
}

// Create returns a builder for creating a Order entity.
func (c *OrderClient) Create() *OrderCreate {
	mutation := newOrderMutation(c.config, OpCreate)
	return &OrderCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Order entities.
func (c *OrderClient) CreateBulk(builders ...*OrderCreate) *OrderCreateBulk {
	return &OrderCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrderClient) MapCreateBulk(slice any, setFunc func(*OrderCreate, int)) *OrderCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrderCreateBulk{err: fmt.Errorf("calling to OrderClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrderCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrderCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Order.
func (c *OrderClient) Update() *OrderUpdate {
	mutation := newOrderMutation(c.config, OpUpdate)
	return &OrderUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrderClient) UpdateOne(o *Order) *OrderUpdateOne {
	mutation := newOrderMutation(c.config, OpUpdateOne, withOrder(o))
	return &OrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrderClient) UpdateOneID(id uuid.UUID) *OrderUpdateOne {
	mutation := newOrderMutation(c.config, OpUpdateOne, withOrderID(id))
	return &OrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Order.
func (c *OrderClient) Delete() *OrderDelete {
	mutation := newOrderMutation(c.config, OpDelete)
	return &OrderDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrderClient) DeleteOne(o *Order) *OrderDeleteOne {
	return c.DeleteOneID(o.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrderClient) DeleteOneID(id uuid.UUID) *OrderDeleteOne {
	builder := c.Delete().Where(order.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrderDeleteOne{builder}
}

// Query returns a query builder for Order.
func (c *OrderClient) Query() *OrderQuery {
	return &OrderQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrder},
		inters: c.Interceptors(),
	}
}

// Get returns a Order entity by its id.
func (c *OrderClient) Get(ctx context.Context, id uuid.UUID) (*Order, error) {
	return c.Query().Where(order.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrderClient) GetX(ctx context.Context, id uuid.UUID) *Order {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCustomer queries the customer edge of a Order.
func (c *OrderClient) QueryCustomer(o *Order) *PersonQuery {
	query := (&PersonClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(order.Table, order.FieldID, id),
			sqlgraph.To(person.Table, person.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, order.CustomerTable, order.CustomerColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCreator queries the creator edge of a Order.
func (c *OrderClient) QueryCreator(o *Order) *PersonQuery {
	query := (&PersonClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(order.Table, order.FieldID, id),
			sqlgraph.To(person.Table, person.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, order.CreatorTable, order.CreatorColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParentOrder queries the parent_order edge of a Order.
func (c *OrderClient) QueryParentOrder(o *Order) *OrderQuery {
	query := (&OrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(order.Table, order.FieldID, id),
			sqlgraph.To(order.Table, order.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, order.ParentOrderTable, order.ParentOrderColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrderStatus queries the order_status edge of a Order.
func (c *OrderClient) QueryOrderStatus(o *Order) *OrderStatusCodeQuery {
	query := (&OrderStatusCodeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(order.Table, order.FieldID, id),
			sqlgraph.To(orderstatuscode.Table, orderstatuscode.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, order.OrderStatusTable, order.OrderStatusColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryManagementStaff queries the management_staff edge of a Order.
func (c *OrderClient) QueryManagementStaff(o *Order) *PersonQuery {
	query := (&PersonClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(order.Table, order.FieldID, id),
			sqlgraph.To(person.Table, person.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, order.ManagementStaffTable, order.ManagementStaffColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWarehouseStaff queries the warehouse_staff edge of a Order.
func (c *OrderClient) QueryWarehouseStaff(o *Order) *PersonQuery {
	query := (&PersonClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(order.Table, order.FieldID, id),
			sqlgraph.To(person.Table, person.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, order.WarehouseStaffTable, order.WarehouseStaffColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDeliveryStaff queries the delivery_staff edge of a Order.
func (c *OrderClient) QueryDeliveryStaff(o *Order) *PersonQuery {
	query := (&PersonClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(order.Table, order.FieldID, id),
			sqlgraph.To(person.Table, person.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, order.DeliveryStaffTable, order.DeliveryStaffColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrderClient) Hooks() []Hook {
	return c.hooks.Order
}

// Interceptors returns the client interceptors.
func (c *OrderClient) Interceptors() []Interceptor {
	return c.inters.Order
}

func (c *OrderClient) mutate(ctx context.Context, m *OrderMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrderCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrderUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrderDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Order mutation op: %q", m.Op())
	}
}

// OrderLineItemClient is a client for the OrderLineItem schema.
type OrderLineItemClient struct {
	config
}

// NewOrderLineItemClient returns a client for the OrderLineItem from the given config.
func NewOrderLineItemClient(c config) *OrderLineItemClient {
	return &OrderLineItemClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `orderlineitem.Hooks(f(g(h())))`.
func (c *OrderLineItemClient) Use(hooks ...Hook) {
	c.hooks.OrderLineItem = append(c.hooks.OrderLineItem, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `orderlineitem.Intercept(f(g(h())))`.
func (c *OrderLineItemClient) Intercept(interceptors ...Interceptor) {
	c.inters.OrderLineItem = append(c.inters.OrderLineItem, interceptors...)
}

// Create returns a builder for creating a OrderLineItem entity.
func (c *OrderLineItemClient) Create() *OrderLineItemCreate {
	mutation := newOrderLineItemMutation(c.config, OpCreate)
	return &OrderLineItemCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OrderLineItem entities.
func (c *OrderLineItemClient) CreateBulk(builders ...*OrderLineItemCreate) *OrderLineItemCreateBulk {
	return &OrderLineItemCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrderLineItemClient) MapCreateBulk(slice any, setFunc func(*OrderLineItemCreate, int)) *OrderLineItemCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrderLineItemCreateBulk{err: fmt.Errorf("calling to OrderLineItemClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrderLineItemCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrderLineItemCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OrderLineItem.
func (c *OrderLineItemClient) Update() *OrderLineItemUpdate {
	mutation := newOrderLineItemMutation(c.config, OpUpdate)
	return &OrderLineItemUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrderLineItemClient) UpdateOne(oli *OrderLineItem) *OrderLineItemUpdateOne {
	mutation := newOrderLineItemMutation(c.config, OpUpdateOne, withOrderLineItem(oli))
	return &OrderLineItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrderLineItemClient) UpdateOneID(id uuid.UUID) *OrderLineItemUpdateOne {
	mutation := newOrderLineItemMutation(c.config, OpUpdateOne, withOrderLineItemID(id))
	return &OrderLineItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OrderLineItem.
func (c *OrderLineItemClient) Delete() *OrderLineItemDelete {
	mutation := newOrderLineItemMutation(c.config, OpDelete)
	return &OrderLineItemDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrderLineItemClient) DeleteOne(oli *OrderLineItem) *OrderLineItemDeleteOne {
	return c.DeleteOneID(oli.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrderLineItemClient) DeleteOneID(id uuid.UUID) *OrderLineItemDeleteOne {
	builder := c.Delete().Where(orderlineitem.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrderLineItemDeleteOne{builder}
}

// Query returns a query builder for OrderLineItem.
func (c *OrderLineItemClient) Query() *OrderLineItemQuery {
	return &OrderLineItemQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrderLineItem},
		inters: c.Interceptors(),
	}
}

// Get returns a OrderLineItem entity by its id.
func (c *OrderLineItemClient) Get(ctx context.Context, id uuid.UUID) (*OrderLineItem, error) {
	return c.Query().Where(orderlineitem.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrderLineItemClient) GetX(ctx context.Context, id uuid.UUID) *OrderLineItem {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOrder queries the order edge of a OrderLineItem.
func (c *OrderLineItemClient) QueryOrder(oli *OrderLineItem) *OrderQuery {
	query := (&OrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := oli.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(orderlineitem.Table, orderlineitem.FieldID, id),
			sqlgraph.To(order.Table, order.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, orderlineitem.OrderTable, orderlineitem.OrderColumn),
		)
		fromV = sqlgraph.Neighbors(oli.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProduct queries the product edge of a OrderLineItem.
func (c *OrderLineItemClient) QueryProduct(oli *OrderLineItem) *ProductQuery {
	query := (&ProductClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := oli.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(orderlineitem.Table, orderlineitem.FieldID, id),
			sqlgraph.To(product.Table, product.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, orderlineitem.ProductTable, orderlineitem.ProductColumn),
		)
		fromV = sqlgraph.Neighbors(oli.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrderLineItemClient) Hooks() []Hook {
	return c.hooks.OrderLineItem
}

// Interceptors returns the client interceptors.
func (c *OrderLineItemClient) Interceptors() []Interceptor {
	return c.inters.OrderLineItem
}

func (c *OrderLineItemClient) mutate(ctx context.Context, m *OrderLineItemMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrderLineItemCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrderLineItemUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrderLineItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrderLineItemDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OrderLineItem mutation op: %q", m.Op())
	}
}

// OrderStatusCodeClient is a client for the OrderStatusCode schema.
type OrderStatusCodeClient struct {
	config
}

// NewOrderStatusCodeClient returns a client for the OrderStatusCode from the given config.
func NewOrderStatusCodeClient(c config) *OrderStatusCodeClient {
	return &OrderStatusCodeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `orderstatuscode.Hooks(f(g(h())))`.
func (c *OrderStatusCodeClient) Use(hooks ...Hook) {
	c.hooks.OrderStatusCode = append(c.hooks.OrderStatusCode, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `orderstatuscode.Intercept(f(g(h())))`.
func (c *OrderStatusCodeClient) Intercept(interceptors ...Interceptor) {
	c.inters.OrderStatusCode = append(c.inters.OrderStatusCode, interceptors...)
}

// Create returns a builder for creating a OrderStatusCode entity.
func (c *OrderStatusCodeClient) Create() *OrderStatusCodeCreate {
	mutation := newOrderStatusCodeMutation(c.config, OpCreate)
	return &OrderStatusCodeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OrderStatusCode entities.
func (c *OrderStatusCodeClient) CreateBulk(builders ...*OrderStatusCodeCreate) *OrderStatusCodeCreateBulk {
	return &OrderStatusCodeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrderStatusCodeClient) MapCreateBulk(slice any, setFunc func(*OrderStatusCodeCreate, int)) *OrderStatusCodeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrderStatusCodeCreateBulk{err: fmt.Errorf("calling to OrderStatusCodeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrderStatusCodeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrderStatusCodeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OrderStatusCode.
func (c *OrderStatusCodeClient) Update() *OrderStatusCodeUpdate {
	mutation := newOrderStatusCodeMutation(c.config, OpUpdate)
	return &OrderStatusCodeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrderStatusCodeClient) UpdateOne(osc *OrderStatusCode) *OrderStatusCodeUpdateOne {
	mutation := newOrderStatusCodeMutation(c.config, OpUpdateOne, withOrderStatusCode(osc))
	return &OrderStatusCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrderStatusCodeClient) UpdateOneID(id int) *OrderStatusCodeUpdateOne {
	mutation := newOrderStatusCodeMutation(c.config, OpUpdateOne, withOrderStatusCodeID(id))
	return &OrderStatusCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OrderStatusCode.
func (c *OrderStatusCodeClient) Delete() *OrderStatusCodeDelete {
	mutation := newOrderStatusCodeMutation(c.config, OpDelete)
	return &OrderStatusCodeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrderStatusCodeClient) DeleteOne(osc *OrderStatusCode) *OrderStatusCodeDeleteOne {
	return c.DeleteOneID(osc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrderStatusCodeClient) DeleteOneID(id int) *OrderStatusCodeDeleteOne {
	builder := c.Delete().Where(orderstatuscode.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrderStatusCodeDeleteOne{builder}
}

// Query returns a query builder for OrderStatusCode.
func (c *OrderStatusCodeClient) Query() *OrderStatusCodeQuery {
	return &OrderStatusCodeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrderStatusCode},
		inters: c.Interceptors(),
	}
}

// Get returns a OrderStatusCode entity by its id.
func (c *OrderStatusCodeClient) Get(ctx context.Context, id int) (*OrderStatusCode, error) {
	return c.Query().Where(orderstatuscode.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrderStatusCodeClient) GetX(ctx context.Context, id int) *OrderStatusCode {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *OrderStatusCodeClient) Hooks() []Hook {
	return c.hooks.OrderStatusCode
}

// Interceptors returns the client interceptors.
func (c *OrderStatusCodeClient) Interceptors() []Interceptor {
	return c.inters.OrderStatusCode
}

func (c *OrderStatusCodeClient) mutate(ctx context.Context, m *OrderStatusCodeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrderStatusCodeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrderStatusCodeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrderStatusCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrderStatusCodeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OrderStatusCode mutation op: %q", m.Op())
	}
}

// PersonClient is a client for the Person schema.
type PersonClient struct {
	config
}

// NewPersonClient returns a client for the Person from the given config.
func NewPersonClient(c config) *PersonClient {
	return &PersonClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `person.Hooks(f(g(h())))`.
func (c *PersonClient) Use(hooks ...Hook) {
	c.hooks.Person = append(c.hooks.Person, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `person.Intercept(f(g(h())))`.
func (c *PersonClient) Intercept(interceptors ...Interceptor) {
	c.inters.Person = append(c.inters.Person, interceptors...)
}

// Create returns a builder for creating a Person entity.
func (c *PersonClient) Create() *PersonCreate {
	mutation := newPersonMutation(c.config, OpCreate)
	return &PersonCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Person entities.
func (c *PersonClient) CreateBulk(builders ...*PersonCreate) *PersonCreateBulk {
	return &PersonCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PersonClient) MapCreateBulk(slice any, setFunc func(*PersonCreate, int)) *PersonCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PersonCreateBulk{err: fmt.Errorf("calling to PersonClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PersonCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PersonCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Person.
func (c *PersonClient) Update() *PersonUpdate {
	mutation := newPersonMutation(c.config, OpUpdate)
	return &PersonUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PersonClient) UpdateOne(pe *Person) *PersonUpdateOne {
	mutation := newPersonMutation(c.config, OpUpdateOne, withPerson(pe))
	return &PersonUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PersonClient) UpdateOneID(id uuid.UUID) *PersonUpdateOne {
	mutation := newPersonMutation(c.config, OpUpdateOne, withPersonID(id))
	return &PersonUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Person.
func (c *PersonClient) Delete() *PersonDelete {
	mutation := newPersonMutation(c.config, OpDelete)
	return &PersonDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PersonClient) DeleteOne(pe *Person) *PersonDeleteOne {
	return c.DeleteOneID(pe.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PersonClient) DeleteOneID(id uuid.UUID) *PersonDeleteOne {
	builder := c.Delete().Where(person.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PersonDeleteOne{builder}
}

// Query returns a query builder for Person.
func (c *PersonClient) Query() *PersonQuery {
	return &PersonQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePerson},
		inters: c.Interceptors(),
	}
}

// Get returns a Person entity by its id.
func (c *PersonClient) Get(ctx context.Context, id uuid.UUID) (*Person, error) {
	return c.Query().Where(person.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PersonClient) GetX(ctx context.Context, id uuid.UUID) *Person {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *PersonClient) Hooks() []Hook {
	return c.hooks.Person
}

// Interceptors returns the client interceptors.
func (c *PersonClient) Interceptors() []Interceptor {
	return c.inters.Person
}

func (c *PersonClient) mutate(ctx context.Context, m *PersonMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PersonCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PersonUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PersonUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PersonDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Person mutation op: %q", m.Op())
	}
}

// ProductClient is a client for the Product schema.
type ProductClient struct {
	config
}

// NewProductClient returns a client for the Product from the given config.
func NewProductClient(c config) *ProductClient {
	return &ProductClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `product.Hooks(f(g(h())))`.
func (c *ProductClient) Use(hooks ...Hook) {
	c.hooks.Product = append(c.hooks.Product, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `product.Intercept(f(g(h())))`.
func (c *ProductClient) Intercept(interceptors ...Interceptor) {
	c.inters.Product = append(c.inters.Product, interceptors...)
}

// Create returns a builder for creating a Product entity.
func (c *ProductClient) Create() *ProductCreate {
	mutation := newProductMutation(c.config, OpCreate)
	return &ProductCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Product entities.
func (c *ProductClient) CreateBulk(builders ...*ProductCreate) *ProductCreateBulk {
	return &ProductCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProductClient) MapCreateBulk(slice any, setFunc func(*ProductCreate, int)) *ProductCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProductCreateBulk{err: fmt.Errorf("calling to ProductClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProductCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProductCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Product.
func (c *ProductClient) Update() *ProductUpdate {
	mutation := newProductMutation(c.config, OpUpdate)
	return &ProductUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProductClient) UpdateOne(pr *Product) *ProductUpdateOne {
	mutation := newProductMutation(c.config, OpUpdateOne, withProduct(pr))
	return &ProductUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProductClient) UpdateOneID(id string) *ProductUpdateOne {
	mutation := newProductMutation(c.config, OpUpdateOne, withProductID(id))
	return &ProductUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Product.
func (c *ProductClient) Delete() *ProductDelete {
	mutation := newProductMutation(c.config, OpDelete)
	return &ProductDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProductClient) DeleteOne(pr *Product) *ProductDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProductClient) DeleteOneID(id string) *ProductDeleteOne {
	builder := c.Delete().Where(product.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProductDeleteOne{builder}
}

// Query returns a query builder for Product.
func (c *ProductClient) Query() *ProductQuery {
	return &ProductQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProduct},
		inters: c.Interceptors(),
	}
}

// Get returns a Product entity by its id.
func (c *ProductClient) Get(ctx context.Context, id string) (*Product, error) {
	return c.Query().Where(product.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProductClient) GetX(ctx context.Context, id string) *Product {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTags queries the tags edge of a Product.
func (c *ProductClient) QueryTags(pr *Product) *TagQuery {
	query := (&TagClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(product.Table, product.FieldID, id),
			sqlgraph.To(tag.Table, tag.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, product.TagsTable, product.TagsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProductTags queries the product_tags edge of a Product.
func (c *ProductClient) QueryProductTags(pr *Product) *ProductTagQuery {
	query := (&ProductTagClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(product.Table, product.FieldID, id),
			sqlgraph.To(producttag.Table, producttag.ProductsColumn),
			sqlgraph.Edge(sqlgraph.O2M, true, product.ProductTagsTable, product.ProductTagsColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProductClient) Hooks() []Hook {
	hooks := c.hooks.Product
	return append(hooks[:len(hooks):len(hooks)], product.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ProductClient) Interceptors() []Interceptor {
	return c.inters.Product
}

func (c *ProductClient) mutate(ctx context.Context, m *ProductMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProductCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProductUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProductUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProductDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Product mutation op: %q", m.Op())
	}
}

// ProductImageClient is a client for the ProductImage schema.
type ProductImageClient struct {
	config
}

// NewProductImageClient returns a client for the ProductImage from the given config.
func NewProductImageClient(c config) *ProductImageClient {
	return &ProductImageClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `productimage.Hooks(f(g(h())))`.
func (c *ProductImageClient) Use(hooks ...Hook) {
	c.hooks.ProductImage = append(c.hooks.ProductImage, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `productimage.Intercept(f(g(h())))`.
func (c *ProductImageClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProductImage = append(c.inters.ProductImage, interceptors...)
}

// Create returns a builder for creating a ProductImage entity.
func (c *ProductImageClient) Create() *ProductImageCreate {
	mutation := newProductImageMutation(c.config, OpCreate)
	return &ProductImageCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProductImage entities.
func (c *ProductImageClient) CreateBulk(builders ...*ProductImageCreate) *ProductImageCreateBulk {
	return &ProductImageCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProductImageClient) MapCreateBulk(slice any, setFunc func(*ProductImageCreate, int)) *ProductImageCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProductImageCreateBulk{err: fmt.Errorf("calling to ProductImageClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProductImageCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProductImageCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProductImage.
func (c *ProductImageClient) Update() *ProductImageUpdate {
	mutation := newProductImageMutation(c.config, OpUpdate)
	return &ProductImageUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProductImageClient) UpdateOne(pi *ProductImage) *ProductImageUpdateOne {
	mutation := newProductImageMutation(c.config, OpUpdateOne, withProductImage(pi))
	return &ProductImageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProductImageClient) UpdateOneID(id uuid.UUID) *ProductImageUpdateOne {
	mutation := newProductImageMutation(c.config, OpUpdateOne, withProductImageID(id))
	return &ProductImageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProductImage.
func (c *ProductImageClient) Delete() *ProductImageDelete {
	mutation := newProductImageMutation(c.config, OpDelete)
	return &ProductImageDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProductImageClient) DeleteOne(pi *ProductImage) *ProductImageDeleteOne {
	return c.DeleteOneID(pi.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProductImageClient) DeleteOneID(id uuid.UUID) *ProductImageDeleteOne {
	builder := c.Delete().Where(productimage.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProductImageDeleteOne{builder}
}

// Query returns a query builder for ProductImage.
func (c *ProductImageClient) Query() *ProductImageQuery {
	return &ProductImageQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProductImage},
		inters: c.Interceptors(),
	}
}

// Get returns a ProductImage entity by its id.
func (c *ProductImageClient) Get(ctx context.Context, id uuid.UUID) (*ProductImage, error) {
	return c.Query().Where(productimage.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProductImageClient) GetX(ctx context.Context, id uuid.UUID) *ProductImage {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProduct queries the product edge of a ProductImage.
func (c *ProductImageClient) QueryProduct(pi *ProductImage) *ProductQuery {
	query := (&ProductClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(productimage.Table, productimage.FieldID, id),
			sqlgraph.To(product.Table, product.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, productimage.ProductTable, productimage.ProductColumn),
		)
		fromV = sqlgraph.Neighbors(pi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProductImageClient) Hooks() []Hook {
	return c.hooks.ProductImage
}

// Interceptors returns the client interceptors.
func (c *ProductImageClient) Interceptors() []Interceptor {
	return c.inters.ProductImage
}

func (c *ProductImageClient) mutate(ctx context.Context, m *ProductImageMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProductImageCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProductImageUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProductImageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProductImageDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ProductImage mutation op: %q", m.Op())
	}
}

// ProductTagClient is a client for the ProductTag schema.
type ProductTagClient struct {
	config
}

// NewProductTagClient returns a client for the ProductTag from the given config.
func NewProductTagClient(c config) *ProductTagClient {
	return &ProductTagClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `producttag.Hooks(f(g(h())))`.
func (c *ProductTagClient) Use(hooks ...Hook) {
	c.hooks.ProductTag = append(c.hooks.ProductTag, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `producttag.Intercept(f(g(h())))`.
func (c *ProductTagClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProductTag = append(c.inters.ProductTag, interceptors...)
}

// Create returns a builder for creating a ProductTag entity.
func (c *ProductTagClient) Create() *ProductTagCreate {
	mutation := newProductTagMutation(c.config, OpCreate)
	return &ProductTagCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProductTag entities.
func (c *ProductTagClient) CreateBulk(builders ...*ProductTagCreate) *ProductTagCreateBulk {
	return &ProductTagCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProductTagClient) MapCreateBulk(slice any, setFunc func(*ProductTagCreate, int)) *ProductTagCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProductTagCreateBulk{err: fmt.Errorf("calling to ProductTagClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProductTagCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProductTagCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProductTag.
func (c *ProductTagClient) Update() *ProductTagUpdate {
	mutation := newProductTagMutation(c.config, OpUpdate)
	return &ProductTagUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProductTagClient) UpdateOne(pt *ProductTag) *ProductTagUpdateOne {
	mutation := newProductTagMutation(c.config, OpUpdateOne)
	mutation.products = &pt.ProductID
	mutation.tags = &pt.TagID
	return &ProductTagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProductTag.
func (c *ProductTagClient) Delete() *ProductTagDelete {
	mutation := newProductTagMutation(c.config, OpDelete)
	return &ProductTagDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Query returns a query builder for ProductTag.
func (c *ProductTagClient) Query() *ProductTagQuery {
	return &ProductTagQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProductTag},
		inters: c.Interceptors(),
	}
}

// QueryProducts queries the products edge of a ProductTag.
func (c *ProductTagClient) QueryProducts(pt *ProductTag) *ProductQuery {
	return c.Query().
		Where(producttag.ProductID(pt.ProductID), producttag.TagID(pt.TagID)).
		QueryProducts()
}

// QueryTags queries the tags edge of a ProductTag.
func (c *ProductTagClient) QueryTags(pt *ProductTag) *TagQuery {
	return c.Query().
		Where(producttag.ProductID(pt.ProductID), producttag.TagID(pt.TagID)).
		QueryTags()
}

// Hooks returns the client hooks.
func (c *ProductTagClient) Hooks() []Hook {
	return c.hooks.ProductTag
}

// Interceptors returns the client interceptors.
func (c *ProductTagClient) Interceptors() []Interceptor {
	return c.inters.ProductTag
}

func (c *ProductTagClient) mutate(ctx context.Context, m *ProductTagMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProductTagCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProductTagUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProductTagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProductTagDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ProductTag mutation op: %q", m.Op())
	}
}

// TagClient is a client for the Tag schema.
type TagClient struct {
	config
}

// NewTagClient returns a client for the Tag from the given config.
func NewTagClient(c config) *TagClient {
	return &TagClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tag.Hooks(f(g(h())))`.
func (c *TagClient) Use(hooks ...Hook) {
	c.hooks.Tag = append(c.hooks.Tag, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tag.Intercept(f(g(h())))`.
func (c *TagClient) Intercept(interceptors ...Interceptor) {
	c.inters.Tag = append(c.inters.Tag, interceptors...)
}

// Create returns a builder for creating a Tag entity.
func (c *TagClient) Create() *TagCreate {
	mutation := newTagMutation(c.config, OpCreate)
	return &TagCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Tag entities.
func (c *TagClient) CreateBulk(builders ...*TagCreate) *TagCreateBulk {
	return &TagCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TagClient) MapCreateBulk(slice any, setFunc func(*TagCreate, int)) *TagCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TagCreateBulk{err: fmt.Errorf("calling to TagClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TagCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TagCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Tag.
func (c *TagClient) Update() *TagUpdate {
	mutation := newTagMutation(c.config, OpUpdate)
	return &TagUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TagClient) UpdateOne(t *Tag) *TagUpdateOne {
	mutation := newTagMutation(c.config, OpUpdateOne, withTag(t))
	return &TagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TagClient) UpdateOneID(id string) *TagUpdateOne {
	mutation := newTagMutation(c.config, OpUpdateOne, withTagID(id))
	return &TagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Tag.
func (c *TagClient) Delete() *TagDelete {
	mutation := newTagMutation(c.config, OpDelete)
	return &TagDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TagClient) DeleteOne(t *Tag) *TagDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TagClient) DeleteOneID(id string) *TagDeleteOne {
	builder := c.Delete().Where(tag.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TagDeleteOne{builder}
}

// Query returns a query builder for Tag.
func (c *TagClient) Query() *TagQuery {
	return &TagQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTag},
		inters: c.Interceptors(),
	}
}

// Get returns a Tag entity by its id.
func (c *TagClient) Get(ctx context.Context, id string) (*Tag, error) {
	return c.Query().Where(tag.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TagClient) GetX(ctx context.Context, id string) *Tag {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProducts queries the products edge of a Tag.
func (c *TagClient) QueryProducts(t *Tag) *ProductQuery {
	query := (&ProductClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tag.Table, tag.FieldID, id),
			sqlgraph.To(product.Table, product.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, tag.ProductsTable, tag.ProductsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProductTags queries the product_tags edge of a Tag.
func (c *TagClient) QueryProductTags(t *Tag) *ProductTagQuery {
	query := (&ProductTagClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tag.Table, tag.FieldID, id),
			sqlgraph.To(producttag.Table, producttag.TagsColumn),
			sqlgraph.Edge(sqlgraph.O2M, true, tag.ProductTagsTable, tag.ProductTagsColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TagClient) Hooks() []Hook {
	hooks := c.hooks.Tag
	return append(hooks[:len(hooks):len(hooks)], tag.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *TagClient) Interceptors() []Interceptor {
	return c.inters.Tag
}

func (c *TagClient) mutate(ctx context.Context, m *TagMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TagCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TagUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TagDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Tag mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Conversation, FinancialTransaction, Invoice, InvoiceLineItem, Message, Order,
		OrderLineItem, OrderStatusCode, Person, Product, ProductImage, ProductTag,
		Tag []ent.Hook
	}
	inters struct {
		Conversation, FinancialTransaction, Invoice, InvoiceLineItem, Message, Order,
		OrderLineItem, OrderStatusCode, Person, Product, ProductImage, ProductTag,
		Tag []ent.Interceptor
	}
)
