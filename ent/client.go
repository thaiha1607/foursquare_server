// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/google/uuid"
	"github.com/thaiha1607/foursquare_server/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/thaiha1607/foursquare_server/ent/conversation"
	"github.com/thaiha1607/foursquare_server/ent/financialtransaction"
	"github.com/thaiha1607/foursquare_server/ent/invoice"
	"github.com/thaiha1607/foursquare_server/ent/invoicelineitem"
	"github.com/thaiha1607/foursquare_server/ent/invoicestatuscode"
	"github.com/thaiha1607/foursquare_server/ent/invoicetype"
	"github.com/thaiha1607/foursquare_server/ent/message"
	"github.com/thaiha1607/foursquare_server/ent/messagetype"
	"github.com/thaiha1607/foursquare_server/ent/order"
	"github.com/thaiha1607/foursquare_server/ent/orderlineitem"
	"github.com/thaiha1607/foursquare_server/ent/orderstatuscode"
	"github.com/thaiha1607/foursquare_server/ent/ordertype"
	"github.com/thaiha1607/foursquare_server/ent/paymentmethod"
	"github.com/thaiha1607/foursquare_server/ent/product"
	"github.com/thaiha1607/foursquare_server/ent/producttag"
	"github.com/thaiha1607/foursquare_server/ent/producttype"
	"github.com/thaiha1607/foursquare_server/ent/tag"
	"github.com/thaiha1607/foursquare_server/ent/transactiontype"
	"github.com/thaiha1607/foursquare_server/ent/user"
	"github.com/thaiha1607/foursquare_server/ent/userrole"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Conversation is the client for interacting with the Conversation builders.
	Conversation *ConversationClient
	// FinancialTransaction is the client for interacting with the FinancialTransaction builders.
	FinancialTransaction *FinancialTransactionClient
	// Invoice is the client for interacting with the Invoice builders.
	Invoice *InvoiceClient
	// InvoiceLineItem is the client for interacting with the InvoiceLineItem builders.
	InvoiceLineItem *InvoiceLineItemClient
	// InvoiceStatusCode is the client for interacting with the InvoiceStatusCode builders.
	InvoiceStatusCode *InvoiceStatusCodeClient
	// InvoiceType is the client for interacting with the InvoiceType builders.
	InvoiceType *InvoiceTypeClient
	// Message is the client for interacting with the Message builders.
	Message *MessageClient
	// MessageType is the client for interacting with the MessageType builders.
	MessageType *MessageTypeClient
	// Order is the client for interacting with the Order builders.
	Order *OrderClient
	// OrderLineItem is the client for interacting with the OrderLineItem builders.
	OrderLineItem *OrderLineItemClient
	// OrderStatusCode is the client for interacting with the OrderStatusCode builders.
	OrderStatusCode *OrderStatusCodeClient
	// OrderType is the client for interacting with the OrderType builders.
	OrderType *OrderTypeClient
	// PaymentMethod is the client for interacting with the PaymentMethod builders.
	PaymentMethod *PaymentMethodClient
	// Product is the client for interacting with the Product builders.
	Product *ProductClient
	// ProductTag is the client for interacting with the ProductTag builders.
	ProductTag *ProductTagClient
	// ProductType is the client for interacting with the ProductType builders.
	ProductType *ProductTypeClient
	// Tag is the client for interacting with the Tag builders.
	Tag *TagClient
	// TransactionType is the client for interacting with the TransactionType builders.
	TransactionType *TransactionTypeClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// UserRole is the client for interacting with the UserRole builders.
	UserRole *UserRoleClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Conversation = NewConversationClient(c.config)
	c.FinancialTransaction = NewFinancialTransactionClient(c.config)
	c.Invoice = NewInvoiceClient(c.config)
	c.InvoiceLineItem = NewInvoiceLineItemClient(c.config)
	c.InvoiceStatusCode = NewInvoiceStatusCodeClient(c.config)
	c.InvoiceType = NewInvoiceTypeClient(c.config)
	c.Message = NewMessageClient(c.config)
	c.MessageType = NewMessageTypeClient(c.config)
	c.Order = NewOrderClient(c.config)
	c.OrderLineItem = NewOrderLineItemClient(c.config)
	c.OrderStatusCode = NewOrderStatusCodeClient(c.config)
	c.OrderType = NewOrderTypeClient(c.config)
	c.PaymentMethod = NewPaymentMethodClient(c.config)
	c.Product = NewProductClient(c.config)
	c.ProductTag = NewProductTagClient(c.config)
	c.ProductType = NewProductTypeClient(c.config)
	c.Tag = NewTagClient(c.config)
	c.TransactionType = NewTransactionTypeClient(c.config)
	c.User = NewUserClient(c.config)
	c.UserRole = NewUserRoleClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                  ctx,
		config:               cfg,
		Conversation:         NewConversationClient(cfg),
		FinancialTransaction: NewFinancialTransactionClient(cfg),
		Invoice:              NewInvoiceClient(cfg),
		InvoiceLineItem:      NewInvoiceLineItemClient(cfg),
		InvoiceStatusCode:    NewInvoiceStatusCodeClient(cfg),
		InvoiceType:          NewInvoiceTypeClient(cfg),
		Message:              NewMessageClient(cfg),
		MessageType:          NewMessageTypeClient(cfg),
		Order:                NewOrderClient(cfg),
		OrderLineItem:        NewOrderLineItemClient(cfg),
		OrderStatusCode:      NewOrderStatusCodeClient(cfg),
		OrderType:            NewOrderTypeClient(cfg),
		PaymentMethod:        NewPaymentMethodClient(cfg),
		Product:              NewProductClient(cfg),
		ProductTag:           NewProductTagClient(cfg),
		ProductType:          NewProductTypeClient(cfg),
		Tag:                  NewTagClient(cfg),
		TransactionType:      NewTransactionTypeClient(cfg),
		User:                 NewUserClient(cfg),
		UserRole:             NewUserRoleClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                  ctx,
		config:               cfg,
		Conversation:         NewConversationClient(cfg),
		FinancialTransaction: NewFinancialTransactionClient(cfg),
		Invoice:              NewInvoiceClient(cfg),
		InvoiceLineItem:      NewInvoiceLineItemClient(cfg),
		InvoiceStatusCode:    NewInvoiceStatusCodeClient(cfg),
		InvoiceType:          NewInvoiceTypeClient(cfg),
		Message:              NewMessageClient(cfg),
		MessageType:          NewMessageTypeClient(cfg),
		Order:                NewOrderClient(cfg),
		OrderLineItem:        NewOrderLineItemClient(cfg),
		OrderStatusCode:      NewOrderStatusCodeClient(cfg),
		OrderType:            NewOrderTypeClient(cfg),
		PaymentMethod:        NewPaymentMethodClient(cfg),
		Product:              NewProductClient(cfg),
		ProductTag:           NewProductTagClient(cfg),
		ProductType:          NewProductTypeClient(cfg),
		Tag:                  NewTagClient(cfg),
		TransactionType:      NewTransactionTypeClient(cfg),
		User:                 NewUserClient(cfg),
		UserRole:             NewUserRoleClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Conversation.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Conversation, c.FinancialTransaction, c.Invoice, c.InvoiceLineItem,
		c.InvoiceStatusCode, c.InvoiceType, c.Message, c.MessageType, c.Order,
		c.OrderLineItem, c.OrderStatusCode, c.OrderType, c.PaymentMethod, c.Product,
		c.ProductTag, c.ProductType, c.Tag, c.TransactionType, c.User, c.UserRole,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Conversation, c.FinancialTransaction, c.Invoice, c.InvoiceLineItem,
		c.InvoiceStatusCode, c.InvoiceType, c.Message, c.MessageType, c.Order,
		c.OrderLineItem, c.OrderStatusCode, c.OrderType, c.PaymentMethod, c.Product,
		c.ProductTag, c.ProductType, c.Tag, c.TransactionType, c.User, c.UserRole,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *ConversationMutation:
		return c.Conversation.mutate(ctx, m)
	case *FinancialTransactionMutation:
		return c.FinancialTransaction.mutate(ctx, m)
	case *InvoiceMutation:
		return c.Invoice.mutate(ctx, m)
	case *InvoiceLineItemMutation:
		return c.InvoiceLineItem.mutate(ctx, m)
	case *InvoiceStatusCodeMutation:
		return c.InvoiceStatusCode.mutate(ctx, m)
	case *InvoiceTypeMutation:
		return c.InvoiceType.mutate(ctx, m)
	case *MessageMutation:
		return c.Message.mutate(ctx, m)
	case *MessageTypeMutation:
		return c.MessageType.mutate(ctx, m)
	case *OrderMutation:
		return c.Order.mutate(ctx, m)
	case *OrderLineItemMutation:
		return c.OrderLineItem.mutate(ctx, m)
	case *OrderStatusCodeMutation:
		return c.OrderStatusCode.mutate(ctx, m)
	case *OrderTypeMutation:
		return c.OrderType.mutate(ctx, m)
	case *PaymentMethodMutation:
		return c.PaymentMethod.mutate(ctx, m)
	case *ProductMutation:
		return c.Product.mutate(ctx, m)
	case *ProductTagMutation:
		return c.ProductTag.mutate(ctx, m)
	case *ProductTypeMutation:
		return c.ProductType.mutate(ctx, m)
	case *TagMutation:
		return c.Tag.mutate(ctx, m)
	case *TransactionTypeMutation:
		return c.TransactionType.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	case *UserRoleMutation:
		return c.UserRole.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// ConversationClient is a client for the Conversation schema.
type ConversationClient struct {
	config
}

// NewConversationClient returns a client for the Conversation from the given config.
func NewConversationClient(c config) *ConversationClient {
	return &ConversationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `conversation.Hooks(f(g(h())))`.
func (c *ConversationClient) Use(hooks ...Hook) {
	c.hooks.Conversation = append(c.hooks.Conversation, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `conversation.Intercept(f(g(h())))`.
func (c *ConversationClient) Intercept(interceptors ...Interceptor) {
	c.inters.Conversation = append(c.inters.Conversation, interceptors...)
}

// Create returns a builder for creating a Conversation entity.
func (c *ConversationClient) Create() *ConversationCreate {
	mutation := newConversationMutation(c.config, OpCreate)
	return &ConversationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Conversation entities.
func (c *ConversationClient) CreateBulk(builders ...*ConversationCreate) *ConversationCreateBulk {
	return &ConversationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ConversationClient) MapCreateBulk(slice any, setFunc func(*ConversationCreate, int)) *ConversationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ConversationCreateBulk{err: fmt.Errorf("calling to ConversationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ConversationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ConversationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Conversation.
func (c *ConversationClient) Update() *ConversationUpdate {
	mutation := newConversationMutation(c.config, OpUpdate)
	return &ConversationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ConversationClient) UpdateOne(co *Conversation) *ConversationUpdateOne {
	mutation := newConversationMutation(c.config, OpUpdateOne, withConversation(co))
	return &ConversationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ConversationClient) UpdateOneID(id uuid.UUID) *ConversationUpdateOne {
	mutation := newConversationMutation(c.config, OpUpdateOne, withConversationID(id))
	return &ConversationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Conversation.
func (c *ConversationClient) Delete() *ConversationDelete {
	mutation := newConversationMutation(c.config, OpDelete)
	return &ConversationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ConversationClient) DeleteOne(co *Conversation) *ConversationDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ConversationClient) DeleteOneID(id uuid.UUID) *ConversationDeleteOne {
	builder := c.Delete().Where(conversation.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ConversationDeleteOne{builder}
}

// Query returns a query builder for Conversation.
func (c *ConversationClient) Query() *ConversationQuery {
	return &ConversationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeConversation},
		inters: c.Interceptors(),
	}
}

// Get returns a Conversation entity by its id.
func (c *ConversationClient) Get(ctx context.Context, id uuid.UUID) (*Conversation, error) {
	return c.Query().Where(conversation.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ConversationClient) GetX(ctx context.Context, id uuid.UUID) *Conversation {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUserOne queries the user_one edge of a Conversation.
func (c *ConversationClient) QueryUserOne(co *Conversation) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(conversation.Table, conversation.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, conversation.UserOneTable, conversation.UserOneColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserTwo queries the user_two edge of a Conversation.
func (c *ConversationClient) QueryUserTwo(co *Conversation) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(conversation.Table, conversation.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, conversation.UserTwoTable, conversation.UserTwoColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ConversationClient) Hooks() []Hook {
	return c.hooks.Conversation
}

// Interceptors returns the client interceptors.
func (c *ConversationClient) Interceptors() []Interceptor {
	return c.inters.Conversation
}

func (c *ConversationClient) mutate(ctx context.Context, m *ConversationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ConversationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ConversationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ConversationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ConversationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Conversation mutation op: %q", m.Op())
	}
}

// FinancialTransactionClient is a client for the FinancialTransaction schema.
type FinancialTransactionClient struct {
	config
}

// NewFinancialTransactionClient returns a client for the FinancialTransaction from the given config.
func NewFinancialTransactionClient(c config) *FinancialTransactionClient {
	return &FinancialTransactionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `financialtransaction.Hooks(f(g(h())))`.
func (c *FinancialTransactionClient) Use(hooks ...Hook) {
	c.hooks.FinancialTransaction = append(c.hooks.FinancialTransaction, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `financialtransaction.Intercept(f(g(h())))`.
func (c *FinancialTransactionClient) Intercept(interceptors ...Interceptor) {
	c.inters.FinancialTransaction = append(c.inters.FinancialTransaction, interceptors...)
}

// Create returns a builder for creating a FinancialTransaction entity.
func (c *FinancialTransactionClient) Create() *FinancialTransactionCreate {
	mutation := newFinancialTransactionMutation(c.config, OpCreate)
	return &FinancialTransactionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of FinancialTransaction entities.
func (c *FinancialTransactionClient) CreateBulk(builders ...*FinancialTransactionCreate) *FinancialTransactionCreateBulk {
	return &FinancialTransactionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FinancialTransactionClient) MapCreateBulk(slice any, setFunc func(*FinancialTransactionCreate, int)) *FinancialTransactionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FinancialTransactionCreateBulk{err: fmt.Errorf("calling to FinancialTransactionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FinancialTransactionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FinancialTransactionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for FinancialTransaction.
func (c *FinancialTransactionClient) Update() *FinancialTransactionUpdate {
	mutation := newFinancialTransactionMutation(c.config, OpUpdate)
	return &FinancialTransactionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FinancialTransactionClient) UpdateOne(ft *FinancialTransaction) *FinancialTransactionUpdateOne {
	mutation := newFinancialTransactionMutation(c.config, OpUpdateOne, withFinancialTransaction(ft))
	return &FinancialTransactionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FinancialTransactionClient) UpdateOneID(id uuid.UUID) *FinancialTransactionUpdateOne {
	mutation := newFinancialTransactionMutation(c.config, OpUpdateOne, withFinancialTransactionID(id))
	return &FinancialTransactionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for FinancialTransaction.
func (c *FinancialTransactionClient) Delete() *FinancialTransactionDelete {
	mutation := newFinancialTransactionMutation(c.config, OpDelete)
	return &FinancialTransactionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FinancialTransactionClient) DeleteOne(ft *FinancialTransaction) *FinancialTransactionDeleteOne {
	return c.DeleteOneID(ft.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FinancialTransactionClient) DeleteOneID(id uuid.UUID) *FinancialTransactionDeleteOne {
	builder := c.Delete().Where(financialtransaction.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FinancialTransactionDeleteOne{builder}
}

// Query returns a query builder for FinancialTransaction.
func (c *FinancialTransactionClient) Query() *FinancialTransactionQuery {
	return &FinancialTransactionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFinancialTransaction},
		inters: c.Interceptors(),
	}
}

// Get returns a FinancialTransaction entity by its id.
func (c *FinancialTransactionClient) Get(ctx context.Context, id uuid.UUID) (*FinancialTransaction, error) {
	return c.Query().Where(financialtransaction.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FinancialTransactionClient) GetX(ctx context.Context, id uuid.UUID) *FinancialTransaction {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryInvoice queries the invoice edge of a FinancialTransaction.
func (c *FinancialTransactionClient) QueryInvoice(ft *FinancialTransaction) *InvoiceQuery {
	query := (&InvoiceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ft.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(financialtransaction.Table, financialtransaction.FieldID, id),
			sqlgraph.To(invoice.Table, invoice.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, financialtransaction.InvoiceTable, financialtransaction.InvoiceColumn),
		)
		fromV = sqlgraph.Neighbors(ft.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTransactionType queries the transaction_type edge of a FinancialTransaction.
func (c *FinancialTransactionClient) QueryTransactionType(ft *FinancialTransaction) *TransactionTypeQuery {
	query := (&TransactionTypeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ft.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(financialtransaction.Table, financialtransaction.FieldID, id),
			sqlgraph.To(transactiontype.Table, transactiontype.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, financialtransaction.TransactionTypeTable, financialtransaction.TransactionTypeColumn),
		)
		fromV = sqlgraph.Neighbors(ft.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPayment queries the payment edge of a FinancialTransaction.
func (c *FinancialTransactionClient) QueryPayment(ft *FinancialTransaction) *PaymentMethodQuery {
	query := (&PaymentMethodClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ft.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(financialtransaction.Table, financialtransaction.FieldID, id),
			sqlgraph.To(paymentmethod.Table, paymentmethod.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, financialtransaction.PaymentTable, financialtransaction.PaymentColumn),
		)
		fromV = sqlgraph.Neighbors(ft.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FinancialTransactionClient) Hooks() []Hook {
	return c.hooks.FinancialTransaction
}

// Interceptors returns the client interceptors.
func (c *FinancialTransactionClient) Interceptors() []Interceptor {
	return c.inters.FinancialTransaction
}

func (c *FinancialTransactionClient) mutate(ctx context.Context, m *FinancialTransactionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FinancialTransactionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FinancialTransactionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FinancialTransactionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FinancialTransactionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown FinancialTransaction mutation op: %q", m.Op())
	}
}

// InvoiceClient is a client for the Invoice schema.
type InvoiceClient struct {
	config
}

// NewInvoiceClient returns a client for the Invoice from the given config.
func NewInvoiceClient(c config) *InvoiceClient {
	return &InvoiceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `invoice.Hooks(f(g(h())))`.
func (c *InvoiceClient) Use(hooks ...Hook) {
	c.hooks.Invoice = append(c.hooks.Invoice, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `invoice.Intercept(f(g(h())))`.
func (c *InvoiceClient) Intercept(interceptors ...Interceptor) {
	c.inters.Invoice = append(c.inters.Invoice, interceptors...)
}

// Create returns a builder for creating a Invoice entity.
func (c *InvoiceClient) Create() *InvoiceCreate {
	mutation := newInvoiceMutation(c.config, OpCreate)
	return &InvoiceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Invoice entities.
func (c *InvoiceClient) CreateBulk(builders ...*InvoiceCreate) *InvoiceCreateBulk {
	return &InvoiceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *InvoiceClient) MapCreateBulk(slice any, setFunc func(*InvoiceCreate, int)) *InvoiceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &InvoiceCreateBulk{err: fmt.Errorf("calling to InvoiceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*InvoiceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &InvoiceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Invoice.
func (c *InvoiceClient) Update() *InvoiceUpdate {
	mutation := newInvoiceMutation(c.config, OpUpdate)
	return &InvoiceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *InvoiceClient) UpdateOne(i *Invoice) *InvoiceUpdateOne {
	mutation := newInvoiceMutation(c.config, OpUpdateOne, withInvoice(i))
	return &InvoiceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *InvoiceClient) UpdateOneID(id uuid.UUID) *InvoiceUpdateOne {
	mutation := newInvoiceMutation(c.config, OpUpdateOne, withInvoiceID(id))
	return &InvoiceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Invoice.
func (c *InvoiceClient) Delete() *InvoiceDelete {
	mutation := newInvoiceMutation(c.config, OpDelete)
	return &InvoiceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *InvoiceClient) DeleteOne(i *Invoice) *InvoiceDeleteOne {
	return c.DeleteOneID(i.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *InvoiceClient) DeleteOneID(id uuid.UUID) *InvoiceDeleteOne {
	builder := c.Delete().Where(invoice.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &InvoiceDeleteOne{builder}
}

// Query returns a query builder for Invoice.
func (c *InvoiceClient) Query() *InvoiceQuery {
	return &InvoiceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeInvoice},
		inters: c.Interceptors(),
	}
}

// Get returns a Invoice entity by its id.
func (c *InvoiceClient) Get(ctx context.Context, id uuid.UUID) (*Invoice, error) {
	return c.Query().Where(invoice.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *InvoiceClient) GetX(ctx context.Context, id uuid.UUID) *Invoice {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOrder queries the order edge of a Invoice.
func (c *InvoiceClient) QueryOrder(i *Invoice) *OrderQuery {
	query := (&OrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(invoice.Table, invoice.FieldID, id),
			sqlgraph.To(order.Table, order.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, invoice.OrderTable, invoice.OrderColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInvoiceType queries the invoice_type edge of a Invoice.
func (c *InvoiceClient) QueryInvoiceType(i *Invoice) *InvoiceTypeQuery {
	query := (&InvoiceTypeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(invoice.Table, invoice.FieldID, id),
			sqlgraph.To(invoicetype.Table, invoicetype.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, invoice.InvoiceTypeTable, invoice.InvoiceTypeColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInvoiceStatus queries the invoice_status edge of a Invoice.
func (c *InvoiceClient) QueryInvoiceStatus(i *Invoice) *InvoiceStatusCodeQuery {
	query := (&InvoiceStatusCodeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(invoice.Table, invoice.FieldID, id),
			sqlgraph.To(invoicestatuscode.Table, invoicestatuscode.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, invoice.InvoiceStatusTable, invoice.InvoiceStatusColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *InvoiceClient) Hooks() []Hook {
	return c.hooks.Invoice
}

// Interceptors returns the client interceptors.
func (c *InvoiceClient) Interceptors() []Interceptor {
	return c.inters.Invoice
}

func (c *InvoiceClient) mutate(ctx context.Context, m *InvoiceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&InvoiceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&InvoiceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&InvoiceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&InvoiceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Invoice mutation op: %q", m.Op())
	}
}

// InvoiceLineItemClient is a client for the InvoiceLineItem schema.
type InvoiceLineItemClient struct {
	config
}

// NewInvoiceLineItemClient returns a client for the InvoiceLineItem from the given config.
func NewInvoiceLineItemClient(c config) *InvoiceLineItemClient {
	return &InvoiceLineItemClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `invoicelineitem.Hooks(f(g(h())))`.
func (c *InvoiceLineItemClient) Use(hooks ...Hook) {
	c.hooks.InvoiceLineItem = append(c.hooks.InvoiceLineItem, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `invoicelineitem.Intercept(f(g(h())))`.
func (c *InvoiceLineItemClient) Intercept(interceptors ...Interceptor) {
	c.inters.InvoiceLineItem = append(c.inters.InvoiceLineItem, interceptors...)
}

// Create returns a builder for creating a InvoiceLineItem entity.
func (c *InvoiceLineItemClient) Create() *InvoiceLineItemCreate {
	mutation := newInvoiceLineItemMutation(c.config, OpCreate)
	return &InvoiceLineItemCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of InvoiceLineItem entities.
func (c *InvoiceLineItemClient) CreateBulk(builders ...*InvoiceLineItemCreate) *InvoiceLineItemCreateBulk {
	return &InvoiceLineItemCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *InvoiceLineItemClient) MapCreateBulk(slice any, setFunc func(*InvoiceLineItemCreate, int)) *InvoiceLineItemCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &InvoiceLineItemCreateBulk{err: fmt.Errorf("calling to InvoiceLineItemClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*InvoiceLineItemCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &InvoiceLineItemCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for InvoiceLineItem.
func (c *InvoiceLineItemClient) Update() *InvoiceLineItemUpdate {
	mutation := newInvoiceLineItemMutation(c.config, OpUpdate)
	return &InvoiceLineItemUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *InvoiceLineItemClient) UpdateOne(ili *InvoiceLineItem) *InvoiceLineItemUpdateOne {
	mutation := newInvoiceLineItemMutation(c.config, OpUpdateOne, withInvoiceLineItem(ili))
	return &InvoiceLineItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *InvoiceLineItemClient) UpdateOneID(id uuid.UUID) *InvoiceLineItemUpdateOne {
	mutation := newInvoiceLineItemMutation(c.config, OpUpdateOne, withInvoiceLineItemID(id))
	return &InvoiceLineItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for InvoiceLineItem.
func (c *InvoiceLineItemClient) Delete() *InvoiceLineItemDelete {
	mutation := newInvoiceLineItemMutation(c.config, OpDelete)
	return &InvoiceLineItemDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *InvoiceLineItemClient) DeleteOne(ili *InvoiceLineItem) *InvoiceLineItemDeleteOne {
	return c.DeleteOneID(ili.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *InvoiceLineItemClient) DeleteOneID(id uuid.UUID) *InvoiceLineItemDeleteOne {
	builder := c.Delete().Where(invoicelineitem.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &InvoiceLineItemDeleteOne{builder}
}

// Query returns a query builder for InvoiceLineItem.
func (c *InvoiceLineItemClient) Query() *InvoiceLineItemQuery {
	return &InvoiceLineItemQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeInvoiceLineItem},
		inters: c.Interceptors(),
	}
}

// Get returns a InvoiceLineItem entity by its id.
func (c *InvoiceLineItemClient) Get(ctx context.Context, id uuid.UUID) (*InvoiceLineItem, error) {
	return c.Query().Where(invoicelineitem.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *InvoiceLineItemClient) GetX(ctx context.Context, id uuid.UUID) *InvoiceLineItem {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryInvoice queries the invoice edge of a InvoiceLineItem.
func (c *InvoiceLineItemClient) QueryInvoice(ili *InvoiceLineItem) *InvoiceQuery {
	query := (&InvoiceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ili.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(invoicelineitem.Table, invoicelineitem.FieldID, id),
			sqlgraph.To(invoice.Table, invoice.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, invoicelineitem.InvoiceTable, invoicelineitem.InvoiceColumn),
		)
		fromV = sqlgraph.Neighbors(ili.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrderLineItem queries the order_line_item edge of a InvoiceLineItem.
func (c *InvoiceLineItemClient) QueryOrderLineItem(ili *InvoiceLineItem) *OrderLineItemQuery {
	query := (&OrderLineItemClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ili.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(invoicelineitem.Table, invoicelineitem.FieldID, id),
			sqlgraph.To(orderlineitem.Table, orderlineitem.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, invoicelineitem.OrderLineItemTable, invoicelineitem.OrderLineItemColumn),
		)
		fromV = sqlgraph.Neighbors(ili.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *InvoiceLineItemClient) Hooks() []Hook {
	return c.hooks.InvoiceLineItem
}

// Interceptors returns the client interceptors.
func (c *InvoiceLineItemClient) Interceptors() []Interceptor {
	return c.inters.InvoiceLineItem
}

func (c *InvoiceLineItemClient) mutate(ctx context.Context, m *InvoiceLineItemMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&InvoiceLineItemCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&InvoiceLineItemUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&InvoiceLineItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&InvoiceLineItemDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown InvoiceLineItem mutation op: %q", m.Op())
	}
}

// InvoiceStatusCodeClient is a client for the InvoiceStatusCode schema.
type InvoiceStatusCodeClient struct {
	config
}

// NewInvoiceStatusCodeClient returns a client for the InvoiceStatusCode from the given config.
func NewInvoiceStatusCodeClient(c config) *InvoiceStatusCodeClient {
	return &InvoiceStatusCodeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `invoicestatuscode.Hooks(f(g(h())))`.
func (c *InvoiceStatusCodeClient) Use(hooks ...Hook) {
	c.hooks.InvoiceStatusCode = append(c.hooks.InvoiceStatusCode, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `invoicestatuscode.Intercept(f(g(h())))`.
func (c *InvoiceStatusCodeClient) Intercept(interceptors ...Interceptor) {
	c.inters.InvoiceStatusCode = append(c.inters.InvoiceStatusCode, interceptors...)
}

// Create returns a builder for creating a InvoiceStatusCode entity.
func (c *InvoiceStatusCodeClient) Create() *InvoiceStatusCodeCreate {
	mutation := newInvoiceStatusCodeMutation(c.config, OpCreate)
	return &InvoiceStatusCodeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of InvoiceStatusCode entities.
func (c *InvoiceStatusCodeClient) CreateBulk(builders ...*InvoiceStatusCodeCreate) *InvoiceStatusCodeCreateBulk {
	return &InvoiceStatusCodeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *InvoiceStatusCodeClient) MapCreateBulk(slice any, setFunc func(*InvoiceStatusCodeCreate, int)) *InvoiceStatusCodeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &InvoiceStatusCodeCreateBulk{err: fmt.Errorf("calling to InvoiceStatusCodeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*InvoiceStatusCodeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &InvoiceStatusCodeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for InvoiceStatusCode.
func (c *InvoiceStatusCodeClient) Update() *InvoiceStatusCodeUpdate {
	mutation := newInvoiceStatusCodeMutation(c.config, OpUpdate)
	return &InvoiceStatusCodeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *InvoiceStatusCodeClient) UpdateOne(isc *InvoiceStatusCode) *InvoiceStatusCodeUpdateOne {
	mutation := newInvoiceStatusCodeMutation(c.config, OpUpdateOne, withInvoiceStatusCode(isc))
	return &InvoiceStatusCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *InvoiceStatusCodeClient) UpdateOneID(id int) *InvoiceStatusCodeUpdateOne {
	mutation := newInvoiceStatusCodeMutation(c.config, OpUpdateOne, withInvoiceStatusCodeID(id))
	return &InvoiceStatusCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for InvoiceStatusCode.
func (c *InvoiceStatusCodeClient) Delete() *InvoiceStatusCodeDelete {
	mutation := newInvoiceStatusCodeMutation(c.config, OpDelete)
	return &InvoiceStatusCodeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *InvoiceStatusCodeClient) DeleteOne(isc *InvoiceStatusCode) *InvoiceStatusCodeDeleteOne {
	return c.DeleteOneID(isc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *InvoiceStatusCodeClient) DeleteOneID(id int) *InvoiceStatusCodeDeleteOne {
	builder := c.Delete().Where(invoicestatuscode.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &InvoiceStatusCodeDeleteOne{builder}
}

// Query returns a query builder for InvoiceStatusCode.
func (c *InvoiceStatusCodeClient) Query() *InvoiceStatusCodeQuery {
	return &InvoiceStatusCodeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeInvoiceStatusCode},
		inters: c.Interceptors(),
	}
}

// Get returns a InvoiceStatusCode entity by its id.
func (c *InvoiceStatusCodeClient) Get(ctx context.Context, id int) (*InvoiceStatusCode, error) {
	return c.Query().Where(invoicestatuscode.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *InvoiceStatusCodeClient) GetX(ctx context.Context, id int) *InvoiceStatusCode {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *InvoiceStatusCodeClient) Hooks() []Hook {
	return c.hooks.InvoiceStatusCode
}

// Interceptors returns the client interceptors.
func (c *InvoiceStatusCodeClient) Interceptors() []Interceptor {
	return c.inters.InvoiceStatusCode
}

func (c *InvoiceStatusCodeClient) mutate(ctx context.Context, m *InvoiceStatusCodeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&InvoiceStatusCodeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&InvoiceStatusCodeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&InvoiceStatusCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&InvoiceStatusCodeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown InvoiceStatusCode mutation op: %q", m.Op())
	}
}

// InvoiceTypeClient is a client for the InvoiceType schema.
type InvoiceTypeClient struct {
	config
}

// NewInvoiceTypeClient returns a client for the InvoiceType from the given config.
func NewInvoiceTypeClient(c config) *InvoiceTypeClient {
	return &InvoiceTypeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `invoicetype.Hooks(f(g(h())))`.
func (c *InvoiceTypeClient) Use(hooks ...Hook) {
	c.hooks.InvoiceType = append(c.hooks.InvoiceType, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `invoicetype.Intercept(f(g(h())))`.
func (c *InvoiceTypeClient) Intercept(interceptors ...Interceptor) {
	c.inters.InvoiceType = append(c.inters.InvoiceType, interceptors...)
}

// Create returns a builder for creating a InvoiceType entity.
func (c *InvoiceTypeClient) Create() *InvoiceTypeCreate {
	mutation := newInvoiceTypeMutation(c.config, OpCreate)
	return &InvoiceTypeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of InvoiceType entities.
func (c *InvoiceTypeClient) CreateBulk(builders ...*InvoiceTypeCreate) *InvoiceTypeCreateBulk {
	return &InvoiceTypeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *InvoiceTypeClient) MapCreateBulk(slice any, setFunc func(*InvoiceTypeCreate, int)) *InvoiceTypeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &InvoiceTypeCreateBulk{err: fmt.Errorf("calling to InvoiceTypeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*InvoiceTypeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &InvoiceTypeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for InvoiceType.
func (c *InvoiceTypeClient) Update() *InvoiceTypeUpdate {
	mutation := newInvoiceTypeMutation(c.config, OpUpdate)
	return &InvoiceTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *InvoiceTypeClient) UpdateOne(it *InvoiceType) *InvoiceTypeUpdateOne {
	mutation := newInvoiceTypeMutation(c.config, OpUpdateOne, withInvoiceType(it))
	return &InvoiceTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *InvoiceTypeClient) UpdateOneID(id int) *InvoiceTypeUpdateOne {
	mutation := newInvoiceTypeMutation(c.config, OpUpdateOne, withInvoiceTypeID(id))
	return &InvoiceTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for InvoiceType.
func (c *InvoiceTypeClient) Delete() *InvoiceTypeDelete {
	mutation := newInvoiceTypeMutation(c.config, OpDelete)
	return &InvoiceTypeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *InvoiceTypeClient) DeleteOne(it *InvoiceType) *InvoiceTypeDeleteOne {
	return c.DeleteOneID(it.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *InvoiceTypeClient) DeleteOneID(id int) *InvoiceTypeDeleteOne {
	builder := c.Delete().Where(invoicetype.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &InvoiceTypeDeleteOne{builder}
}

// Query returns a query builder for InvoiceType.
func (c *InvoiceTypeClient) Query() *InvoiceTypeQuery {
	return &InvoiceTypeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeInvoiceType},
		inters: c.Interceptors(),
	}
}

// Get returns a InvoiceType entity by its id.
func (c *InvoiceTypeClient) Get(ctx context.Context, id int) (*InvoiceType, error) {
	return c.Query().Where(invoicetype.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *InvoiceTypeClient) GetX(ctx context.Context, id int) *InvoiceType {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *InvoiceTypeClient) Hooks() []Hook {
	return c.hooks.InvoiceType
}

// Interceptors returns the client interceptors.
func (c *InvoiceTypeClient) Interceptors() []Interceptor {
	return c.inters.InvoiceType
}

func (c *InvoiceTypeClient) mutate(ctx context.Context, m *InvoiceTypeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&InvoiceTypeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&InvoiceTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&InvoiceTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&InvoiceTypeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown InvoiceType mutation op: %q", m.Op())
	}
}

// MessageClient is a client for the Message schema.
type MessageClient struct {
	config
}

// NewMessageClient returns a client for the Message from the given config.
func NewMessageClient(c config) *MessageClient {
	return &MessageClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `message.Hooks(f(g(h())))`.
func (c *MessageClient) Use(hooks ...Hook) {
	c.hooks.Message = append(c.hooks.Message, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `message.Intercept(f(g(h())))`.
func (c *MessageClient) Intercept(interceptors ...Interceptor) {
	c.inters.Message = append(c.inters.Message, interceptors...)
}

// Create returns a builder for creating a Message entity.
func (c *MessageClient) Create() *MessageCreate {
	mutation := newMessageMutation(c.config, OpCreate)
	return &MessageCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Message entities.
func (c *MessageClient) CreateBulk(builders ...*MessageCreate) *MessageCreateBulk {
	return &MessageCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MessageClient) MapCreateBulk(slice any, setFunc func(*MessageCreate, int)) *MessageCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MessageCreateBulk{err: fmt.Errorf("calling to MessageClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MessageCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MessageCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Message.
func (c *MessageClient) Update() *MessageUpdate {
	mutation := newMessageMutation(c.config, OpUpdate)
	return &MessageUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MessageClient) UpdateOne(m *Message) *MessageUpdateOne {
	mutation := newMessageMutation(c.config, OpUpdateOne, withMessage(m))
	return &MessageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MessageClient) UpdateOneID(id uuid.UUID) *MessageUpdateOne {
	mutation := newMessageMutation(c.config, OpUpdateOne, withMessageID(id))
	return &MessageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Message.
func (c *MessageClient) Delete() *MessageDelete {
	mutation := newMessageMutation(c.config, OpDelete)
	return &MessageDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MessageClient) DeleteOne(m *Message) *MessageDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MessageClient) DeleteOneID(id uuid.UUID) *MessageDeleteOne {
	builder := c.Delete().Where(message.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MessageDeleteOne{builder}
}

// Query returns a query builder for Message.
func (c *MessageClient) Query() *MessageQuery {
	return &MessageQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMessage},
		inters: c.Interceptors(),
	}
}

// Get returns a Message entity by its id.
func (c *MessageClient) Get(ctx context.Context, id uuid.UUID) (*Message, error) {
	return c.Query().Where(message.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MessageClient) GetX(ctx context.Context, id uuid.UUID) *Message {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryConversation queries the conversation edge of a Message.
func (c *MessageClient) QueryConversation(m *Message) *ConversationQuery {
	query := (&ConversationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(message.Table, message.FieldID, id),
			sqlgraph.To(conversation.Table, conversation.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, message.ConversationTable, message.ConversationColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySender queries the sender edge of a Message.
func (c *MessageClient) QuerySender(m *Message) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(message.Table, message.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, message.SenderTable, message.SenderColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMessageType queries the message_type edge of a Message.
func (c *MessageClient) QueryMessageType(m *Message) *MessageTypeQuery {
	query := (&MessageTypeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(message.Table, message.FieldID, id),
			sqlgraph.To(messagetype.Table, messagetype.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, message.MessageTypeTable, message.MessageTypeColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MessageClient) Hooks() []Hook {
	return c.hooks.Message
}

// Interceptors returns the client interceptors.
func (c *MessageClient) Interceptors() []Interceptor {
	return c.inters.Message
}

func (c *MessageClient) mutate(ctx context.Context, m *MessageMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MessageCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MessageUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MessageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MessageDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Message mutation op: %q", m.Op())
	}
}

// MessageTypeClient is a client for the MessageType schema.
type MessageTypeClient struct {
	config
}

// NewMessageTypeClient returns a client for the MessageType from the given config.
func NewMessageTypeClient(c config) *MessageTypeClient {
	return &MessageTypeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `messagetype.Hooks(f(g(h())))`.
func (c *MessageTypeClient) Use(hooks ...Hook) {
	c.hooks.MessageType = append(c.hooks.MessageType, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `messagetype.Intercept(f(g(h())))`.
func (c *MessageTypeClient) Intercept(interceptors ...Interceptor) {
	c.inters.MessageType = append(c.inters.MessageType, interceptors...)
}

// Create returns a builder for creating a MessageType entity.
func (c *MessageTypeClient) Create() *MessageTypeCreate {
	mutation := newMessageTypeMutation(c.config, OpCreate)
	return &MessageTypeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MessageType entities.
func (c *MessageTypeClient) CreateBulk(builders ...*MessageTypeCreate) *MessageTypeCreateBulk {
	return &MessageTypeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MessageTypeClient) MapCreateBulk(slice any, setFunc func(*MessageTypeCreate, int)) *MessageTypeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MessageTypeCreateBulk{err: fmt.Errorf("calling to MessageTypeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MessageTypeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MessageTypeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MessageType.
func (c *MessageTypeClient) Update() *MessageTypeUpdate {
	mutation := newMessageTypeMutation(c.config, OpUpdate)
	return &MessageTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MessageTypeClient) UpdateOne(mt *MessageType) *MessageTypeUpdateOne {
	mutation := newMessageTypeMutation(c.config, OpUpdateOne, withMessageType(mt))
	return &MessageTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MessageTypeClient) UpdateOneID(id int) *MessageTypeUpdateOne {
	mutation := newMessageTypeMutation(c.config, OpUpdateOne, withMessageTypeID(id))
	return &MessageTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MessageType.
func (c *MessageTypeClient) Delete() *MessageTypeDelete {
	mutation := newMessageTypeMutation(c.config, OpDelete)
	return &MessageTypeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MessageTypeClient) DeleteOne(mt *MessageType) *MessageTypeDeleteOne {
	return c.DeleteOneID(mt.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MessageTypeClient) DeleteOneID(id int) *MessageTypeDeleteOne {
	builder := c.Delete().Where(messagetype.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MessageTypeDeleteOne{builder}
}

// Query returns a query builder for MessageType.
func (c *MessageTypeClient) Query() *MessageTypeQuery {
	return &MessageTypeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMessageType},
		inters: c.Interceptors(),
	}
}

// Get returns a MessageType entity by its id.
func (c *MessageTypeClient) Get(ctx context.Context, id int) (*MessageType, error) {
	return c.Query().Where(messagetype.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MessageTypeClient) GetX(ctx context.Context, id int) *MessageType {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *MessageTypeClient) Hooks() []Hook {
	return c.hooks.MessageType
}

// Interceptors returns the client interceptors.
func (c *MessageTypeClient) Interceptors() []Interceptor {
	return c.inters.MessageType
}

func (c *MessageTypeClient) mutate(ctx context.Context, m *MessageTypeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MessageTypeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MessageTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MessageTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MessageTypeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MessageType mutation op: %q", m.Op())
	}
}

// OrderClient is a client for the Order schema.
type OrderClient struct {
	config
}

// NewOrderClient returns a client for the Order from the given config.
func NewOrderClient(c config) *OrderClient {
	return &OrderClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `order.Hooks(f(g(h())))`.
func (c *OrderClient) Use(hooks ...Hook) {
	c.hooks.Order = append(c.hooks.Order, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `order.Intercept(f(g(h())))`.
func (c *OrderClient) Intercept(interceptors ...Interceptor) {
	c.inters.Order = append(c.inters.Order, interceptors...)
}

// Create returns a builder for creating a Order entity.
func (c *OrderClient) Create() *OrderCreate {
	mutation := newOrderMutation(c.config, OpCreate)
	return &OrderCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Order entities.
func (c *OrderClient) CreateBulk(builders ...*OrderCreate) *OrderCreateBulk {
	return &OrderCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrderClient) MapCreateBulk(slice any, setFunc func(*OrderCreate, int)) *OrderCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrderCreateBulk{err: fmt.Errorf("calling to OrderClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrderCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrderCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Order.
func (c *OrderClient) Update() *OrderUpdate {
	mutation := newOrderMutation(c.config, OpUpdate)
	return &OrderUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrderClient) UpdateOne(o *Order) *OrderUpdateOne {
	mutation := newOrderMutation(c.config, OpUpdateOne, withOrder(o))
	return &OrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrderClient) UpdateOneID(id uuid.UUID) *OrderUpdateOne {
	mutation := newOrderMutation(c.config, OpUpdateOne, withOrderID(id))
	return &OrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Order.
func (c *OrderClient) Delete() *OrderDelete {
	mutation := newOrderMutation(c.config, OpDelete)
	return &OrderDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrderClient) DeleteOne(o *Order) *OrderDeleteOne {
	return c.DeleteOneID(o.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrderClient) DeleteOneID(id uuid.UUID) *OrderDeleteOne {
	builder := c.Delete().Where(order.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrderDeleteOne{builder}
}

// Query returns a query builder for Order.
func (c *OrderClient) Query() *OrderQuery {
	return &OrderQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrder},
		inters: c.Interceptors(),
	}
}

// Get returns a Order entity by its id.
func (c *OrderClient) Get(ctx context.Context, id uuid.UUID) (*Order, error) {
	return c.Query().Where(order.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrderClient) GetX(ctx context.Context, id uuid.UUID) *Order {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCustomer queries the customer edge of a Order.
func (c *OrderClient) QueryCustomer(o *Order) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(order.Table, order.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, order.CustomerTable, order.CustomerColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCreator queries the creator edge of a Order.
func (c *OrderClient) QueryCreator(o *Order) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(order.Table, order.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, order.CreatorTable, order.CreatorColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParentOrder queries the parent_order edge of a Order.
func (c *OrderClient) QueryParentOrder(o *Order) *OrderQuery {
	query := (&OrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(order.Table, order.FieldID, id),
			sqlgraph.To(order.Table, order.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, order.ParentOrderTable, order.ParentOrderColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrderStatus queries the order_status edge of a Order.
func (c *OrderClient) QueryOrderStatus(o *Order) *OrderStatusCodeQuery {
	query := (&OrderStatusCodeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(order.Table, order.FieldID, id),
			sqlgraph.To(orderstatuscode.Table, orderstatuscode.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, order.OrderStatusTable, order.OrderStatusColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrderType queries the order_type edge of a Order.
func (c *OrderClient) QueryOrderType(o *Order) *OrderTypeQuery {
	query := (&OrderTypeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(order.Table, order.FieldID, id),
			sqlgraph.To(ordertype.Table, ordertype.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, order.OrderTypeTable, order.OrderTypeColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryManagementStaff queries the management_staff edge of a Order.
func (c *OrderClient) QueryManagementStaff(o *Order) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(order.Table, order.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, order.ManagementStaffTable, order.ManagementStaffColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWarehouseStaff queries the warehouse_staff edge of a Order.
func (c *OrderClient) QueryWarehouseStaff(o *Order) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(order.Table, order.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, order.WarehouseStaffTable, order.WarehouseStaffColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDeliveryStaff queries the delivery_staff edge of a Order.
func (c *OrderClient) QueryDeliveryStaff(o *Order) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(order.Table, order.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, order.DeliveryStaffTable, order.DeliveryStaffColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrderClient) Hooks() []Hook {
	return c.hooks.Order
}

// Interceptors returns the client interceptors.
func (c *OrderClient) Interceptors() []Interceptor {
	return c.inters.Order
}

func (c *OrderClient) mutate(ctx context.Context, m *OrderMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrderCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrderUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrderDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Order mutation op: %q", m.Op())
	}
}

// OrderLineItemClient is a client for the OrderLineItem schema.
type OrderLineItemClient struct {
	config
}

// NewOrderLineItemClient returns a client for the OrderLineItem from the given config.
func NewOrderLineItemClient(c config) *OrderLineItemClient {
	return &OrderLineItemClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `orderlineitem.Hooks(f(g(h())))`.
func (c *OrderLineItemClient) Use(hooks ...Hook) {
	c.hooks.OrderLineItem = append(c.hooks.OrderLineItem, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `orderlineitem.Intercept(f(g(h())))`.
func (c *OrderLineItemClient) Intercept(interceptors ...Interceptor) {
	c.inters.OrderLineItem = append(c.inters.OrderLineItem, interceptors...)
}

// Create returns a builder for creating a OrderLineItem entity.
func (c *OrderLineItemClient) Create() *OrderLineItemCreate {
	mutation := newOrderLineItemMutation(c.config, OpCreate)
	return &OrderLineItemCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OrderLineItem entities.
func (c *OrderLineItemClient) CreateBulk(builders ...*OrderLineItemCreate) *OrderLineItemCreateBulk {
	return &OrderLineItemCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrderLineItemClient) MapCreateBulk(slice any, setFunc func(*OrderLineItemCreate, int)) *OrderLineItemCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrderLineItemCreateBulk{err: fmt.Errorf("calling to OrderLineItemClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrderLineItemCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrderLineItemCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OrderLineItem.
func (c *OrderLineItemClient) Update() *OrderLineItemUpdate {
	mutation := newOrderLineItemMutation(c.config, OpUpdate)
	return &OrderLineItemUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrderLineItemClient) UpdateOne(oli *OrderLineItem) *OrderLineItemUpdateOne {
	mutation := newOrderLineItemMutation(c.config, OpUpdateOne, withOrderLineItem(oli))
	return &OrderLineItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrderLineItemClient) UpdateOneID(id uuid.UUID) *OrderLineItemUpdateOne {
	mutation := newOrderLineItemMutation(c.config, OpUpdateOne, withOrderLineItemID(id))
	return &OrderLineItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OrderLineItem.
func (c *OrderLineItemClient) Delete() *OrderLineItemDelete {
	mutation := newOrderLineItemMutation(c.config, OpDelete)
	return &OrderLineItemDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrderLineItemClient) DeleteOne(oli *OrderLineItem) *OrderLineItemDeleteOne {
	return c.DeleteOneID(oli.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrderLineItemClient) DeleteOneID(id uuid.UUID) *OrderLineItemDeleteOne {
	builder := c.Delete().Where(orderlineitem.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrderLineItemDeleteOne{builder}
}

// Query returns a query builder for OrderLineItem.
func (c *OrderLineItemClient) Query() *OrderLineItemQuery {
	return &OrderLineItemQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrderLineItem},
		inters: c.Interceptors(),
	}
}

// Get returns a OrderLineItem entity by its id.
func (c *OrderLineItemClient) Get(ctx context.Context, id uuid.UUID) (*OrderLineItem, error) {
	return c.Query().Where(orderlineitem.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrderLineItemClient) GetX(ctx context.Context, id uuid.UUID) *OrderLineItem {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOrder queries the order edge of a OrderLineItem.
func (c *OrderLineItemClient) QueryOrder(oli *OrderLineItem) *OrderQuery {
	query := (&OrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := oli.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(orderlineitem.Table, orderlineitem.FieldID, id),
			sqlgraph.To(order.Table, order.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, orderlineitem.OrderTable, orderlineitem.OrderColumn),
		)
		fromV = sqlgraph.Neighbors(oli.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProduct queries the product edge of a OrderLineItem.
func (c *OrderLineItemClient) QueryProduct(oli *OrderLineItem) *ProductQuery {
	query := (&ProductClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := oli.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(orderlineitem.Table, orderlineitem.FieldID, id),
			sqlgraph.To(product.Table, product.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, orderlineitem.ProductTable, orderlineitem.ProductColumn),
		)
		fromV = sqlgraph.Neighbors(oli.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrderLineItemClient) Hooks() []Hook {
	return c.hooks.OrderLineItem
}

// Interceptors returns the client interceptors.
func (c *OrderLineItemClient) Interceptors() []Interceptor {
	return c.inters.OrderLineItem
}

func (c *OrderLineItemClient) mutate(ctx context.Context, m *OrderLineItemMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrderLineItemCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrderLineItemUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrderLineItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrderLineItemDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OrderLineItem mutation op: %q", m.Op())
	}
}

// OrderStatusCodeClient is a client for the OrderStatusCode schema.
type OrderStatusCodeClient struct {
	config
}

// NewOrderStatusCodeClient returns a client for the OrderStatusCode from the given config.
func NewOrderStatusCodeClient(c config) *OrderStatusCodeClient {
	return &OrderStatusCodeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `orderstatuscode.Hooks(f(g(h())))`.
func (c *OrderStatusCodeClient) Use(hooks ...Hook) {
	c.hooks.OrderStatusCode = append(c.hooks.OrderStatusCode, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `orderstatuscode.Intercept(f(g(h())))`.
func (c *OrderStatusCodeClient) Intercept(interceptors ...Interceptor) {
	c.inters.OrderStatusCode = append(c.inters.OrderStatusCode, interceptors...)
}

// Create returns a builder for creating a OrderStatusCode entity.
func (c *OrderStatusCodeClient) Create() *OrderStatusCodeCreate {
	mutation := newOrderStatusCodeMutation(c.config, OpCreate)
	return &OrderStatusCodeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OrderStatusCode entities.
func (c *OrderStatusCodeClient) CreateBulk(builders ...*OrderStatusCodeCreate) *OrderStatusCodeCreateBulk {
	return &OrderStatusCodeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrderStatusCodeClient) MapCreateBulk(slice any, setFunc func(*OrderStatusCodeCreate, int)) *OrderStatusCodeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrderStatusCodeCreateBulk{err: fmt.Errorf("calling to OrderStatusCodeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrderStatusCodeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrderStatusCodeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OrderStatusCode.
func (c *OrderStatusCodeClient) Update() *OrderStatusCodeUpdate {
	mutation := newOrderStatusCodeMutation(c.config, OpUpdate)
	return &OrderStatusCodeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrderStatusCodeClient) UpdateOne(osc *OrderStatusCode) *OrderStatusCodeUpdateOne {
	mutation := newOrderStatusCodeMutation(c.config, OpUpdateOne, withOrderStatusCode(osc))
	return &OrderStatusCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrderStatusCodeClient) UpdateOneID(id int) *OrderStatusCodeUpdateOne {
	mutation := newOrderStatusCodeMutation(c.config, OpUpdateOne, withOrderStatusCodeID(id))
	return &OrderStatusCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OrderStatusCode.
func (c *OrderStatusCodeClient) Delete() *OrderStatusCodeDelete {
	mutation := newOrderStatusCodeMutation(c.config, OpDelete)
	return &OrderStatusCodeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrderStatusCodeClient) DeleteOne(osc *OrderStatusCode) *OrderStatusCodeDeleteOne {
	return c.DeleteOneID(osc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrderStatusCodeClient) DeleteOneID(id int) *OrderStatusCodeDeleteOne {
	builder := c.Delete().Where(orderstatuscode.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrderStatusCodeDeleteOne{builder}
}

// Query returns a query builder for OrderStatusCode.
func (c *OrderStatusCodeClient) Query() *OrderStatusCodeQuery {
	return &OrderStatusCodeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrderStatusCode},
		inters: c.Interceptors(),
	}
}

// Get returns a OrderStatusCode entity by its id.
func (c *OrderStatusCodeClient) Get(ctx context.Context, id int) (*OrderStatusCode, error) {
	return c.Query().Where(orderstatuscode.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrderStatusCodeClient) GetX(ctx context.Context, id int) *OrderStatusCode {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *OrderStatusCodeClient) Hooks() []Hook {
	return c.hooks.OrderStatusCode
}

// Interceptors returns the client interceptors.
func (c *OrderStatusCodeClient) Interceptors() []Interceptor {
	return c.inters.OrderStatusCode
}

func (c *OrderStatusCodeClient) mutate(ctx context.Context, m *OrderStatusCodeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrderStatusCodeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrderStatusCodeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrderStatusCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrderStatusCodeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OrderStatusCode mutation op: %q", m.Op())
	}
}

// OrderTypeClient is a client for the OrderType schema.
type OrderTypeClient struct {
	config
}

// NewOrderTypeClient returns a client for the OrderType from the given config.
func NewOrderTypeClient(c config) *OrderTypeClient {
	return &OrderTypeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `ordertype.Hooks(f(g(h())))`.
func (c *OrderTypeClient) Use(hooks ...Hook) {
	c.hooks.OrderType = append(c.hooks.OrderType, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `ordertype.Intercept(f(g(h())))`.
func (c *OrderTypeClient) Intercept(interceptors ...Interceptor) {
	c.inters.OrderType = append(c.inters.OrderType, interceptors...)
}

// Create returns a builder for creating a OrderType entity.
func (c *OrderTypeClient) Create() *OrderTypeCreate {
	mutation := newOrderTypeMutation(c.config, OpCreate)
	return &OrderTypeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OrderType entities.
func (c *OrderTypeClient) CreateBulk(builders ...*OrderTypeCreate) *OrderTypeCreateBulk {
	return &OrderTypeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrderTypeClient) MapCreateBulk(slice any, setFunc func(*OrderTypeCreate, int)) *OrderTypeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrderTypeCreateBulk{err: fmt.Errorf("calling to OrderTypeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrderTypeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrderTypeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OrderType.
func (c *OrderTypeClient) Update() *OrderTypeUpdate {
	mutation := newOrderTypeMutation(c.config, OpUpdate)
	return &OrderTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrderTypeClient) UpdateOne(ot *OrderType) *OrderTypeUpdateOne {
	mutation := newOrderTypeMutation(c.config, OpUpdateOne, withOrderType(ot))
	return &OrderTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrderTypeClient) UpdateOneID(id int) *OrderTypeUpdateOne {
	mutation := newOrderTypeMutation(c.config, OpUpdateOne, withOrderTypeID(id))
	return &OrderTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OrderType.
func (c *OrderTypeClient) Delete() *OrderTypeDelete {
	mutation := newOrderTypeMutation(c.config, OpDelete)
	return &OrderTypeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrderTypeClient) DeleteOne(ot *OrderType) *OrderTypeDeleteOne {
	return c.DeleteOneID(ot.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrderTypeClient) DeleteOneID(id int) *OrderTypeDeleteOne {
	builder := c.Delete().Where(ordertype.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrderTypeDeleteOne{builder}
}

// Query returns a query builder for OrderType.
func (c *OrderTypeClient) Query() *OrderTypeQuery {
	return &OrderTypeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrderType},
		inters: c.Interceptors(),
	}
}

// Get returns a OrderType entity by its id.
func (c *OrderTypeClient) Get(ctx context.Context, id int) (*OrderType, error) {
	return c.Query().Where(ordertype.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrderTypeClient) GetX(ctx context.Context, id int) *OrderType {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *OrderTypeClient) Hooks() []Hook {
	return c.hooks.OrderType
}

// Interceptors returns the client interceptors.
func (c *OrderTypeClient) Interceptors() []Interceptor {
	return c.inters.OrderType
}

func (c *OrderTypeClient) mutate(ctx context.Context, m *OrderTypeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrderTypeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrderTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrderTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrderTypeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OrderType mutation op: %q", m.Op())
	}
}

// PaymentMethodClient is a client for the PaymentMethod schema.
type PaymentMethodClient struct {
	config
}

// NewPaymentMethodClient returns a client for the PaymentMethod from the given config.
func NewPaymentMethodClient(c config) *PaymentMethodClient {
	return &PaymentMethodClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `paymentmethod.Hooks(f(g(h())))`.
func (c *PaymentMethodClient) Use(hooks ...Hook) {
	c.hooks.PaymentMethod = append(c.hooks.PaymentMethod, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `paymentmethod.Intercept(f(g(h())))`.
func (c *PaymentMethodClient) Intercept(interceptors ...Interceptor) {
	c.inters.PaymentMethod = append(c.inters.PaymentMethod, interceptors...)
}

// Create returns a builder for creating a PaymentMethod entity.
func (c *PaymentMethodClient) Create() *PaymentMethodCreate {
	mutation := newPaymentMethodMutation(c.config, OpCreate)
	return &PaymentMethodCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PaymentMethod entities.
func (c *PaymentMethodClient) CreateBulk(builders ...*PaymentMethodCreate) *PaymentMethodCreateBulk {
	return &PaymentMethodCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PaymentMethodClient) MapCreateBulk(slice any, setFunc func(*PaymentMethodCreate, int)) *PaymentMethodCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PaymentMethodCreateBulk{err: fmt.Errorf("calling to PaymentMethodClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PaymentMethodCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PaymentMethodCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PaymentMethod.
func (c *PaymentMethodClient) Update() *PaymentMethodUpdate {
	mutation := newPaymentMethodMutation(c.config, OpUpdate)
	return &PaymentMethodUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PaymentMethodClient) UpdateOne(pm *PaymentMethod) *PaymentMethodUpdateOne {
	mutation := newPaymentMethodMutation(c.config, OpUpdateOne, withPaymentMethod(pm))
	return &PaymentMethodUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PaymentMethodClient) UpdateOneID(id int) *PaymentMethodUpdateOne {
	mutation := newPaymentMethodMutation(c.config, OpUpdateOne, withPaymentMethodID(id))
	return &PaymentMethodUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PaymentMethod.
func (c *PaymentMethodClient) Delete() *PaymentMethodDelete {
	mutation := newPaymentMethodMutation(c.config, OpDelete)
	return &PaymentMethodDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PaymentMethodClient) DeleteOne(pm *PaymentMethod) *PaymentMethodDeleteOne {
	return c.DeleteOneID(pm.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PaymentMethodClient) DeleteOneID(id int) *PaymentMethodDeleteOne {
	builder := c.Delete().Where(paymentmethod.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PaymentMethodDeleteOne{builder}
}

// Query returns a query builder for PaymentMethod.
func (c *PaymentMethodClient) Query() *PaymentMethodQuery {
	return &PaymentMethodQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePaymentMethod},
		inters: c.Interceptors(),
	}
}

// Get returns a PaymentMethod entity by its id.
func (c *PaymentMethodClient) Get(ctx context.Context, id int) (*PaymentMethod, error) {
	return c.Query().Where(paymentmethod.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PaymentMethodClient) GetX(ctx context.Context, id int) *PaymentMethod {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *PaymentMethodClient) Hooks() []Hook {
	return c.hooks.PaymentMethod
}

// Interceptors returns the client interceptors.
func (c *PaymentMethodClient) Interceptors() []Interceptor {
	return c.inters.PaymentMethod
}

func (c *PaymentMethodClient) mutate(ctx context.Context, m *PaymentMethodMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PaymentMethodCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PaymentMethodUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PaymentMethodUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PaymentMethodDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PaymentMethod mutation op: %q", m.Op())
	}
}

// ProductClient is a client for the Product schema.
type ProductClient struct {
	config
}

// NewProductClient returns a client for the Product from the given config.
func NewProductClient(c config) *ProductClient {
	return &ProductClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `product.Hooks(f(g(h())))`.
func (c *ProductClient) Use(hooks ...Hook) {
	c.hooks.Product = append(c.hooks.Product, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `product.Intercept(f(g(h())))`.
func (c *ProductClient) Intercept(interceptors ...Interceptor) {
	c.inters.Product = append(c.inters.Product, interceptors...)
}

// Create returns a builder for creating a Product entity.
func (c *ProductClient) Create() *ProductCreate {
	mutation := newProductMutation(c.config, OpCreate)
	return &ProductCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Product entities.
func (c *ProductClient) CreateBulk(builders ...*ProductCreate) *ProductCreateBulk {
	return &ProductCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProductClient) MapCreateBulk(slice any, setFunc func(*ProductCreate, int)) *ProductCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProductCreateBulk{err: fmt.Errorf("calling to ProductClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProductCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProductCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Product.
func (c *ProductClient) Update() *ProductUpdate {
	mutation := newProductMutation(c.config, OpUpdate)
	return &ProductUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProductClient) UpdateOne(pr *Product) *ProductUpdateOne {
	mutation := newProductMutation(c.config, OpUpdateOne, withProduct(pr))
	return &ProductUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProductClient) UpdateOneID(id uuid.UUID) *ProductUpdateOne {
	mutation := newProductMutation(c.config, OpUpdateOne, withProductID(id))
	return &ProductUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Product.
func (c *ProductClient) Delete() *ProductDelete {
	mutation := newProductMutation(c.config, OpDelete)
	return &ProductDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProductClient) DeleteOne(pr *Product) *ProductDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProductClient) DeleteOneID(id uuid.UUID) *ProductDeleteOne {
	builder := c.Delete().Where(product.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProductDeleteOne{builder}
}

// Query returns a query builder for Product.
func (c *ProductClient) Query() *ProductQuery {
	return &ProductQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProduct},
		inters: c.Interceptors(),
	}
}

// Get returns a Product entity by its id.
func (c *ProductClient) Get(ctx context.Context, id uuid.UUID) (*Product, error) {
	return c.Query().Where(product.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProductClient) GetX(ctx context.Context, id uuid.UUID) *Product {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProductType queries the product_type edge of a Product.
func (c *ProductClient) QueryProductType(pr *Product) *ProductTypeQuery {
	query := (&ProductTypeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(product.Table, product.FieldID, id),
			sqlgraph.To(producttype.Table, producttype.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, product.ProductTypeTable, product.ProductTypeColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTags queries the tags edge of a Product.
func (c *ProductClient) QueryTags(pr *Product) *TagQuery {
	query := (&TagClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(product.Table, product.FieldID, id),
			sqlgraph.To(tag.Table, tag.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, product.TagsTable, product.TagsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProductTags queries the product_tags edge of a Product.
func (c *ProductClient) QueryProductTags(pr *Product) *ProductTagQuery {
	query := (&ProductTagClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(product.Table, product.FieldID, id),
			sqlgraph.To(producttag.Table, producttag.ProductsColumn),
			sqlgraph.Edge(sqlgraph.O2M, true, product.ProductTagsTable, product.ProductTagsColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProductClient) Hooks() []Hook {
	return c.hooks.Product
}

// Interceptors returns the client interceptors.
func (c *ProductClient) Interceptors() []Interceptor {
	return c.inters.Product
}

func (c *ProductClient) mutate(ctx context.Context, m *ProductMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProductCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProductUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProductUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProductDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Product mutation op: %q", m.Op())
	}
}

// ProductTagClient is a client for the ProductTag schema.
type ProductTagClient struct {
	config
}

// NewProductTagClient returns a client for the ProductTag from the given config.
func NewProductTagClient(c config) *ProductTagClient {
	return &ProductTagClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `producttag.Hooks(f(g(h())))`.
func (c *ProductTagClient) Use(hooks ...Hook) {
	c.hooks.ProductTag = append(c.hooks.ProductTag, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `producttag.Intercept(f(g(h())))`.
func (c *ProductTagClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProductTag = append(c.inters.ProductTag, interceptors...)
}

// Create returns a builder for creating a ProductTag entity.
func (c *ProductTagClient) Create() *ProductTagCreate {
	mutation := newProductTagMutation(c.config, OpCreate)
	return &ProductTagCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProductTag entities.
func (c *ProductTagClient) CreateBulk(builders ...*ProductTagCreate) *ProductTagCreateBulk {
	return &ProductTagCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProductTagClient) MapCreateBulk(slice any, setFunc func(*ProductTagCreate, int)) *ProductTagCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProductTagCreateBulk{err: fmt.Errorf("calling to ProductTagClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProductTagCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProductTagCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProductTag.
func (c *ProductTagClient) Update() *ProductTagUpdate {
	mutation := newProductTagMutation(c.config, OpUpdate)
	return &ProductTagUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProductTagClient) UpdateOne(pt *ProductTag) *ProductTagUpdateOne {
	mutation := newProductTagMutation(c.config, OpUpdateOne)
	mutation.products = &pt.ProductID
	mutation.tags = &pt.TagID
	return &ProductTagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProductTag.
func (c *ProductTagClient) Delete() *ProductTagDelete {
	mutation := newProductTagMutation(c.config, OpDelete)
	return &ProductTagDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Query returns a query builder for ProductTag.
func (c *ProductTagClient) Query() *ProductTagQuery {
	return &ProductTagQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProductTag},
		inters: c.Interceptors(),
	}
}

// QueryProducts queries the products edge of a ProductTag.
func (c *ProductTagClient) QueryProducts(pt *ProductTag) *ProductQuery {
	return c.Query().
		Where(producttag.ProductID(pt.ProductID), producttag.TagID(pt.TagID)).
		QueryProducts()
}

// QueryTags queries the tags edge of a ProductTag.
func (c *ProductTagClient) QueryTags(pt *ProductTag) *TagQuery {
	return c.Query().
		Where(producttag.ProductID(pt.ProductID), producttag.TagID(pt.TagID)).
		QueryTags()
}

// Hooks returns the client hooks.
func (c *ProductTagClient) Hooks() []Hook {
	return c.hooks.ProductTag
}

// Interceptors returns the client interceptors.
func (c *ProductTagClient) Interceptors() []Interceptor {
	return c.inters.ProductTag
}

func (c *ProductTagClient) mutate(ctx context.Context, m *ProductTagMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProductTagCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProductTagUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProductTagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProductTagDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ProductTag mutation op: %q", m.Op())
	}
}

// ProductTypeClient is a client for the ProductType schema.
type ProductTypeClient struct {
	config
}

// NewProductTypeClient returns a client for the ProductType from the given config.
func NewProductTypeClient(c config) *ProductTypeClient {
	return &ProductTypeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `producttype.Hooks(f(g(h())))`.
func (c *ProductTypeClient) Use(hooks ...Hook) {
	c.hooks.ProductType = append(c.hooks.ProductType, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `producttype.Intercept(f(g(h())))`.
func (c *ProductTypeClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProductType = append(c.inters.ProductType, interceptors...)
}

// Create returns a builder for creating a ProductType entity.
func (c *ProductTypeClient) Create() *ProductTypeCreate {
	mutation := newProductTypeMutation(c.config, OpCreate)
	return &ProductTypeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProductType entities.
func (c *ProductTypeClient) CreateBulk(builders ...*ProductTypeCreate) *ProductTypeCreateBulk {
	return &ProductTypeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProductTypeClient) MapCreateBulk(slice any, setFunc func(*ProductTypeCreate, int)) *ProductTypeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProductTypeCreateBulk{err: fmt.Errorf("calling to ProductTypeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProductTypeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProductTypeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProductType.
func (c *ProductTypeClient) Update() *ProductTypeUpdate {
	mutation := newProductTypeMutation(c.config, OpUpdate)
	return &ProductTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProductTypeClient) UpdateOne(pt *ProductType) *ProductTypeUpdateOne {
	mutation := newProductTypeMutation(c.config, OpUpdateOne, withProductType(pt))
	return &ProductTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProductTypeClient) UpdateOneID(id int) *ProductTypeUpdateOne {
	mutation := newProductTypeMutation(c.config, OpUpdateOne, withProductTypeID(id))
	return &ProductTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProductType.
func (c *ProductTypeClient) Delete() *ProductTypeDelete {
	mutation := newProductTypeMutation(c.config, OpDelete)
	return &ProductTypeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProductTypeClient) DeleteOne(pt *ProductType) *ProductTypeDeleteOne {
	return c.DeleteOneID(pt.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProductTypeClient) DeleteOneID(id int) *ProductTypeDeleteOne {
	builder := c.Delete().Where(producttype.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProductTypeDeleteOne{builder}
}

// Query returns a query builder for ProductType.
func (c *ProductTypeClient) Query() *ProductTypeQuery {
	return &ProductTypeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProductType},
		inters: c.Interceptors(),
	}
}

// Get returns a ProductType entity by its id.
func (c *ProductTypeClient) Get(ctx context.Context, id int) (*ProductType, error) {
	return c.Query().Where(producttype.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProductTypeClient) GetX(ctx context.Context, id int) *ProductType {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ProductTypeClient) Hooks() []Hook {
	return c.hooks.ProductType
}

// Interceptors returns the client interceptors.
func (c *ProductTypeClient) Interceptors() []Interceptor {
	return c.inters.ProductType
}

func (c *ProductTypeClient) mutate(ctx context.Context, m *ProductTypeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProductTypeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProductTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProductTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProductTypeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ProductType mutation op: %q", m.Op())
	}
}

// TagClient is a client for the Tag schema.
type TagClient struct {
	config
}

// NewTagClient returns a client for the Tag from the given config.
func NewTagClient(c config) *TagClient {
	return &TagClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tag.Hooks(f(g(h())))`.
func (c *TagClient) Use(hooks ...Hook) {
	c.hooks.Tag = append(c.hooks.Tag, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tag.Intercept(f(g(h())))`.
func (c *TagClient) Intercept(interceptors ...Interceptor) {
	c.inters.Tag = append(c.inters.Tag, interceptors...)
}

// Create returns a builder for creating a Tag entity.
func (c *TagClient) Create() *TagCreate {
	mutation := newTagMutation(c.config, OpCreate)
	return &TagCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Tag entities.
func (c *TagClient) CreateBulk(builders ...*TagCreate) *TagCreateBulk {
	return &TagCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TagClient) MapCreateBulk(slice any, setFunc func(*TagCreate, int)) *TagCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TagCreateBulk{err: fmt.Errorf("calling to TagClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TagCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TagCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Tag.
func (c *TagClient) Update() *TagUpdate {
	mutation := newTagMutation(c.config, OpUpdate)
	return &TagUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TagClient) UpdateOne(t *Tag) *TagUpdateOne {
	mutation := newTagMutation(c.config, OpUpdateOne, withTag(t))
	return &TagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TagClient) UpdateOneID(id uuid.UUID) *TagUpdateOne {
	mutation := newTagMutation(c.config, OpUpdateOne, withTagID(id))
	return &TagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Tag.
func (c *TagClient) Delete() *TagDelete {
	mutation := newTagMutation(c.config, OpDelete)
	return &TagDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TagClient) DeleteOne(t *Tag) *TagDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TagClient) DeleteOneID(id uuid.UUID) *TagDeleteOne {
	builder := c.Delete().Where(tag.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TagDeleteOne{builder}
}

// Query returns a query builder for Tag.
func (c *TagClient) Query() *TagQuery {
	return &TagQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTag},
		inters: c.Interceptors(),
	}
}

// Get returns a Tag entity by its id.
func (c *TagClient) Get(ctx context.Context, id uuid.UUID) (*Tag, error) {
	return c.Query().Where(tag.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TagClient) GetX(ctx context.Context, id uuid.UUID) *Tag {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProducts queries the products edge of a Tag.
func (c *TagClient) QueryProducts(t *Tag) *ProductQuery {
	query := (&ProductClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tag.Table, tag.FieldID, id),
			sqlgraph.To(product.Table, product.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, tag.ProductsTable, tag.ProductsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProductTags queries the product_tags edge of a Tag.
func (c *TagClient) QueryProductTags(t *Tag) *ProductTagQuery {
	query := (&ProductTagClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tag.Table, tag.FieldID, id),
			sqlgraph.To(producttag.Table, producttag.TagsColumn),
			sqlgraph.Edge(sqlgraph.O2M, true, tag.ProductTagsTable, tag.ProductTagsColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TagClient) Hooks() []Hook {
	return c.hooks.Tag
}

// Interceptors returns the client interceptors.
func (c *TagClient) Interceptors() []Interceptor {
	return c.inters.Tag
}

func (c *TagClient) mutate(ctx context.Context, m *TagMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TagCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TagUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TagDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Tag mutation op: %q", m.Op())
	}
}

// TransactionTypeClient is a client for the TransactionType schema.
type TransactionTypeClient struct {
	config
}

// NewTransactionTypeClient returns a client for the TransactionType from the given config.
func NewTransactionTypeClient(c config) *TransactionTypeClient {
	return &TransactionTypeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `transactiontype.Hooks(f(g(h())))`.
func (c *TransactionTypeClient) Use(hooks ...Hook) {
	c.hooks.TransactionType = append(c.hooks.TransactionType, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `transactiontype.Intercept(f(g(h())))`.
func (c *TransactionTypeClient) Intercept(interceptors ...Interceptor) {
	c.inters.TransactionType = append(c.inters.TransactionType, interceptors...)
}

// Create returns a builder for creating a TransactionType entity.
func (c *TransactionTypeClient) Create() *TransactionTypeCreate {
	mutation := newTransactionTypeMutation(c.config, OpCreate)
	return &TransactionTypeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TransactionType entities.
func (c *TransactionTypeClient) CreateBulk(builders ...*TransactionTypeCreate) *TransactionTypeCreateBulk {
	return &TransactionTypeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TransactionTypeClient) MapCreateBulk(slice any, setFunc func(*TransactionTypeCreate, int)) *TransactionTypeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TransactionTypeCreateBulk{err: fmt.Errorf("calling to TransactionTypeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TransactionTypeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TransactionTypeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TransactionType.
func (c *TransactionTypeClient) Update() *TransactionTypeUpdate {
	mutation := newTransactionTypeMutation(c.config, OpUpdate)
	return &TransactionTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TransactionTypeClient) UpdateOne(tt *TransactionType) *TransactionTypeUpdateOne {
	mutation := newTransactionTypeMutation(c.config, OpUpdateOne, withTransactionType(tt))
	return &TransactionTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TransactionTypeClient) UpdateOneID(id int) *TransactionTypeUpdateOne {
	mutation := newTransactionTypeMutation(c.config, OpUpdateOne, withTransactionTypeID(id))
	return &TransactionTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TransactionType.
func (c *TransactionTypeClient) Delete() *TransactionTypeDelete {
	mutation := newTransactionTypeMutation(c.config, OpDelete)
	return &TransactionTypeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TransactionTypeClient) DeleteOne(tt *TransactionType) *TransactionTypeDeleteOne {
	return c.DeleteOneID(tt.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TransactionTypeClient) DeleteOneID(id int) *TransactionTypeDeleteOne {
	builder := c.Delete().Where(transactiontype.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TransactionTypeDeleteOne{builder}
}

// Query returns a query builder for TransactionType.
func (c *TransactionTypeClient) Query() *TransactionTypeQuery {
	return &TransactionTypeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTransactionType},
		inters: c.Interceptors(),
	}
}

// Get returns a TransactionType entity by its id.
func (c *TransactionTypeClient) Get(ctx context.Context, id int) (*TransactionType, error) {
	return c.Query().Where(transactiontype.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TransactionTypeClient) GetX(ctx context.Context, id int) *TransactionType {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *TransactionTypeClient) Hooks() []Hook {
	return c.hooks.TransactionType
}

// Interceptors returns the client interceptors.
func (c *TransactionTypeClient) Interceptors() []Interceptor {
	return c.inters.TransactionType
}

func (c *TransactionTypeClient) mutate(ctx context.Context, m *TransactionTypeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TransactionTypeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TransactionTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TransactionTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TransactionTypeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TransactionType mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id uuid.UUID) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id uuid.UUID) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id uuid.UUID) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id uuid.UUID) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUserRole queries the user_role edge of a User.
func (c *UserClient) QueryUserRole(u *User) *UserRoleQuery {
	query := (&UserRoleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(userrole.Table, userrole.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, user.UserRoleTable, user.UserRoleColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// UserRoleClient is a client for the UserRole schema.
type UserRoleClient struct {
	config
}

// NewUserRoleClient returns a client for the UserRole from the given config.
func NewUserRoleClient(c config) *UserRoleClient {
	return &UserRoleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userrole.Hooks(f(g(h())))`.
func (c *UserRoleClient) Use(hooks ...Hook) {
	c.hooks.UserRole = append(c.hooks.UserRole, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userrole.Intercept(f(g(h())))`.
func (c *UserRoleClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserRole = append(c.inters.UserRole, interceptors...)
}

// Create returns a builder for creating a UserRole entity.
func (c *UserRoleClient) Create() *UserRoleCreate {
	mutation := newUserRoleMutation(c.config, OpCreate)
	return &UserRoleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserRole entities.
func (c *UserRoleClient) CreateBulk(builders ...*UserRoleCreate) *UserRoleCreateBulk {
	return &UserRoleCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserRoleClient) MapCreateBulk(slice any, setFunc func(*UserRoleCreate, int)) *UserRoleCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserRoleCreateBulk{err: fmt.Errorf("calling to UserRoleClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserRoleCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserRoleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserRole.
func (c *UserRoleClient) Update() *UserRoleUpdate {
	mutation := newUserRoleMutation(c.config, OpUpdate)
	return &UserRoleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserRoleClient) UpdateOne(ur *UserRole) *UserRoleUpdateOne {
	mutation := newUserRoleMutation(c.config, OpUpdateOne, withUserRole(ur))
	return &UserRoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserRoleClient) UpdateOneID(id int) *UserRoleUpdateOne {
	mutation := newUserRoleMutation(c.config, OpUpdateOne, withUserRoleID(id))
	return &UserRoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserRole.
func (c *UserRoleClient) Delete() *UserRoleDelete {
	mutation := newUserRoleMutation(c.config, OpDelete)
	return &UserRoleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserRoleClient) DeleteOne(ur *UserRole) *UserRoleDeleteOne {
	return c.DeleteOneID(ur.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserRoleClient) DeleteOneID(id int) *UserRoleDeleteOne {
	builder := c.Delete().Where(userrole.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserRoleDeleteOne{builder}
}

// Query returns a query builder for UserRole.
func (c *UserRoleClient) Query() *UserRoleQuery {
	return &UserRoleQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserRole},
		inters: c.Interceptors(),
	}
}

// Get returns a UserRole entity by its id.
func (c *UserRoleClient) Get(ctx context.Context, id int) (*UserRole, error) {
	return c.Query().Where(userrole.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserRoleClient) GetX(ctx context.Context, id int) *UserRole {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *UserRoleClient) Hooks() []Hook {
	return c.hooks.UserRole
}

// Interceptors returns the client interceptors.
func (c *UserRoleClient) Interceptors() []Interceptor {
	return c.inters.UserRole
}

func (c *UserRoleClient) mutate(ctx context.Context, m *UserRoleMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserRoleCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserRoleUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserRoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserRoleDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserRole mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Conversation, FinancialTransaction, Invoice, InvoiceLineItem, InvoiceStatusCode,
		InvoiceType, Message, MessageType, Order, OrderLineItem, OrderStatusCode,
		OrderType, PaymentMethod, Product, ProductTag, ProductType, Tag,
		TransactionType, User, UserRole []ent.Hook
	}
	inters struct {
		Conversation, FinancialTransaction, Invoice, InvoiceLineItem, InvoiceStatusCode,
		InvoiceType, Message, MessageType, Order, OrderLineItem, OrderStatusCode,
		OrderType, PaymentMethod, Product, ProductTag, ProductType, Tag,
		TransactionType, User, UserRole []ent.Interceptor
	}
)
